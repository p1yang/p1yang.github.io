

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="p1yang">
  <meta name="keywords" content="">
  
    <meta name="description" content="1.1 Ghidra背景 1.1.1 什么是Ghidra Ghidra是一个由美国国家安全局（NSA）研究部门创造并维护的软件逆向工程框架。这个框架包括了一套完善的软件分析工具，涵盖了反汇编、汇编、反编译、图形化以及许多其他有用的功能。 美国国家安全局于2019年3月将Ghidra开源放出。Ghidra的官方GitHub项目地址在 https:&#x2F;&#x2F;github.com&#x2F;NationalSecuri">
<meta property="og:type" content="article">
<meta property="og:title" content="p1yang">
<meta property="og:url" content="http://example.com/article/0.html">
<meta property="og:site_name" content="p1yang">
<meta property="og:description" content="1.1 Ghidra背景 1.1.1 什么是Ghidra Ghidra是一个由美国国家安全局（NSA）研究部门创造并维护的软件逆向工程框架。这个框架包括了一套完善的软件分析工具，涵盖了反汇编、汇编、反编译、图形化以及许多其他有用的功能。 美国国家安全局于2019年3月将Ghidra开源放出。Ghidra的官方GitHub项目地址在 https:&#x2F;&#x2F;github.com&#x2F;NationalSecuri">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="blob:file:///3333d5b7-4c46-4884-b848-266b0063445c">
<meta property="og:image" content="blob:file:///fde779bb-5a0e-4537-8eb5-9869529ca23b">
<meta property="og:image" content="blob:file:///90764224-7175-4f7d-ba1b-4e2d83dc08c8">
<meta property="og:image" content="blob:file:///a7bd0605-c774-4ce1-98d0-ef51419c73de">
<meta property="og:image" content="blob:file:///7fe12308-2fac-4798-8379-d72406fa52e1">
<meta property="og:image" content="blob:file:///6cbf9dc1-7502-4200-a477-d09ec3c25d5e">
<meta property="og:image" content="blob:file:///4a40fdd0-193d-4bca-8b7b-3a8afa61b09f">
<meta property="og:image" content="blob:file:///84f21f27-401b-4984-bf17-e1178eb93ebe">
<meta property="og:image" content="blob:file:///4ac76f2d-234e-4a5e-8b8e-2c899ac19d56">
<meta property="og:image" content="blob:file:///324cf6ed-de35-4745-ab77-b4ce3dbabfe6">
<meta property="og:image" content="blob:file:///974a7bf4-40c6-428f-850d-999c73364f1a">
<meta property="og:image" content="blob:file:///6dbe7925-f883-4050-977b-81d948467275">
<meta property="og:image" content="blob:file:///b8882b93-1971-45f6-9b2c-9f49985d8744">
<meta property="og:image" content="blob:file:///935ff513-14bf-4a9d-af34-af13359a5f06">
<meta property="og:image" content="blob:file:///71327e8e-bd7e-4e01-88e0-9a23d9afb646">
<meta property="og:image" content="blob:file:///00e070cd-feb1-491a-a6d7-c0641450fcf2">
<meta property="og:image" content="blob:file:///4f29eb25-d960-4ab4-aff8-7e21742a9b7b">
<meta property="og:image" content="blob:file:///04e593b4-3314-4a21-be05-34ebeed3cb60">
<meta property="og:image" content="blob:file:///203d4c55-597f-428b-b109-63567154fd3c">
<meta property="og:image" content="blob:file:///71bb9177-21cb-46e6-b0aa-b6eda2bd4363">
<meta property="og:image" content="blob:file:///4f6fe3e0-2114-4719-8abc-377c586c5a47">
<meta property="og:image" content="blob:file:///eae41902-5096-45aa-a311-00b0e9c77af5">
<meta property="og:image" content="blob:file:///3b60be62-5d02-4a15-ac9f-7839c65923ec">
<meta property="og:image" content="blob:file:///39d43dd4-9656-4bd3-8649-a371423e3aff">
<meta property="og:image" content="blob:file:///684a725f-f3af-4343-931c-3b7c6d2d2e53">
<meta property="og:image" content="blob:file:///17a5fc8f-705f-46a3-b43f-f8ae59fd8fbf">
<meta property="og:image" content="blob:file:///3badda1d-4874-4ae6-ac25-66c3957a1ae8">
<meta property="og:image" content="blob:file:///a9d1bebc-d940-40b6-9af8-54afd691d02c">
<meta property="og:image" content="blob:file:///26c484f6-39ca-4abd-ade6-fb50b0ea5fe7">
<meta property="og:image" content="blob:file:///75f032ce-6137-4b57-bdf3-1d3b708dc599">
<meta property="og:image" content="blob:file:///a6a57ecd-b300-49b8-afae-46c3e8329071">
<meta property="og:image" content="blob:file:///661babf3-fd99-4dcf-a1c3-f3390a17f662">
<meta property="og:image" content="blob:file:///3e7fac23-6e12-4432-8cfc-2983c00c7006">
<meta property="og:image" content="blob:file:///31a036fe-8373-4599-8b9e-3167e40b219d">
<meta property="og:image" content="blob:file:///4d4409ec-0d5d-4de8-9b3c-acd38435e752">
<meta property="og:image" content="blob:file:///4ce037d7-8b0b-475a-8a0c-93e1a3a88dd0">
<meta property="og:image" content="blob:file:///fac046ef-7325-4f12-aafe-785d188f27ca">
<meta property="og:image" content="blob:file:///02b91a3d-74d8-454f-a842-9f18dce7cf4c">
<meta property="og:image" content="blob:file:///6a3889a1-2c83-4af8-8c8b-ca0aecaadf46">
<meta property="og:image" content="blob:file:///4de37e8e-88cb-43c5-9349-a642f540acf5">
<meta property="og:image" content="blob:file:///f4b27ff2-a36a-491c-a9d9-3b144b7dcb68">
<meta property="og:image" content="blob:file:///6f751c5b-7bb8-45e3-b618-788785e9139f">
<meta property="og:image" content="blob:file:///7327ba3d-ab73-44ae-9d80-6df3c31947ce">
<meta property="og:image" content="blob:file:///f06cc77c-0761-4f77-8111-3d1665288c18">
<meta property="og:image" content="blob:file:///6d6f7502-c22f-4627-92da-a069590e1422">
<meta property="og:image" content="blob:file:///6b105190-97c9-4407-8fb4-3bf7e63b1115">
<meta property="og:image" content="blob:file:///bcb48e33-c8db-4631-b35d-cd0f64dd0300">
<meta property="og:image" content="blob:file:///96b34efc-7e94-48e3-9302-d7e855ac9ebf">
<meta property="og:image" content="blob:file:///53bc70fd-e581-4e2b-a003-6df3d3b22239">
<meta property="og:image" content="blob:file:///ac21f0a6-85ea-4097-aa8e-6d4dccf8062d">
<meta property="og:image" content="blob:file:///1e0dfd22-4ed0-4aff-b72d-fcf403cd3698">
<meta property="og:image" content="blob:file:///b0f1e5d2-614c-42fe-80c5-7c01931e64bb">
<meta property="og:image" content="blob:file:///aa3508c8-10bf-472f-ad20-28e8bab7bb67">
<meta property="og:image" content="blob:file:///e69f4d78-fe62-4487-b18b-a29ddd50883b">
<meta property="og:image" content="blob:file:///c6dfb78a-abc9-48f0-a80b-264c69e92ead">
<meta property="og:image" content="blob:file:///05cb3061-cf25-4a94-82fd-729b652e0fc1">
<meta property="og:image" content="blob:file:///4e93adb5-780c-4749-9f16-4db646311378">
<meta property="og:image" content="blob:file:///537b7684-a005-4d9c-8b4e-80969ea209ac">
<meta property="og:image" content="blob:file:///68d532b6-250f-4c8f-a6f0-6b9b63f6e73a">
<meta property="og:image" content="blob:file:///278b1cd3-0314-4ff7-9349-c81ffe407f1f">
<meta property="og:image" content="blob:file:///7903c1f3-cb7e-41ea-b47a-5180381388c7">
<meta property="og:image" content="blob:file:///bbd8ab58-f262-4e7e-8328-e7d6bb8c528f">
<meta property="og:image" content="blob:file:///2aacb2a0-2c71-4fdd-b277-182df4b4e768">
<meta property="og:image" content="blob:file:///024a3cdf-eab4-43f0-b91b-9f1c034c9e0c">
<meta property="og:image" content="blob:file:///78cd63b9-0f0a-43a0-aa95-b7ac0786c832">
<meta property="og:image" content="blob:file:///3cbe2b45-d099-475c-ab4a-163a93e3d192">
<meta property="og:image" content="blob:file:///90ab3df1-bafc-4ed4-99cb-eef640cd4830">
<meta property="og:image" content="blob:file:///fe9fd416-44a4-4120-9a38-1bd611de9bfd">
<meta property="og:image" content="blob:file:///db9a69d7-15c2-4548-aa26-dc36911c12c8">
<meta property="og:image" content="blob:file:///d7300c64-8e34-409b-afbb-cca766a1fffa">
<meta property="og:image" content="blob:file:///94898c87-f5b5-4040-852f-4436296d4771">
<meta property="og:image" content="blob:file:///d7300c64-8e34-409b-afbb-cca766a1fffa">
<meta property="og:image" content="blob:file:///affbf168-9d35-4117-ba33-e163824f2eca">
<meta property="og:image" content="blob:file:///fe9fd416-44a4-4120-9a38-1bd611de9bfd">
<meta property="og:image" content="blob:file:///20ba336d-5d84-4da0-9648-5d320f43bb8e">
<meta property="og:image" content="blob:file:///2a17151c-d87d-45c1-94cb-5f350041e817">
<meta property="og:image" content="blob:file:///989f6ef7-5cdb-4700-bd29-fac005085247">
<meta property="og:image" content="blob:file:///73b24c5a-b7c9-490e-818d-b3d84a34d645">
<meta property="og:image" content="blob:file:///9d9e3fa3-1211-409d-9ee1-fc59c33ff9dc">
<meta property="og:image" content="blob:file:///15330b32-f32a-4bfb-bbce-df55e7adfa5a">
<meta property="og:image" content="blob:file:///761f00f3-3a63-4528-998f-127ea3cbb2fc">
<meta property="og:image" content="blob:file:///ee54a746-0f9b-4c14-9c97-85e83c553b9c">
<meta property="og:image" content="blob:file:///c1d67edb-4c95-43e1-9360-18cff27fe73c">
<meta property="og:image" content="blob:file:///efb20046-8b4f-4350-bf60-3fa4baa6625f">
<meta property="og:image" content="blob:file:///a54b5112-82e6-479d-a900-7d099b882a63">
<meta property="og:image" content="blob:file:///47b6a4a4-e06a-4843-a803-778708560749">
<meta property="og:image" content="blob:file:///979e1cbc-2fe2-42b3-866e-c1978478dd87">
<meta property="og:image" content="blob:file:///fa42ca82-e076-4230-b10a-87651fe850ed">
<meta property="og:image" content="blob:file:///eec75e83-da95-444b-b29c-d231f941e59a">
<meta property="og:image" content="blob:file:///b6859724-20d3-40b3-87d0-963cb421a013">
<meta property="og:image" content="blob:file:///d47c6079-46fb-4f67-8d24-2330661faf71">
<meta property="og:image" content="blob:file:///48e45e09-6b65-4b3a-b26f-b3938af6b482">
<meta property="og:image" content="blob:file:///f6f18bc5-f9e5-4eca-a0de-ddc53629eb71">
<meta property="og:image" content="blob:file:///c230271a-8911-445b-bd74-21d680772770">
<meta property="og:image" content="blob:file:///25fdcd48-1482-4105-b8d1-353011bb3df2">
<meta property="og:image" content="blob:file:///7c3fc960-cbeb-4989-99cb-a00c30d1af58">
<meta property="og:image" content="blob:file:///5b92da69-af65-4289-b71c-e6c04bc61a9f">
<meta property="og:image" content="blob:file:///46fccc96-2d27-437d-9208-5be625a18f9d">
<meta property="og:image" content="blob:file:///590353a1-2059-4777-92ac-755ea4215553">
<meta property="og:image" content="blob:file:///9cf55f61-34b0-4e5d-a419-7cdb0476037a">
<meta property="og:image" content="blob:file:///ef27a1e9-3bfe-48ca-963d-61be4b41fb4f">
<meta property="og:image" content="blob:file:///fce662b5-df8f-459f-b24d-a06afcb7b041">
<meta property="og:image" content="blob:file:///4b69dfa4-6a93-4f4e-ac51-9f6c5d865105">
<meta property="og:image" content="blob:file:///bffa37d6-02d6-4d09-ac5c-486aa99e4054">
<meta property="og:image" content="blob:file:///7fa04861-c4d4-4217-96d9-5ce02ddfd3c6">
<meta property="og:image" content="blob:file:///745c3cbc-86d7-4f73-8cc5-f63086f4b8de">
<meta property="og:image" content="blob:file:///d22fcd00-bf2b-4dd5-a578-fca2b4117b35">
<meta property="og:image" content="blob:file:///dd5cc85a-4fe6-4289-ba17-407f60450dc0">
<meta property="og:image" content="blob:file:///3aaada51-8c58-4f56-83e5-374e1cbf6248">
<meta property="og:image" content="blob:file:///e002abbc-9f39-49ac-83b1-c9336bced43c">
<meta property="og:image" content="blob:file:///c1efdf53-fbe5-4743-9bf5-98b452e20a4b">
<meta property="og:image" content="blob:file:///701e22ef-6302-4f91-bc44-1e2b90e797b2">
<meta property="og:image" content="blob:file:///78403896-fdcb-4a45-bdf6-2c2047e07187">
<meta property="og:image" content="blob:file:///3d322ce1-39c5-421c-aa8f-f6e4ade9b4ae">
<meta property="og:image" content="blob:file:///383d3460-c550-4b61-85d4-2c3214796d17">
<meta property="og:image" content="blob:file:///5e781f89-46f3-44d0-baa2-b0bb934fe4b2">
<meta property="og:image" content="blob:file:///6009ec30-64ed-4858-a6dd-ccdec5e39299">
<meta property="og:image" content="blob:file:///4833c618-ef07-4b49-8b16-c317eb077894">
<meta property="og:image" content="blob:file:///99019444-603e-4998-8e59-d00d67e2e851">
<meta property="og:image" content="blob:file:///1fd72b30-eee9-4827-ba24-bcd9b6430958">
<meta property="og:image" content="blob:file:///8127b96f-2217-498e-b309-b1caffb4ef26">
<meta property="og:image" content="blob:file:///a24b24a4-dc92-4376-87b4-86fa052f5d3c">
<meta property="og:image" content="blob:file:///0d972ff8-ca55-4539-9b37-de9b73e1e32e">
<meta property="og:image" content="blob:file:///901f0c9d-113b-4bae-a138-0d74a8678970">
<meta property="og:image" content="blob:file:///78f21e4d-2ff4-4388-b9dd-2b81c0f61a26">
<meta property="og:image" content="blob:file:///820d52a9-67ca-4e1d-8d9b-d307cce75564">
<meta property="og:image" content="blob:file:///c74bb980-7a42-4f48-a61d-d75065fb0d57">
<meta property="og:image" content="blob:file:///c8eac30a-d298-4e94-ad7f-a271d44a428a">
<meta property="og:image" content="blob:file:///e283aad3-6f3c-473b-9d11-86118a476768">
<meta property="og:image" content="blob:file:///991181b0-541c-4d80-a4df-ac6bcb4f568d">
<meta property="og:image" content="blob:file:///fdc17af2-9efb-47b4-b883-921da261eb46">
<meta property="og:image" content="blob:file:///0829fc2a-affa-4b60-8ce3-e12ab45a123b">
<meta property="og:image" content="blob:file:///2c9e6176-ccba-4417-8df9-572ed15c8e48">
<meta property="og:image" content="blob:file:///b715a642-4759-4846-8447-28923f0d8cd7">
<meta property="og:image" content="blob:file:///66c3c21d-e61c-416e-a8dd-e1809681d973">
<meta property="og:image" content="blob:file:///de3cdb4e-3468-459b-b3cb-df404e95f1d4">
<meta property="og:image" content="blob:file:///23eb0778-4b28-40e4-b282-4e01bfa9040e">
<meta property="og:image" content="blob:file:///31251f5d-3f37-4340-b8ff-1d4d6dd16eb3">
<meta property="og:image" content="blob:file:///ffcdc5e8-4305-4a6f-a9d1-ef1d6259fd96">
<meta property="og:image" content="blob:file:///91631757-9ad1-47e2-9db4-d05db8b34f26">
<meta property="og:image" content="blob:file:///fe1c1c41-1058-4364-8fa3-8fbb56750ef4">
<meta property="og:image" content="blob:file:///c0da2c7d-880a-43a0-9f5d-84db698be028">
<meta property="og:image" content="blob:file:///d219b049-af8b-486c-9427-668203be254a">
<meta property="og:image" content="blob:file:///f55d742d-ed42-4129-9fbd-9e82bb3d14a6">
<meta property="og:image" content="blob:file:///9f51545a-9e22-4723-a914-f7b818f76b74">
<meta property="og:image" content="blob:file:///7f97146d-e78d-48ac-8bea-1a1f9a82b628">
<meta property="og:image" content="blob:file:///db8d3e6d-857f-4403-b50c-1f95e77cd6d4">
<meta property="og:image" content="blob:file:///4714e620-91c6-4f6a-84db-f981d55b0cc5">
<meta property="og:image" content="blob:file:///bb5dd84f-51a6-44bd-ad47-5074cae623cb">
<meta property="og:image" content="blob:file:///9d4e475f-e022-423e-b297-c807db25da21">
<meta property="og:image" content="blob:file:///943dafdd-d8c5-4211-9566-5d692ca18d44">
<meta property="og:image" content="blob:file:///d8c8718d-f865-4123-beb0-0ed117f0437a">
<meta property="og:image" content="blob:file:///661398ae-3c61-4a54-ac9c-7ab8d8f7e324">
<meta property="og:image" content="blob:file:///117132cc-d6b0-4738-be89-2cdfe7f2f34a">
<meta property="og:image" content="blob:file:///9d4e475f-e022-423e-b297-c807db25da21">
<meta property="og:image" content="blob:file:///14f3a8af-999f-4baa-9876-e305f1891ffd">
<meta property="og:image" content="blob:file:///5fede103-2144-4d90-aa33-dd1b9b0d9327">
<meta property="og:image" content="blob:file:///1ca0e258-0040-43bb-b351-51626c3e16b7">
<meta property="og:image" content="blob:file:///175a3266-ff2c-48ca-aaa1-d74868975082">
<meta property="og:image" content="blob:file:///1d55e3b9-9a8c-4f80-870b-e3aaae809498">
<meta property="og:image" content="blob:file:///f9cc4f69-93fd-48f4-9ea4-1799313cf8e9">
<meta property="og:image" content="blob:file:///b0f5445e-fee6-4597-978d-aefdab70759e">
<meta property="og:image" content="blob:file:///4732bcb5-8928-4404-b174-1eecc2ddead3">
<meta property="og:image" content="blob:file:///f6412645-f429-446b-847a-50682e323765">
<meta property="og:image" content="blob:file:///025f17f8-1789-449d-a10e-cfd4c1b9c302">
<meta property="og:image" content="blob:file:///bbf711ab-67f5-4804-ac42-7ec94049bf9d">
<meta property="og:image" content="blob:file:///6cb63dda-9a4b-4e9d-87a8-491eededb267">
<meta property="og:image" content="blob:file:///ec60bd57-c74c-4a97-9180-6f484988a748">
<meta property="og:image" content="blob:file:///b9af46db-7237-45a6-baba-2f6d47fe4702">
<meta property="og:image" content="blob:file:///a56627cd-08aa-4801-aded-2495f3d1a335">
<meta property="og:image" content="blob:file:///cbe5bf81-c145-4005-9ab3-591a1fe96f15">
<meta property="og:image" content="blob:file:///f829efe2-d78f-480e-a83d-e4e750c21c17">
<meta property="og:image" content="blob:file:///9e38c90f-b63b-463f-ab79-6642ea40b04d">
<meta property="og:image" content="blob:file:///68ca5d4f-0800-402d-b0d2-4013b1f0be4d">
<meta property="og:image" content="blob:file:///093d0de1-20cf-4a2e-a350-8d251b9063af">
<meta property="og:image" content="blob:file:///e86c6024-cc4f-4551-841b-dfc45f39a7a5">
<meta property="og:image" content="blob:file:///9454d3f3-b86f-42d6-9f7d-fb32b5f180de">
<meta property="og:image" content="blob:file:///0df42c41-01fd-49fd-833e-f3fa9b5795f3">
<meta property="og:image" content="blob:file:///e87d360d-d7b3-429c-a8fd-aa11fe859130">
<meta property="og:image" content="blob:file:///06275063-b049-46db-ad20-e01e7e914f8d">
<meta property="og:image" content="blob:file:///a6b9771f-0ce0-496e-a6b8-13e2441891e7">
<meta property="og:image" content="blob:file:///91b90a57-f196-48a6-b3e1-d16674a5cefc">
<meta property="og:image" content="blob:file:///6c074e68-38bb-4c4f-a02a-b2475cced529">
<meta property="og:image" content="blob:file:///2143d30d-16b0-47c9-ae05-1fdc9ef8f438">
<meta property="og:image" content="blob:file:///16b6e810-b322-4ce0-9e5c-f8468f373007">
<meta property="og:image" content="blob:file:///52b83e9a-477d-4dd9-9ae8-b313947207ce">
<meta property="og:image" content="blob:file:///1dafc404-0ff5-4410-81eb-29928c6b69f7">
<meta property="og:image" content="blob:file:///7d6e2c1a-8175-468e-83e2-7b52bf199b49">
<meta property="og:image" content="blob:file:///12ae3b45-739b-4157-8e49-4db35328184b">
<meta property="og:image" content="blob:file:///f90ab40f-8cce-420a-aea9-511ebc3f5d89">
<meta property="og:image" content="blob:file:///0b09560d-a9a3-43cd-8986-ba4c8735fedf">
<meta property="og:image" content="blob:file:///a32d6273-0729-41fd-af37-52102183b2aa">
<meta property="og:image" content="blob:file:///a98abec8-026d-4feb-8426-bd9e8c020014">
<meta property="og:image" content="blob:file:///d5556505-5ab4-47b0-987f-02ec2b6f6ede">
<meta property="og:image" content="blob:file:///b51822d9-ea44-431c-9dec-40794823fe2c">
<meta property="og:image" content="blob:file:///d6d3d540-3b80-4b5e-b021-3778b66a7cc9">
<meta property="og:image" content="blob:file:///606a11bd-2916-464a-a071-03b7138456b8">
<meta property="og:image" content="blob:file:///ec450adb-a3fd-4ec5-a595-d4bb8bca2017">
<meta property="og:image" content="blob:file:///2ebca1bd-6cab-4732-9fcf-66ba07707a1e">
<meta property="og:image" content="blob:file:///e18b3640-8529-4ebb-b089-5fc1cc4f1d22">
<meta property="og:image" content="blob:file:///18d89be8-d55d-4f3e-80ea-528534b73d77">
<meta property="og:image" content="blob:file:///30692ab1-bc47-4206-b82d-d6862722a080">
<meta property="og:image" content="blob:file:///3e390dac-a8ec-46b3-975e-416e4b5cfe13">
<meta property="og:image" content="blob:file:///ff2368c2-732c-4498-9556-b56de7f246c1">
<meta property="og:image" content="blob:file:///5073e1bf-633b-4a03-907a-15fe88c2ee67">
<meta property="og:image" content="blob:file:///2641fb4f-bac9-45e1-bb91-1d6c9e4c0531">
<meta property="og:image" content="blob:file:///67dd8d26-a9c3-4251-839d-37cd7879b39d">
<meta property="og:image" content="blob:file:///486db3f4-1b6c-4aef-91b3-3493be5ab49e">
<meta property="og:image" content="blob:file:///9f894896-6c7c-48ec-b3a0-53417aca94ad">
<meta property="og:image" content="blob:file:///4eb12c82-d250-4e8b-96b3-887fa98b947d">
<meta property="og:image" content="blob:file:///18145e9e-96bf-4316-9fb9-8d771354d62c">
<meta property="og:image" content="blob:file:///7666e597-fc69-4634-8684-1bcc3a36b027">
<meta property="og:image" content="blob:file:///c6e2c8a3-ff21-4d0e-82b2-016bd71ce595">
<meta property="og:image" content="blob:file:///eb965567-638d-445a-b7eb-a19c2191dec6">
<meta property="og:image" content="blob:file:///2271f780-cd65-416f-8ad5-0f3a7300f1ab">
<meta property="og:image" content="blob:file:///5ae5499f-eea4-4e16-aa89-404daf151d51">
<meta property="og:image" content="blob:file:///f510a5ee-e034-4c3d-97d5-9f93a644a5ea">
<meta property="og:image" content="blob:file:///05d2682a-591d-4900-b07e-3c3bdfcb8358">
<meta property="og:image" content="blob:file:///3bff1b5c-1dbd-402d-b07e-d1783c9f668b">
<meta property="og:image" content="blob:file:///35861b4a-7b78-41d8-ad4d-f80b28acedfe">
<meta property="og:image" content="blob:file:///0fa7b222-cb70-4c77-b925-a6fe26c55696">
<meta property="og:image" content="blob:file:///4ce581fe-0a31-4815-8809-6c490c885d7a">
<meta property="og:image" content="blob:file:///dea09ba3-3188-4c7e-8cd4-94a9ba00f859">
<meta property="og:image" content="blob:file:///0fc5ccf4-0640-4a2d-a6a6-642bf4a84654">
<meta property="og:image" content="blob:file:///f24c1282-df5a-41a7-8ed6-132c1d09a691">
<meta property="og:image" content="blob:file:///a4c1651c-0701-479e-9f5d-e6619a2e415d">
<meta property="og:image" content="blob:file:///f8c120bd-2fe3-445b-8320-57846a47c327">
<meta property="article:published_time" content="2023-08-29T07:20:48.901Z">
<meta property="article:modified_time" content="2023-08-29T09:55:57.243Z">
<meta property="article:author" content="p1yang">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="blob:file:///3333d5b7-4c46-4884-b848-266b0063445c">
  
  
  
  <title>p1yang</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>p1yang&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-29 15:20" pubdate>
          August 29, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          63k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          525 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
            
              <div class="markdown-body">
                
                <p><strong>1.1 Ghidra背景</strong></p>
<p><strong>1.1.1 什么是Ghidra</strong></p>
<p>Ghidra是一个由美国国家安全局（NSA）研究部门创造并维护的软件逆向工程框架。这个框架包括了一套完善的软件分析工具，涵盖了反汇编、汇编、反编译、图形化以及许多其他有用的功能。</p>
<p>美国国家安全局于2019年3月将Ghidra开源放出。Ghidra的官方GitHub项目地址在 <a target="_blank" rel="noopener" href="https://github.com/NationalSecurityAgency/ghidra">https://github.com/NationalSecurityAgency/ghidra</a> 。</p>
<p><img src="blob:file:///3333d5b7-4c46-4884-b848-266b0063445c" srcset="/img/loading.gif" lazyload alt="202004030932_X468CWWAYFY7KSC.png"></p>
<p>图1-1 Ghidra的LOGO</p>
<p><strong>1.1.2 为什么用Ghidra*</strong>*</p>
<p><strong>(1) 基本功能</strong></p>
<p>Ghidra涵盖了同类型工具如IDA Pro、Radare、Binary Ninja等所拥有的大部分功能，并将这些功能完善地整合在了一起。Ghidra也支持大量的处理器指令集与可执行格式。</p>
<p><strong>(2) 兼容性</strong></p>
<p>用Java编写的Ghidra能够在Windows、macOS、Linux等主流平台上运行。</p>
<p><strong>(3) 对于团队作业的高度支持</strong></p>
<p>软件逆向工程可以是非常庞大的任务。用户可以通过配置Ghidra Server来简易可靠地实现多个用户共同工作的目标。Ghidra Server提供了权限管理、版本管理等功能。我们会在后面的章节讲到有关Ghidra Server的具体操作。</p>
<p><strong>(4) 定制化与高度可扩展性</strong></p>
<p>Ghidra整合了许多的【插件】，每个插件提供特定的功能。【工具】（tools）则是插件与插件配置的集合。用户可以自定义插件与工具的配置、创建新的工具、编写自己的插件。从UI到功能的可自定义性，Ghidra能够满足绝大多数用户的需求。</p>
<p><strong>(5) 操作撤回</strong></p>
<p>这是Ghidra提供的一个虽然小巧却非常实用的功能，允许用户对操作进行撤回（Undo）和重做(Redo)。当然，操作的储存深度也是可以由用户自定义的。</p>
<p><img src="blob:file:///fde779bb-5a0e-4537-8eb5-9869529ca23b" srcset="/img/loading.gif" lazyload alt="202004030933_79SQBZDTYRNVCRQ.png"></p>
<p>图1-2 撤回与重做</p>
<p><strong>(6) 开源</strong></p>
<p>Ghidra在2019年3月之后已经被开源，协议为Apache License 2.0。该协议允许用户对代码进行更改与再发布。</p>
<p>图1-3 Ghidra的开源协议</p>
<p>而市面上主流的同类工具，以IDA Pro为例，则是价格不菲。</p>
<p><img src="blob:file:///90764224-7175-4f7d-ba1b-4e2d83dc08c8" srcset="/img/loading.gif" lazyload alt="202004030933_GVCD7MYZWD89GJR.png"></p>
<p>图1-4 IDA Pro售价</p>
<p>#ghidra使用手册</p>
<p><strong>1.2 安装、配置环境与运行</strong></p>
<p><strong>1.2.1 配置要求</strong> </p>
<p><strong>硬件</strong></p>
<p>4GB RAM，1 GB 存储空间，双显示器或多显示器最佳</p>
<p><strong>平台</strong></p>
<p>Microsoft Windows 7 或 10 (64-bit)</p>
<p>Linux (64-bit, CentOS 7 最佳)</p>
<p>macOS (OS X) 10.8.3+</p>
<p>不支持32位的操作系统</p>
<p><strong>软件</strong></p>
<p>Java 11 Runtime and Development Kit（JDK）</p>
<p>推荐使用的环境为OpenJDK</p>
<p><strong>1.2.2 下载</strong></p>
<p>用户可以于Ghidra官网（<a target="_blank" rel="noopener" href="https://ghidra-sre.org/%EF%BC%89%E4%B8%8B%E8%BD%BDGhidra%E7%9A%84%E6%9C%80%E6%96%B0%E5%8E%8B%E7%BC%A9%E5%8C%85%EF%BC%88%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BE%8E%E5%9B%BD%E4%BB%A3%E7%90%86%EF%BC%89%E3%80%82Ghidra%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6%E5%B0%B1%E8%83%BD%E4%BD%BFGhidra%E5%8F%91%E8%A1%8C%E7%89%88%E5%9C%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B0%B1%E4%BD%8D%E3%80%82%E4%BD%BF%E7%94%A8%E8%AF%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E4%BE%BF%E8%83%BD%E5%A4%9F%E5%AE%89%E8%A3%85Ghidra%E6%9D%A5%E4%BD%BF%E7%94%A8%E3%80%82%E5%8F%A6%E5%A4%96%EF%BC%8C%E7%A7%BB%E9%99%A4Ghidra%E5%8F%AA%E9%9C%80%E8%A6%81%E7%AE%80%E5%8D%95%E5%9C%B0%E5%88%A0%E9%99%A4Ghidra%E7%9A%84%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E3%80%82">https://ghidra-sre.org/）下载Ghidra的最新压缩包（可能需要使用美国代理）。Ghidra没有使用传统的安装程序，直接提取文件就能使Ghidra发行版在文件系统中就位。使用该方法的好处是，不需要管理员权限便能够安装Ghidra来使用。另外，移除Ghidra只需要简单地删除Ghidra的安装目录。</a></p>
<p><img src="blob:file:///a7bd0605-c774-4ce1-98d0-ef51419c73de" srcset="/img/loading.gif" lazyload alt="202004030933_GAU3BZ9U9CYSHH3.png"></p>
<p>图1-5 下载</p>
<p><strong>1.2.3 配置环境</strong></p>
<p>Ghidra需要特定版本的JDK位于PATH中才能够运行。如果PATH中的Java版本Ghidra并不支持，它将使用该版本的Java来寻找用户系统中受支持的Java版本。如果仍然找不到受支持的Java版本，用户会被要求输入一个Java的主目录以供使用。</p>
<p>Ghidra是通过OpenJDK进行的开发与测试，因此我们建议使用这个OpenJDK来获取最稳定的体验。</p>
<p>如果Ghidra由于PATH中没有任何版本的Java而不能运行，用户需要手动安装一个受支持的JDK并将其添加到PATH，以下是操作流程：</p>
<p><strong>(1) Windows</strong></p>
<p>1 提取JDK发行版本(.zip文件)，之后</p>
<p>Windows 10: 右键点击左下角Windows键，然后点击【系统】</p>
<p>Windows 7: 点击左下角Windows键，右键点击【计算机】，点击【属性】</p>
<p>2 点击【系统信息】，之后点击【高级系统设置】</p>
<p>3 点击【环境变量】</p>
<p>4 在【系统变量】下方，选中Path，并点击【编辑】</p>
<p>5 在【编辑系统变量】的窗口中，在变量值的最后加入一个分号“;”，并接着输入&lt;JDK目录的路径&gt;bin</p>
<p>6 确认以上修改</p>
<p><strong>(2) Linux 与macOS (OS X)</strong></p>
<p>1 提取JDK。</p>
<p>tar xvf &lt;JDK文件.tar.gz&gt;</p>
<p>2 用编辑器打开~&#x2F;.bashrc，譬如</p>
<p>vi ~&#x2F;.bashrc</p>
<p>3 在文件最后，将JDK的bin目录加入PATH变量。</p>
<p>export PATH&#x3D;&lt;提取出的JDK目录路径&gt;&#x2F;bin:$PATH</p>
<p>4 保存文件。</p>
<p>5 重启所有终端来让改动生效。</p>
<p>在一些情况下，用户可能希望以特定版本的Java来启动Ghidra。我们设置support&#x2F;launch.properties中的JAVA_HOME_OVERRIDE。如果该属性被设置为一个不兼容的Java版本，Ghidra会自动定位一个兼容版本。需要注意的是，PATH中一定要存在某个Java来使JAVA_HOME_OVERRIDE属性生效。</p>
<p><img src="blob:file:///7fe12308-2fac-4798-8379-d72406fa52e1" srcset="/img/loading.gif" lazyload alt="202004030934_TAEXD5KNR6BBJJN.png"></p>
<p>图1-6 JAVA_HOME_OVERRIDE属性</p>
<p><strong>1.2.4 运行</strong></p>
<p>切换至 Ghidra 所在目录</p>
<p><strong>(1) Windows</strong></p>
<p>运行ghidraRun.bat</p>
<p><strong>(2) Linux 与macOS （OS X）</strong></p>
<p>运行ghidraRun</p>
<p>在macOS上运行Ghidra，将显示如下主界面：</p>
<p><img src="blob:file:///6cbf9dc1-7502-4200-a477-d09ec3c25d5e" srcset="/img/loading.gif" lazyload alt="202004030934_TD2JEB2PKQ6BBMM.png"></p>
<p>#ghidra使用手册</p>
<p><strong>1.3 初步的UI自定义</strong></p>
<p>在创建第一个项目之前，我们可以先将图形UI做一些初步的调整。在窗口点击Edit，之后点击Tool Options，再选择Tool，现在我们可以在Swing Look And Feel这里选择我们想要的主题，也可以勾选Use Inverted Colors来实现反转颜色。请注意部分的主题配上颜色反转会出现菜单字体颜色太淡的问题。更改完成后需要重新启动Ghidra才能使设置生效。</p>
<p><img src="blob:file:///4a40fdd0-193d-4bca-8b7b-3a8afa61b09f" srcset="/img/loading.gif" lazyload alt="202004030934_364JNTCRY4E9PJJ.png"></p>
<p>图1-7 反转颜色与主题设置 </p>
<p>#ghidra使用手册</p>
<p> <strong>1.4 第一个项目</strong></p>
<p>配置好环境并运行Ghidra之后，我们可以点击File→New Project，或者使用快捷键Ctrl+N，来创建一个新项目。鉴于我们暂时先讲单人作业，选择Non-Shared Project，并接着输入项目目录与名称以完成项目的创建。</p>
<p><img src="blob:file:///84f21f27-401b-4984-bf17-e1178eb93ebe" srcset="/img/loading.gif" lazyload alt="202004030935_KB4J4ZUFB5W5MPM.png"></p>
<p>图1-8 完成项目创建</p>
<p>之后我们便可以开始导入文件，我们可以简单地将文件拖入Ghidra窗口，也可以选择File→Import File（快捷键I）来导入文件。</p>
<p><img src="blob:file:///4ac76f2d-234e-4a5e-8b8e-2c899ac19d56" srcset="/img/loading.gif" lazyload alt="202004030935_93Q3CQD8SNHFY59.png"></p>
<p>图1-9 导入文件</p>
<p>导入文件后，我们选择CodeBrowser（喷火的龙头图标）工具，也即是Ghidra自带的工具来打开文件。</p>
<p><img src="blob:file:///324cf6ed-de35-4745-ab77-b4ce3dbabfe6" srcset="/img/loading.gif" lazyload alt="202004030936_26V735C6TF63BD9.png"></p>
<p>图1-10 打开文件</p>
<p>CodeBrowser已经是一个非常强大的工具，我们会在下一章开始介绍它的功能。</p>
<p>#ghidra使用手册</p>
<p><strong>2.1 界面介绍</strong></p>
<p>在用CodeBrowser打开我们的文件后，由于是第一次打开，Ghidra会提醒我们，需不需要对文件进行分析，我们选Yes并且以默认的分析工具设置对文件进行分析（直接点选Analyze）。</p>
<p><img src="blob:file:///974a7bf4-40c6-428f-850d-999c73364f1a" srcset="/img/loading.gif" lazyload alt="202004030950_QFFRMN429PRG8PK.png"></p>
<p>图2-1 分析文件</p>
<p><img src="blob:file:///6dbe7925-f883-4050-977b-81d948467275" srcset="/img/loading.gif" lazyload alt="202004030950_FB5PJSUC7ZBCZDW.png"></p>
<p>图2-2 默认配置</p>
<p>分析的进度会在界面右下角显示。</p>
<p>在本章，我们会对CodeBrowser工具中所涵盖的各个内置插件进行逐一的介绍。</p>
<p>打开工具后，我们能看到显示着几个默认的窗口。在本章我们介绍位于界面中间最大的窗口，也是CodeBrowser中的主要窗口，Listing View。</p>
<p><img src="blob:file:///b8882b93-1971-45f6-9b2c-9f49985d8744" srcset="/img/loading.gif" lazyload alt="202004030951_NFUDV2VUN295SND.png"></p>
<p>图2-3 默认窗口</p>
<p>Listing View，我们接下来管他叫做【陈列窗口】，是展示程序指令和数据，并且与其交互的主要窗口。在下面的图中，陈列窗口展示了crackme_example程序的一部分。</p>
<p><img src="blob:file:///935ff513-14bf-4a9d-af34-af13359a5f06" srcset="/img/loading.gif" lazyload alt="202004030951_52YQXPUKDJE7RZR.png"></p>
<p>图2-4 陈列窗口</p>
<p>陈列窗口展示了地址、字节、助记符、算子等信息。陈列窗口的整体结构可以通过Browser Field Formatter（我们会在2.2讨论它）来进行更改。该视窗默认显示整个程序的信息，在视窗大于屏幕大小的情况下（大部分的情况），我们都可以使用滚动条或者鼠标滚轮来进行视窗的上下移动。</p>
<p>此外，我们可以通过其他的Ghidra组件来将视窗展示内容限制在程序的某一个部分上。比如说，我们可以在Program Trees窗口中双击选中.rodata，即只读数据，这时陈列窗口便只显示.rodata段的内容了。</p>
<p><img src="blob:file:///71327e8e-bd7e-4e01-88e0-9a23d9afb646" srcset="/img/loading.gif" lazyload alt="202004030952_37SHENXZUB8B3EN.png"></p>
<p>图2-5 只显示.rodata内容的陈列窗口</p>
<p><strong>2.1.1 光标与选择</strong></p>
<p>尽管陈列窗口不会对程序进行更改，它对于其他插件却非常重要。陈列窗口中一直保持着一个光标的位置，许多其他的插件需要作用于一个特定的地址，而这可以由陈列窗口中的光标来提供。比如，我们将光标放置于main函数中的一个位置，</p>
<p><img src="blob:file:///00e070cd-feb1-491a-a6d7-c0641450fcf2" srcset="/img/loading.gif" lazyload alt="202004030952_EHB3HR3QFP5UDXT.png"></p>
<p>图2-6 放置光标于main函数中</p>
<p>之后点击Windows→Function Graph（关于这个窗口本身我们会在本章的后面进行介绍），我们就能够看到main函数的图形化展示了。</p>
<p><img src="blob:file:///4f29eb25-d960-4ab4-aff8-7e21742a9b7b" srcset="/img/loading.gif" lazyload alt="202004030952_W83ZWH3JEZBYBA5.png"></p>
<p>图2-7 main的图形化展示</p>
<p>光标可以通过任意方向键，或者鼠标点击来进行移动。</p>
<p>此外，还有些插件作用于一个范围内的地址，所以我们还需要用到陈列窗口内的选择功能。我们可以按住鼠标左键拖动鼠标来进行选择，也可以在按住Shift按键的同时用方向键移动光标。</p>
<p>如果一段地址未被选中，按住Ctrl键并选中该段地址，可以将其添加到当前的选中范围中。反之，则可以将其从当前的选中范围中删除。</p>
<p>我们可以将选中的部分高亮显示。选中之后，右键点击，选择Program Highlight→Entire Selection，或者选中之后直接使用快捷键（Ctrl+H），便可以高亮显示该部分。</p>
<p><img src="blob:file:///04e593b4-3314-4a21-be05-34ebeed3cb60" srcset="/img/loading.gif" lazyload alt="202004030953_8XWV6YDPGS82DTU.png"></p>
<p>图2-8 高亮显示部分</p>
<p>之后在同一个菜单下，我们也可以取消高亮显示的效果。</p>
<p>我们也可以用鼠标中键点击一个区域，这样能高亮所选的文本，并且所有相同的文本都会被高亮显示。譬如说，我们中键点击一个MOV指令，我们会发现，所有的MOV指令都被高亮显示了。只有大小写、所有字符都与选中的文本相同才会被该功能匹配。</p>
<p><img src="blob:file:///203d4c55-597f-428b-b109-63567154fd3c" srcset="/img/loading.gif" lazyload alt="202004030953_M7UKEE439XBS3RN.png"></p>
<p>图2-9 中键高亮MOV</p>
<p><strong>2.1.2 导向</strong></p>
<p>陈列窗口提供了强大的导向功能。我们可以通过简单地双击地址或者标签来实现导向。如果想要前往的地址在程序内却不在当前视窗内，当前的视窗会延伸并涵盖至目标地址。</p>
<p><strong>2.1.3 标记</strong></p>
<p>Markers，我们称之为标记，指示着程序中一些特殊的位置。这些位置可以是用户自己添加的(Bookmarks)，也可以是某些Ghidra插件添加的。标记分为两种显示方式：边缘标记(Margin Marker)和导向标记(Navigation Marker)。</p>
<p>想要手动添加书签(Bookmarks)的话，我们可以将光标移动到指定位置，也可以选中一段地址，之后在右键菜单内点击Bookmark，或者使用快捷键Ctrl+D。</p>
<p><strong>边缘标记</strong></p>
<p>边缘标记位于陈列窗口的左侧，在当前展示的代码中指示位置。指示的位置可以是一个地址，也可以是一段地址。下图红框中标出的部分，便是边缘标记。</p>
<p><img src="blob:file:///71bb9177-21cb-46e6-b0aa-b6eda2bd4363" srcset="/img/loading.gif" lazyload alt="202004030953_4S597AKXQPN53NE.png"></p>
<p>图2-10 边缘标记</p>
<p><strong>导向标记</strong></p>
<p>导向标记位于陈列窗口的右边。边缘标记只有处在展示的代码段中才会显示，而导向标记则会一直显示着当前整个视窗内所有的标记。因此，我们可以轻松地利用导向标记来在程序中进行导向。左键单击导向标记，陈列窗口中便会定位至标记的位置。</p>
<p><img src="blob:file:///4f6fe3e0-2114-4719-8abc-377c586c5a47" srcset="/img/loading.gif" lazyload alt="202004030954_A3VM48BHT2EJU8F.png"></p>
<p>图2-11 导向标记</p>
<p>显示导向标记的区域竖直地分成两个部分，左边显示点标记，即是一个单独地址的标记。右半边显示区域标记，即是一段地址的标记。此外，我们还可以通过右键点击导向标记显示的区域来自定义显示的内容。</p>
<p><strong>2.1.4 流程箭头</strong></p>
<p>陈列窗口中的流程箭头图形化地展示了函数内的流程。Jump类指令的起点与终点都被用箭头连接了起来。有条件的跳转用虚线显示，而无条件的跳转用实线显示。</p>
<p><img src="blob:file:///eae41902-5096-45aa-a311-00b0e9c77af5" srcset="/img/loading.gif" lazyload alt="202004030954_W8CYN7JCYKQMTXU.png"></p>
<p>图2-12 流程箭头</p>
<p>我们可以利用流程箭头来导向，双击一个流程箭头便可以导向至该跳转的终点。如果我们的光标已经在终点的地址，双击流程箭头便可以导向至起点。</p>
<p><strong>2.1.5 鼠标悬浮*</strong>*</p>
<p>陈列窗口还提供了悬浮窗口，当鼠标悬浮在有额外信息的区域上时，悬浮窗口会自动出现。悬浮窗口让我们在不重定位显示窗口的前提下，能够看到想要的信息。</p>
<p>比如，我们将鼠标悬浮于地址之上，就会出现一个显示偏移的悬浮窗口。</p>
<p><img src="blob:file:///3b60be62-5d02-4a15-ac9f-7839c65923ec" srcset="/img/loading.gif" lazyload alt="202004030954_7ZCZN3R78DCJNGF.png"></p>
<p>图2-13 悬浮窗口</p>
<p>此外，悬浮窗口还作用于【内存引用】、【缩略文本】、【数据类型】、【函数名】以及【数量】上。</p>
<p>#ghidra使用手册</p>
<p><strong>2.2 Decompiler</strong></p>
<p>在CodeBrowser默认显示的窗口中，反编译窗口一样非常显眼。我们将先对Ghidra的反编译器本身进行介绍，对于其具体的操作则会在2.2.2当中说明。</p>
<p><strong>2.2.1 反编译器</strong></p>
<p>Ghidra自带复杂的转换引擎，能够将二进制表示的函数转化成更高层的C语言形式。Ghidra的反编译器包含以下功能：</p>
<p><strong>1.还原表达式：</strong></p>
<p>反编译器会进行完整的数据流分析从而对函数进行切离。由编译&#x2F;优化这个过程带来的复杂的表达式，会被还原成简单易读的形式。</p>
<p><strong>2.还原高级变量：</strong></p>
<p>反编译器会有效地还原最初程序所使用的变量，最小化引入新变量的需求。</p>
<p><strong>3.还原函数参数：</strong></p>
<p>反编译器会还原函数最初的形式。</p>
<p><strong>4.自动命名</strong></p>
<p>高级变量将会被合适地命名，数组的index值也会自动计算并用正确的格式显示出来，字符指针常量会被自动替换为对应的字符串。</p>
<p><strong>5.自动引入数据类型与名称</strong></p>
<p>当用户更改数据类型与名称的时候，反编译器会自动引入这些修改并应用，C语言输出也会随之更改。</p>
<p><strong>6.局部类型传播</strong></p>
<p>当信息不足的时候，反编译器会尽可能地提供相关的已知信息。因此，当遇到一个数据类型没有被确定的变量时，用户可以通过观察这个变量是如何被使用的，或者让已知的数据类型传播，来还原该变量的数据类型。</p>
<p><strong>变量</strong></p>
<p>反编译器会尝试结合不同位置的信息（堆、内存、寄存器）来决定函数内的变量。变量数据类型的信息也是由多个源头自动收集而来。比如，函数签名能够提供类型的信息。如果函数包含一个对全局内存位置的引用，而又有数据类型作用于这些位置上，反编译器也能从中得到信息。反编译器所得到的的信息越多，其产生出来的C代码便会更好。</p>
<p>未能够直接确定类型的变量可以通过局部类型传播来确定。我们往往只需要手动分配几个关键变量的类型，就能极大的提升C代码的可读性，因为反编译器可以通过局部类型传播来精确地分配其他数据类型。另外，手动分配函数签名中的类型，或是全局变量，会极为有效，因为这能同时影响多个函数。标明函数参数的数据类型非常有用。一个函数参数中定义了的数据类型会被传播到这个函数调用的所有函数当中。</p>
<p>如果你有程序所用API的C语言头文件，Ghidra提供了一个原型的C代码解析器。该解析器能够提取C代码中的数据类型信息并且创建一个Ghidra Data Type Archive(.gdt)文件。我们可以选择File→Parse C Source来打开该解析器。更多关于数据类型管理的内容，我们会在2.1.5中讲到。</p>
<p><strong>反编译器内部函数</strong></p>
<p>有时，反编译器会使用某个反编译器内部函数，这些函数没有被转化成像C代码的样子。出现这种情况通常说明产生的伪代码不正确，或者是需要被手动调整至更可读的输出。有时可能我们需要添加针对这种特定情况的额外简化规则。</p>
<p><strong>SUB41(x,e) 截断操作</strong></p>
<p>其中4代表着输入算子(x)的字节数，1代表着输出值的字节数。x为将被截断的值，e则是被截断的最低有效字节个数。举个例子：</p>
<p>SUB42(0xaabbccdd,1)&#x3D;0xbbcc</p>
<p>当e的值为0时，该操作基本是对整数大小间的转换。</p>
<p>SUB41(x,0)通常是从int到char的转换</p>
<p>SUB42(x,0)是从int到short的转换</p>
<p>SUB84(x,4)可能是扩展精度乘法的一部分，但也可能出现在诸如除法的强度折减的其他操作当中。</p>
<p><strong>CONCAT31(x,y) 连接两个算子</strong></p>
<p>其中3代表x的字节数，1代表y的字节数。输出结果会是一个4字节的连接，x会组成结果的最高有效字节部分，而y会组成最低有效字节部分。例：</p>
<p>CONCAT31（0xaabbcc,0xdd）&#x3D;0xaabbccdd</p>
<p>这个函数通常会在大小为1字节的变量(char)被储存于4字节的寄存器中出现。所有在4字节寄存器上的基本运算&#x2F;逻辑操作都能够正确地作用于1字节的变量，编译器只需要保证忽略寄存器中的3个最高有效字节。</p>
<p>CONCACT31被反编译器用来追踪这些被编译器忽略掉的最高有效字节。再多数情况下，反编译器能够做到这一点，然而在循环结构中却不行。这是由反编译器源代码所带来的难以解决的问题。</p>
<p><strong>ZEXT14(x) 0的扩展</strong></p>
<p>其中1代表x的字节数,4代表输出值的字节数。该函数绝大多数情况下是对小的整型到较大的无符号整型的转换。</p>
<p><strong>SEXT14(x) 有符号的扩展</strong></p>
<p>其中1代表x的字节数,4代表输出值的字节数。该函数绝大多数情况下是对小的有符号整型到较大的有符号整型的转换。</p>
<p><strong>SBORROW4(x,y) 判断两数相减有无运算溢出</strong></p>
<p>其中4代表x与y的字节数，x,y均为有符号整型。该函数在x-y会造成运算溢出的情况下返回true。该函数一般由两个有符号整型的比较中产生。尽管反编译器中有还原比较的规则，这是一个没有被涵盖到的特殊情况。</p>
<p><strong>CARRY4(x,y) 判断x+y是否进位</strong></p>
<p><strong>SCARRY4(x,y)判断x+y是否导致有符号的溢出</strong></p>
<p>其中4代表x与y的字节数。如果x+y导致进位，将会返回true。</p>
<p><strong>寄存器设置</strong></p>
<p>有时程序会使用一个寄存器来储存一个全局常数。我们可以在陈列窗口右键菜单中选择Set Register Values来指定该值。这个常数会自动传播到反编译器中的相关函数中，我们得到的C代码也可能因此被进一步简化。</p>
<p><img src="blob:file:///39d43dd4-9656-4bd3-8649-a371423e3aff" srcset="/img/loading.gif" lazyload alt="202004030956_WJ864BURC8EGNYK.png"></p>
<p>图2-14 寄存器设置</p>
<p><strong>反编译器选项</strong></p>
<p>如下则是一些可用的反编译器分析选项(Edit→Tool Options→Decompiler&#x2F;Analysis):</p>
<p><img src="blob:file:///684a725f-f3af-4343-931c-3b7c6d2d2e53" srcset="/img/loading.gif" lazyload alt="202004030956_HC75USV9REMUJ3H.png"></p>
<p>图2-15 反编译器选项</p>
<p>Eliminate unreadable code：让反编译器去除它认为不可读的代码部分。</p>
<p>Ignore unimplemented instructions：让反编译器忽略那些语义被标记为未实现的指令。</p>
<p>Infer constant pointers：允许反编译器推断那些看起来像指针的常数的数据类型。如果常数的地址看起来像是程序中已知的数据或者函数，该常数会被假设为一个指针。</p>
<p>Respect read-only flags：让反编译器将被标记为只读的内存当作常数值。对那些真正只读，并且从未变化过的值，该段内存会被在Memory Manager中被标记为只读。</p>
<p>Simplify predication：使反编译器简化条件指令，合并使用相同判断条件的if else的代码段。</p>
<p>Simplify extended integer operations：使反编译器简化对整型的操作。当一个值被分为多个部分并在不同阶段操作时，反编译器会尝试将这些阶段合并，还原出单一的操作。</p>
<p>Use in-place assignment operators：使反编译器在输出中使用像+&#x3D;这样的分配操作符。</p>
<p>Decompiler Timeout(seconds)：设定允许有反编译器运行的秒数。目前这个时间设置不影响用户界面，用户界面会无止境的运行。这个设定目前只影响后台使用decompiler.syntax的分析进程。</p>
<p><strong>2.2.2 反编译窗口</strong></p>
<p>现在我们会开始介绍Ghidra反编译器所提供的用户界面，也就是反编译窗口（Decompiler Window）的使用。反编译窗口默认位于陈列窗口的右边。</p>
<p><img src="blob:file:///17a5fc8f-705f-46a3-b43f-f8ae59fd8fbf" srcset="/img/loading.gif" lazyload alt="202004030957_9ETKA2AQD2JR723.png"></p>
<p>图2-16 反编译窗口</p>
<p>如果窗口被关闭，我们也可以从Window→Decompile中将其打开。</p>
<p><strong>鼠标活动</strong></p>
<p>双击：导向至双击的标志</p>
<p>Ctrl+双击：在新窗口中导向至双击的标志</p>
<p>中键点击：高亮显示所有与所点击的目标相同的内容</p>
<p><strong>复制</strong></p>
<p>我们可以将反编译窗口中的C代码复制，选择需要复制的文本，并从右键菜单中选择Copy，也可以直接使用快捷键Ctrl+C。</p>
<p><strong>重命名</strong></p>
<p>我们可以重命名任意的参数或者变量，右键点击变量，选择Rename Variable（快捷键L），便可更改变量名。</p>
<p><img src="blob:file:///3badda1d-4874-4ae6-ac25-66c3957a1ae8" srcset="/img/loading.gif" lazyload alt="202004030957_J6KV8R3D2Q6UQAE.png"></p>
<p>图2-17 重命名变量</p>
<p>而重命名函数，需要点击函数名，右键菜单中选择Rename Function（快捷键L）。</p>
<p><strong>重定义变量类型</strong></p>
<p>尽管反编译器会尽可能地自动还原变量类型，它时常得不到足够的信息。我们可以手动变更一些变量的类型来改善所得到的C代码。右键点击变量，选择Retype Variable（快捷键Ctrl+L）。任何该程序已知的类型都可以使用。</p>
<p><img src="blob:file:///a9d1bebc-d940-40b6-9af8-54afd691d02c" srcset="/img/loading.gif" lazyload alt="202004030957_PE6UKADH335KNUM.png"></p>
<p>图2-18 更改变量类型</p>
<p>一个简单有效的提升反编译器所生成的代码质量的方式是，找到函数有明显的字符串参数的函数，并将参数的类型改为char *。之后对任何对定义的内存的引用都会将所传递的参数显示为string。</p>
<p><strong>编辑函数签名</strong></p>
<p>右键菜单中选择Edit Function Signature，我们便可以更改函数签名。</p>
<p><img src="blob:file:///26c484f6-39ca-4abd-ade6-fb50b0ea5fe7" srcset="/img/loading.gif" lazyload alt="202004030958_BDSCH4E5UM6HNG2.png"></p>
<p>图2-19 编辑函数签名</p>
<p>函数签名包括函数名、返回类型、参数个数、参数名、参数类型、变量参数（varargs）。</p>
<p>我们可以通过修改函数签名的字符串来修改以上任意内容。比如说，当我们发现某个函数实际上是printf的话，我们可以在输入void printf(char *x, …)。</p>
<p>另外，我们也可以选中Calling Convention（见图2-19）来从一系列可用的调用约定中选择。勾选inline以指示内联函数。勾选No Return以指示该函数不返回。</p>
<p><strong>查找</strong></p>
<p>右键菜单中的Find功能（Ctrl+F），支持在当前函数中对正则表达式或者字符串的查找。</p>
<p><strong>导出成C代码</strong></p>
<p>选择下图所示图标，可将当前反编译的函数导出。如果不指定文件扩展名，Ghidra会将其保存为.c文件。</p>
<p><img src="blob:file:///75f032ce-6137-4b57-bdf3-1d3b708dc599" srcset="/img/loading.gif" lazyload alt="202004030958_RZ4PNSM86GCTY5S.png"></p>
<p>图2-20 编辑函数签名</p>
<p>#ghidra使用手册</p>
<p><strong>2.3 Program Tree管理窗口</strong></p>
<p>Program Tree（以下称作“程序树”）管理窗口默认位于界面的左上角。程序树被用来将程序组织进一个树结构。我们可以用程序树中的节点在CodeBrowser中进行导向，我们也能够利用程序树限制CodeBrowser中所显示的内容（可参考2.1中关于限制当前视窗显示内容的部分）。程序树管理器可以创建、删除、重命名或关闭程序树的视图。</p>
<p><img src="blob:file:///a6a57ecd-b300-49b8-afae-46c3e8329071" srcset="/img/loading.gif" lazyload alt="202004031002_RCR32SXB8BDRQ2D.png"></p>
<p>图2-21 程序树管理窗口</p>
<p><strong>2.3.1 文件夹与分段</strong></p>
<p>程序树将一个程序组织成文件夹与分段（folders and fragments）。分段包含着代码的单元，而代码单元只能存在于一个且只有一个分段中。文件夹则可以包含分段和其他文件夹。这里所说的文件夹不像文件系统当中的文件夹，除了根文件夹之外的任意文件夹，和分段，都可以有不止一个的父文件夹。当用户将一个文件夹或分段（暂且称之为A）复制到另一个父文件夹下时，不会有新的A被创建，而是目标文件夹会被添加为A的另一文件夹。</p>
<p><strong>创建文件夹</strong></p>
<p>1 右键选择窗口中的一个文件夹</p>
<p>2 右键菜单中选中Create Folder</p>
<p><strong>创建分段</strong></p>
<p>1 右键选择窗口中的一个文件夹</p>
<p>2 右键菜单中选择Create Fragment</p>
<p>我们也可以通过拖动陈列窗口中的代码单元来创建分段，只需拖动选中的代码单元到一个文件夹。该新建的分段的名称将会由所选代码单元中的第一个地址名称所决定。如果拖动的代码单元有标签，分段的名称将会被默认地设为标签名。</p>
<p><strong>删除</strong></p>
<p>满足以下两种情况之一时，我们才能够删除文件夹或分段A。</p>
<p>1 A是空的。</p>
<p>2 A存在于其他的文件夹中。</p>
<p>右键选择Delete以将其删除。</p>
<p><strong>排序</strong></p>
<p>用户可以选择以地址或名称顺序对程序树中内容进行排序。</p>
<p>1 右键选择一个文件夹</p>
<p>2 Sort→by Address（以地址顺序），Sort→by Name（以名称顺序）。</p>
<p>#ghidra使用手册</p>
<p><strong>2.4 Symbol Tree 窗口</strong></p>
<p>Symbol Tree窗口，以下称作符号树窗口，将程序分为五个大类显示：Externals、Function、Labels、Classes与Namespaces。</p>
<p>符号树窗口默认显示于程序树窗口下方，如果关闭后想将其重新打开，选择Window→Symbol Tree。</p>
<p><img src="blob:file:///661babf3-fd99-4dcf-a1c3-f3390a17f662" srcset="/img/loading.gif" lazyload alt="202004031003_D5YCDRQCQPCCYHZ.png"></p>
<p>图2-22 程序树管理窗口</p>
<p><strong>2.4.1 显示</strong></p>
<p>我们将对上图中可见到的类别一一介绍。</p>
<p><strong>Imports</strong></p>
<p>Imports类别包含了代表外部库命名空间的符号。库名<EXTERNAL>被预留以放置那些还没有与特定的库关联的外部符号。</p>
<p><img src="blob:file:///3e7fac23-6e12-4432-8cfc-2983c00c7006" srcset="/img/loading.gif" lazyload alt="202004031004_RMUNMEQVW3J6NPD.png"></p>
<p>图2-23 <EXTERNAL></p>
<p><strong>Exports</strong></p>
<p>Exports包含了那些代表导出的入口点的符号。</p>
<p><strong>Functions</strong></p>
<p>Functions包含了代表程序中函数的符号（除外部函数）。我们可以打开一个函数的符号来显示它的参数和变量符号。</p>
<p><img src="blob:file:///31a036fe-8373-4599-8b9e-3167e40b219d" srcset="/img/loading.gif" lazyload alt="202004031004_RZQQXTARRE7B6J6.png"></p>
<p>图2-24 显示参数与变量</p>
<p><strong>Labels</strong></p>
<p>所有Labels类别中的符号都处于全局命名空间中。</p>
<p><strong>Class</strong></p>
<p>Class包含了那些可能包含函数命名空间或标记符号的类的命名空间。</p>
<p><strong>Namespace</strong></p>
<p>Namespace包含了处于全局命名空间中的通用命名空间，也可能包含类、函数、标记、或其他命名空间。</p>
<p><strong>2.4.2 创建库</strong></p>
<p>用户可以创建一个库的名字并将其指代一个外部库。这个名字因此就可以与程序（或库）相关联并允许用户进行导向或阅读代码。右键点击Imports文件夹并选择Create Library。所创建的库默认名称会是NewLibrary。</p>
<p><strong>2.4.3 设置外部程序</strong></p>
<p>右键点击你想要的关联的Imports文件夹中的库，并选择Set External Program，这将弹出一个选择外部程序的会话，我们可以在该会话中选择想关联的外部程序（或库）。之后，用户便能够对外部引用进行导向或阅读代码。</p>
<p><strong>2.4.4 外部位置</strong></p>
<p>右键点击某个库，并选择Create External Location，便会弹出一个创建外部位置的对话(如下图)。External Program Path，即是程序对应的库，在项目中有关联程序的情况下会被自动填充。另外的情况下，我们可以从Edit手动选择。我们需要为外部位置指定Label（标签）或是Address（地址）。勾选Make External Function将创建一个外部函数。不勾选的情况下，一个非函数的外部位置将被创建。</p>
<p><img src="blob:file:///4d4409ec-0d5d-4de8-9b3c-acd38435e752" srcset="/img/loading.gif" lazyload alt="202004031005_59KKF3FJPKP75HN.png"></p>
<p>图2-25 创建外部位置</p>
<p>在上图所显示的对话中，我们创建了一个外部函数，被标记为A_Label，位于Lib中的地址0xdeadbeef。这个库的名称Lib，则将会与项目中的lib_example文件相关联。</p>
<p>与上述操作类似，我们可以对外部位置进行编辑。右键选择外部位置&#x2F;外部函数并选择便可以调出编辑外部位置的对话。</p>
<p>如果我们选中一个外部位置的标志，会被导向至一个外部的引用源，该引用源指向外部位置。如果想要真正地导向到这个外部位置，右键点击标志并选择Go To External Location。</p>
<p><strong>2.4.5 创建类与命名空间</strong></p>
<p>右键选中一个父命名空间并选择Create Class选项。所有在Class类别中的类，都在全局命名空间中。</p>
<p>相似地，我们可以在全局命名空间、类、或者其他命名空间中创建命名空间。右键点击父命名空间并选择Create Namespace。所有在Namespace类别中的命名空间，都在全局命名空间中。</p>
<p>#ghidra使用手册</p>
<p><strong>2.5 Data Type 管理器</strong></p>
<p>Data Type Manager，以下称为“数据类型管理器”，让用户能够定位、组织数据类型，也能够将数据类型应用于程序。Ghidra的一个长期的目标，便是让用户能够搭建数据类型的库，并在不同的程序、项目甚至用户之间分享使用。</p>
<p><strong>2.5.1 基本概念</strong></p>
<p><strong>数据类型</strong></p>
<p>Ghidra支持三类数据类型：Built-in、user defined、derived。</p>
<p><strong>类型</strong></p>
<p><strong>描述</strong></p>
<p><strong>Built-in</strong></p>
<p>直接由Java实现并被用于基本的标准类型，比如byte、word、string等等，不能被改变或重命名。</p>
<p><strong>User Defined</strong></p>
<p>有四个用户定义（user defined）的数据类型，分别是Structures、Unions、Enums和Typedefs，可以被创建、修改及重命名。</p>
<p><strong>Derived</strong></p>
<p>两种派生的数据类型：Pointers（指针）和Arrays（数组），可以被创建与删除，但是名字由其基本类型决定。</p>
<p><strong>数据类型档案</strong></p>
<p>数据类型档案被用于在程序、项目和用户间打包并分享数据类型。有两种用户创建的档案类型：文件数据类型档案（File data type archives）和项目数据类型档案（Project data type archives）。数据类型档案可以在数据类型管理器中访问。一个被打开的数据类型档案将会被显示为数据类型管理树中的一个节点。档案可以被用户手动打开，也可以被引用它的程序自动打开。</p>
<p><strong>内置数据类型档案</strong></p>
<p>Built-in档案，即内置数据类型档案，总会出现在数据类型管理器中。它支持对所有Ghidra 内置数据类型的访问。</p>
<p><img src="blob:file:///4ce037d7-8b0b-475a-8a0c-93e1a3a88dd0" srcset="/img/loading.gif" lazyload alt="202004031006_UPGYXVX9B4GFGA4.png"></p>
<p>图2-26 内置数据类型档案</p>
<p><strong>文件数据类型档案</strong></p>
<p>文件数据类型档案，以下简称为“文件档案”，将数据类型储存于扩展名为.gdt的文件中，可以位于文件系统中的任意位置。在被分享使用的文件系统中，文件档案可以被多个用户同时打开，但是只有其中一个用户能够打开并对其做修改。</p>
<p><strong>项目数据类型档案</strong></p>
<p>项目数据类型档案，以下简称为“项目档案”，将数据类型与其他程序一起，储存于Ghidra项目数据库目录当中。Ghidra项目窗口会将项目中的项目档案如同其他程序一样展示。项目档案可以被记录版本并可在多用户环境中共用。</p>
<p><strong>程序中的数据类型</strong></p>
<p>除了存储于档案中，数据类型也能被存于程序内部。任何在程序中使用的数据类型一定会被存储于程序当中，即使它最初来自于某个档案。</p>
<p><img src="blob:file:///fac046ef-7325-4f12-aafe-785d188f27ca" srcset="/img/loading.gif" lazyload alt="202004031006_7N68NCSJKDQ5SXM.png"></p>
<p>图2-27 程序中的数据类型</p>
<p><strong>应用数据类型*</strong>*</p>
<p>将数据类型应用于程序当中是我们的主要目的。数据类型可以被应用于内存上的位置，来让Ghidra知道该位置中的那些字节究竟是什么。数据类型也可以用来描述函数的参数和局部变量。</p>
<p>我们可以通过拖动数据类型至陈列窗口中的某个元素，来应用该数据类型。我们会在后面的章节中更细致的介绍应用数据类型的其他方法。</p>
<p>当一个来自于档案中的数据类型被应用于某个程序时，一份该数据类型的拷贝会在该程序中产生。我们将产生这份拷贝的过程称之为“解析”（resolving）。这是一个复杂的过程，因为数据类型可以包含或引用其他的数据类型。这些引用的数据类型既可能存在，也可能不存在于该程序中，而解析的过程要考虑到这些情况。有时，程序中可能存在与需要解析的数据类型同名的类型。即使这两个产生冲突的数据类型一致，Ghidra也难以对其进行判断与处理。通常来说，Ghidra会通过重命名新的类型，将.conflict添加到这个新的数据类型名称之后，来解决这类问题。对于许多从数据类型管理器触发的操作来说，冲突的解决办法由当前的“数据类型冲突模式”（Data Type Conflict Mode）决定。添加一个单一的数据类型往往会导致许多新的数据类型被添加到程序当中。</p>
<p><strong>2.5.2 数据类型档案操作</strong></p>
<p>在2.5.1当中，我们已经知道用户创建的数据类型档案分为文件档案与项目档案。通常来说，文件档案会被以只读模式打开，而项目档案会被打开用于编辑。项目档案支持分享与版本控制，因此允许多个用户同时对其进行更改。而文件档案同时只允许一个用户进行编辑。</p>
<p><img src="blob:file:///02b91a3d-74d8-454f-a842-9f18dce7cf4c" srcset="/img/loading.gif" lazyload alt="202004031007_EPGH67G3ZH59DBP.png"></p>
<p>图2-28 在倒三角菜单中，选择对档案的操作</p>
<p><strong>文件档案</strong></p>
<p>在上图中，我们可以看到一系列关于档案操作的选项。选择New File Archive…，便会出现一个文件选择对话。选择一个目录并输入新档案的名称。一个新的档案便会出现在数据类型管理器当中。</p>
<p>如果想要打开文件档案，选择Open File Archive…，后面的操作与上述操作类似。</p>
<p>文件档案打开后，不能直接用于编辑。如果想对其进行编辑，我们需要右键点击该档案并选择Open for Editing。如果其他用户正在对该档案进行编辑，这个操作会失败，我们会被提示有其他用户正在编辑该档案。</p>
<p>档案中未保存的更改会被加上*符号来提醒用户。我们可以右键点击编辑的档案，并选择Save Archive来对其进行保存。也可以选择Save As…将编辑的档案保存在新的文件当中。</p>
<p>当不再需要编辑该文件档案时，我们应将该档案转变回只读模式。右键点击该档案并选择Close for Editing。</p>
<p><strong>项目档案</strong></p>
<p>选择New Project Archive…，并在出现的对话中选择一个文件夹，输入新档案的名称。我们也可以简单地将.gdt文件，即文件档案，拖入Ghidra项目窗口中，这也能够添加新的项目档案。</p>
<p>如果想要打开项目档案，选择Open Project Archive…，后面的操作与上述操作类似。</p>
<p><strong>2.5.3 数据类型操作*</strong>*</p>
<p>数据类型是档案中真正有用的内容。数据类型可以被应用于程序，并丰富其中数据、参数、局部变量和函数返回类型的意义。用户定义的数据类型可以变得十分复杂，但他们最终都是基于内置数据类型。</p>
<p><strong>将数据类型应用于程序</strong></p>
<p>用户可以通过以下两种方法应用数据类型。</p>
<p>1 拖动：我们可以通过将数据类型拖动于陈列窗口的相应元素上来应用数据类型。在下图中，我们将内置类型中的int拖动到函数名main上，便可以将int类型应用于main函数的返回值。</p>
<p><img src="blob:file:///6a3889a1-2c83-4af8-8c8b-ca0aecaadf46" srcset="/img/loading.gif" lazyload alt="202004031007_QZP6VE2FH8MUNWX.png"></p>
<p>图2-29 拖动数据类型</p>
<p>2 陈列窗口中进行应用：在陈列窗口中，右键点击某一元素，选择Set Data Type，便可以从提供的常用数据类型中进行选择。我们也可以直接选中元素，并按快捷键T，来调出选择数据类型的对话。</p>
<p><img src="blob:file:///4de37e8e-88cb-43c5-9349-a642f540acf5" srcset="/img/loading.gif" lazyload alt="202004031008_QEQDTUJPMNN8544.png"></p>
<p>图2-30 陈列窗口中进行操作</p>
<p>需要注意的是，从档案中应用数据类型会自动将该数据类型添加至本程序的档案中。该档案也会被自动与该程序关联，以后打开这个程序时，该档案也会被打开。</p>
<p><strong>创建用户定义数据类型</strong></p>
<p>有七种用户可以创建的数据类型：Structures、Unions、Enums、Function Definitions、Typedefs和Pointers。</p>
<p>右键点击想要创建新类型的目录，选择New→Structure，New→Union，New→Enum，New→Function Definition来创建对应的数据类型。下图是创建新的Structure的示例。</p>
<p><img src="blob:file:///f4b27ff2-a36a-491c-a9d9-3b144b7dcb68" srcset="/img/loading.gif" lazyload alt="202004031008_ETHAENWPYUR6N85.png"></p>
<p>图2-31 创建新的Structure</p>
<p>创建typedef更加简单，右键选择需要被typedef的数据类型（称之为A），选择New→Typedef on A。此外，我们还可以选择New→Typedef…来调出一个完整的对话窗口。</p>
<p><img src="blob:file:///6f751c5b-7bb8-45e3-b618-788785e9139f" srcset="/img/loading.gif" lazyload alt="202004031008_JN54XURXGDRT6D2.png"></p>
<p>图2-32 通过完整对话窗口创建新的Typedef</p>
<p>类似地，如果想创建一个Pointer，选择New→Pointer to A。需要注意的是，我们不能对内置数据类型的目录进行更改。所以如果我们在内置数据类型目录下创建Pointer或Typedef，所生成的数据类型会被放置于程序的数据类型根目录下。</p>
<p><strong>编辑数据类型</strong></p>
<p>只有Structure，Union，Enums和Function Definitions能够被编辑。在数据类型管理器中双击或右键并选择Edit这类节点，便可以打开对应的编辑器。</p>
<p><strong>从所选枚举类型创建新的枚举类型</strong></p>
<p>我们可以通过选择两个或以上的枚举类型（Enums），再选择Create Enum form Selection。输入新的Enum的名字便可以完成创建。所得的Enum会包含所选的Enums的名称与值。需要注意的是，如果所选枚举中含有相同的值，这些值都会被添加至新的枚举中。然而，只有第一个该值将在应用时生效。</p>
<p><img src="blob:file:///7327ba3d-ab73-44ae-9d80-6df3c31947ce" srcset="/img/loading.gif" lazyload alt="202004031009_BMEN3SR26H8JK6C.png"></p>
<p>图2-33 从所选枚举类型创建新的枚举类型</p>
<p><strong>删除，移动与复制</strong></p>
<p>我们可以右键点击选择Delete来对数据类型进行删除。一个确认的对话窗口将会弹出，提醒用户该操作不能被撤回。</p>
<p><img src="blob:file:///f06cc77c-0761-4f77-8111-3d1665288c18" srcset="/img/loading.gif" lazyload alt="202004031009_KBUE5VSQJJAYV4T.png"></p>
<p>图2-34 不能用Undo功能撤回</p>
<p>数据类型只可以在同一个档案中移动，如果想在不同档案间移动数据类型，该数据类型会被复制。我们可以通过两种方法移动一个数据类型：</p>
<p>1 拖动</p>
<p>2 剪切&#x2F;粘贴：右键点击想要移动的数据类型，并选择Cut，之后右键点击目标父目录并选择Paste。</p>
<p>数据类型可以在一个档案之中进行复制，也可以从一个档案复制至另一个档案。然而在这两种情况下，复制的行为其实是不同的。当在一个档案之中进行复制时，源数据类型的一个复制自然地被放置在目标目录下。然而当在不同档案间进行复制时，任何包含于所复制的数据类型中的数据类型都会被按照相对路径复制到目标档案之中。</p>
<p>相似地，我们有两种办法复制一个数据类型。</p>
<p>1 拖动</p>
<p>2 复制&#x2F;粘贴：右键点击想要移动的数据类型，并选择Copy，之后右键点击目标父目录并选择Paste</p>
<p><strong>对齐数据类型</strong></p>
<p>右键点击想要进行对齐操作的Structure或Union，并选择Align。</p>
<p><strong>承认对源档案的改动</strong></p>
<p>如果我们作出了对与源档案有关联的数据类型的改动，这些改动需要被应用至源档案以确保不同位置的数据类型是同步的。右键点击想要承认改动的数据类型，并选择Commit to Archive，改动便将被应用至源档案之中。</p>
<p><strong>从源档案更新数据类型</strong></p>
<p>如果我们对源档案当中的数据类型作出了改变，而这些数据类型又有所关联的数据类型存在于其他档案或是程序的档案当中，我们便需要从源档案当中更新数据类型。右键点击想要更新的数据类型，并选择Update From Archive。</p>
<p><strong>取消改动</strong></p>
<p>如果我们作出了对与源档案有关联的数据类型的改动，但不想保留且应用这些改动，我们可以将其返回至最初的状态。右键点击数据类型并选择Revert便能移除改动。</p>
<p><strong>关联&#x2F;取消关联</strong></p>
<p>当一个数据类型被应用于一个程序中时，该数据类型的一份复制就会创建于程序内。另外，一个与原数据类型的关联也会被建立。然而，当一个数据类型被创建于程序中，并之后被移动到档案中时，会弹出一个对话询问用户是否希望一个关联被建立。如果选择yes，关联将被创建，档案会变成该数据类型的源。</p>
<p><img src="blob:file:///6d6f7502-c22f-4627-92da-a069590e1422" srcset="/img/loading.gif" lazyload alt="202004031009_GN9DGARCPN9AMV8.png"></p>
<p>图2-35 是否建立关联</p>
<p>如果想要取消某个数据类型与源档案的关联，我们右键点击数据类型并选择Disassociate From Archive。该数据类型便会变成局部的数据类型，任何对其的修改也不会影响到源档案中的原数据类型。</p>
<p><strong>处理数据类型冲突</strong></p>
<p>当我们尝试移动或者复制数据类型到一个含有同名数据类型的目录下时，便会引发冲突。我们可以在数据类型管理器中提前设置解决冲突的模式。</p>
<p><img src="blob:file:///6b105190-97c9-4407-8fb4-3bf7e63b1115" srcset="/img/loading.gif" lazyload alt="202004031010_XHVNYFQPQYZMQS8.png"></p>
<p>图2-36 处理数据类型冲突</p>
<p>如上图所示，我们可以在所示图标处选择一种解决冲突的模式。</p>
<p>1 Rename New or Moved Data Type:</p>
<p>将新建或移动过来的数据类型重命名。如原名称是A，其将会被重命名为A.conflict。</p>
<p>2 Use Existing Data Type:</p>
<p>目标目录将不受影响，继续使用改动前的数据类型。</p>
<p>3 Replace Existing Data Type:</p>
<p>与选项2相对地，选择此项将会删除现存的数据类型，并用移动或新建而来的数据类型代替。</p>
<p>4 Replace Empty Structures else Rename:</p>
<p>与选项1类似，只有在目标目录中的冲突类型为一个空的Structure时，移动或新建而来的Structure会将其代替。</p>
<p><strong>替换数据类型</strong></p>
<p>数据类型可以被替换为其他的数据类型。这意味着程序中所有的该数据类型将会被替换为新的数据类型，原数据类型将被删除。有两个方式进行该操作：</p>
<p>1 拖动：将数据类型拖动至将被替换的数据类型上。</p>
<p>2 复制&#x2F;粘贴：右键点击数据类型，并选择Cut。接下来右键选择将被替换的数据类型，选择Paste。</p>
<p><img src="blob:file:///bcb48e33-c8db-4631-b35d-cd0f64dd0300" srcset="/img/loading.gif" lazyload alt="202004031010_KU3KK5VPTA4TMH2.png"></p>
<p>图2-37 替换数据类型</p>
<p>不过使用哪一种方法，都将弹出一个用于确认的对话窗口。</p>
<p><strong>设置偏好的数据类型</strong></p>
<p>数据类型可以被标记为偏好的(favorites)，这些数据类型由此可以出现在陈列窗口的Set Data Type选项当中。这是一个快速将数据类型应用到程序当中的方法。CodeBrowser将大多数常用的内置数据类型标记为了受偏好的。</p>
<p><img src="blob:file:///96b34efc-7e94-48e3-9302-d7e855ac9ebf" srcset="/img/loading.gif" lazyload alt="202004031010_8MGUDS7BDSAF47N.png"></p>
<p>图2-38 喜爱的数据类型出现位置</p>
<p>想要设置偏好的数据类型，我们可以右键点击数据类型并选择Favorite。偏好的数据类型将会被标以心形图标（如下图所示）。</p>
<p><img src="blob:file:///53bc70fd-e581-4e2b-a003-6df3d3b22239" srcset="/img/loading.gif" lazyload alt="202004031010_ZUCJJKZF9XUVRCR.png"></p>
<p>图2-39 偏好的数据类型</p>
<p>想要移除偏好，右键点击数据类型并取消对Favorite的选择。</p>
<p>需要注意的是，偏好的数据类型的名字必须是独特的。如果我们在目录A与目录B都有叫做A_type的数据类型，我们便不能同时将他们设置为偏好的数据类型。此外，任意的数据类型都可以被设置为偏好的。然而，只有对内置数据类型的设置会在你退出项目或关闭Ghidra时被保存为工具的设置。</p>
<p><strong>2.5.4 编辑用户定义的数据类型*</strong>*</p>
<p>我们可以通过Structure专用的编辑器来编辑一个结构体数据类型的内容。编辑器可被用于创建新的或编辑已经存在的Structure。下图是编辑器的内容。</p>
<p><img src="blob:file:///ac21f0a6-85ea-4097-aa8e-6d4dccf8062d" srcset="/img/loading.gif" lazyload alt="202004031011_N6VTPAHG32YH6MU.png"></p>
<p>图2-40 Structure编辑器</p>
<p>Union的编辑器与Structure的类似。Union的所有组成部分都位于偏移0。</p>
<p><img src="blob:file:///1e0dfd22-4ed0-4aff-b72d-fcf403cd3698" srcset="/img/loading.gif" lazyload alt="202004031011_DVCQGTFWGCK44TR.png"></p>
<p>图2-41 Union编辑器</p>
<p>我们可以点击右上角的保存图标来应用对于Union或者Structure的修改。</p>
<p><img src="blob:file:///b0f1e5d2-614c-42fe-80c5-7c01931e64bb" srcset="/img/loading.gif" lazyload alt="202004031011_DX2ERAR93CCENK8.png"></p>
<p>图2-42 保存图标</p>
<p><strong>编辑器中的搜索</strong></p>
<p>我们可以在编辑器的Search栏中输入想要搜索的内容，并通过上下箭头来选择进行向上或是向下的搜索。</p>
<p><strong>对齐</strong></p>
<p>我们可以在Align的勾选框中选择是否对齐。如果勾选，将会出现额外的选项。</p>
<p><img src="blob:file:///aa3508c8-10bf-472f-ad20-28e8bab7bb67" srcset="/img/loading.gif" lazyload alt="202004031012_Y5BA3EP7KXDT5TX.png"></p>
<p>图2-43 额外的选项</p>
<p><strong>未对齐的Structure</strong></p>
<p>当一个Structure未被对齐，它其中的每个组成部分将会紧挨着上一个。也就是说，不会出现自动的对齐或是填充。</p>
<p><strong>对齐的Structure</strong></p>
<p>在对齐的Structure当中，各个组成部分的偏移将会基于他们的数据类型和位置被自动地对齐。一个默认的未定义字节不能被添加到一个对齐的Structure中。而该Structure的总大小取决于所包含的组成部分，以及这些组成部分是否被包入(packed)。如图2-43所示，我们可以在编辑器中指定对齐的属性。</p>
<p>align(minimum)：这个属性指示最小的对齐值。在窗口中可以指定的选项有以下三种。</p>
<p>1 none：不指定最小的对齐值。对该数据类型中组成部分的对齐值取决于其组成部分和包入。</p>
<p>2 machine：将最小的对齐值设置为机器的对齐值。</p>
<p>3 by value：指定最小的对齐值。</p>
<p>pack(maximum)：这个属性指示包入值。在窗口中可以指定的选项有以下两种。</p>
<p>1 none：Structure中的组成部分按照编译器的默认方式对齐，组成部分不被包入。</p>
<p>2 by value：指定包入组成部分时最大的对齐值。</p>
<p><strong>未对齐的Union</strong></p>
<p>当一个Union未被对齐时，其大小就是其最大组成部分的大小。当将一个未对齐的Union放入其他数据类型时，对齐值会是1。</p>
<p><strong>对齐的Union</strong></p>
<p>一个对齐的Union的总大小至少是其最大组成部分的大小，其大小还会受到基于对齐和包入值的影响。与Structure的编辑器中相似地，我们可以在编辑器中对包入值和对齐值进行自定义。Union中所有组成部分的偏移都是0，所以包入值不会对组成部分的偏移造成影响。</p>
<p><strong>编辑操作*</strong>*</p>
<p>接下来我们会介绍在编辑器当中的具体操作。</p>
<p><strong>插入未定义字节</strong></p>
<p>点击下图所示的图标可插入未定义字节，需要注意的是未定义的字节只能被插入到未对齐的Structure当中。</p>
<p><img src="blob:file:///e69f4d78-fe62-4487-b18b-a29ddd50883b" srcset="/img/loading.gif" lazyload alt="202004031012_XEBYYH28PFVVDSW.png"></p>
<p>图2-44</p>
<p><strong>上下的移动</strong></p>
<p>我们可以通过选中一个或一些组成部分并点击上下箭头的图标（如下图所示），来对被选中的组成部分进行向上或向下的移动。</p>
<p><img src="blob:file:///c6dfb78a-abc9-48f0-a80b-264c69e92ead" srcset="/img/loading.gif" lazyload alt="202004031013_RCVZCVQB65A55PP.png"></p>
<p>图2-45</p>
<p><strong>复制组成部分</strong></p>
<p>我们可以复制Structure或Union中的组成部分。</p>
<p>1 选中想要复制的组成部分。</p>
<p>2 如果想要复制一份，选择下图中左边的图标；如果想要复制多份，选择右边的图标，这将弹出一个对话窗口，输入想要复制的份数。</p>
<p><img src="blob:file:///05cb3061-cf25-4a94-82fd-729b652e0fc1" srcset="/img/loading.gif" lazyload alt="202004031013_RRP2B7WDJA8QKGT.png"></p>
<p>图2-46</p>
<p>3 复制的组成部分会紧挨着所选组成部分出现。</p>
<p><strong>创建数组</strong></p>
<p>1 选择一个组成部分。</p>
<p>2 按下形状为的Create Array按键。</p>
<p>3 这将弹出一个询问数组中元素个数的对话窗口，输入个数并选择OK。</p>
<p><img src="blob:file:///4e93adb5-780c-4749-9f16-4db646311378" srcset="/img/loading.gif" lazyload alt="202004031013_E3M3WTYUX2QHBUQ.png"></p>
<p>图2-47 输入元素个数</p>
<p>4 所选的元素将会成为其数据类型的数组。</p>
<p>在一个Structure当中，我们可以从多个组成部分创建数组。第一个所选的组成部分的数据类型将会成为数组的数据类型。</p>
<p>1 选择多个组成部分。</p>
<p>2 按下形状为的Create Array按键。</p>
<p>3 一个数组将被创建。数组的数据类型将取决于第一个所选的组成部分。</p>
<p><strong>Enum 数据类型编辑器</strong></p>
<p>枚举（Enum）数据类型的编辑器更加简单。如下图所示。</p>
<p><img src="blob:file:///537b7684-a005-4d9c-8b4e-80969ea209ac" srcset="/img/loading.gif" lazyload alt="202004031013_YYY24WFSW3GGUF8.png"></p>
<p>图2-48 Enum类型编辑器</p>
<p>我们可以通过右上角的图标，添加或删除枚举入口，并通过保存图标对修改进行保存。因为操作与Structure高度类似，我们便不再重复进行介绍。</p>
<p>#ghidra使用手册</p>
<p><strong>2.6 Console</strong></p>
<p> Console，即控制台，默认位于界面的最底部，用于输出信息。</p>
<p><img src="blob:file:///68d532b6-250f-4c8f-a6f0-6b9b63f6e73a" srcset="/img/loading.gif" lazyload alt="202004031015_74GE4D5VVWZW976.png"></p>
<p>图2-49 控制台</p>
<p>任何插件都可以传递信息至控制台以显示。大部分情况下，控制台被用来显示脚本的输出。</p>
<p>我们可以通过控制台窗口右上方的小图标锁定窗口的自动滚动，或者清除控制台内容，更多关于脚本本身与控制台的内容我们会在后面介绍。</p>
<p>#ghidra使用手册</p>
<p><strong>3.1 Byte Viewer</strong></p>
<p>即字节查看器，可以将内存中的字节以多种形式展示。</p>
<p><img src="blob:file:///278b1cd3-0314-4ff7-9349-c81ffe407f1f" srcset="/img/loading.gif" lazyload alt="202004031044_YG76959JNPEBADY.png"></p>
<p>图3-1 字节查看器</p>
<p>我们可以点击如下图所示的图标，或者选择Window→Bytes:…来打开字节查看器。</p>
<p><img src="blob:file:///7903c1f3-cb7e-41ea-b47a-5180381388c7" srcset="/img/loading.gif" lazyload alt="202004031044_4G2PNVTRRCZG5E6.png"></p>
<p>图3-2 字节查看器图标</p>
<p><strong>3.1.1 数据格式</strong></p>
<p>我们在将在本节中讨论Ghidra提供的默认格式。我们可以点击字节查看器右上角的Set Byte Viewer Options图标来显示我们想要在查看器中展示的格式。</p>
<p><img src="blob:file:///bbd8ab58-f262-4e7e-8328-e7d6bb8c528f" srcset="/img/loading.gif" lazyload alt="202004031044_M544YA9TAKS2EWM.png"></p>
<p>图3-3 更改显示格式</p>
<p><strong>Hex</strong></p>
<p>Hex，即十六进制的格式，将各个字节显示为一个两个字符的十六进制值。该格式支持对字节的编辑。</p>
<p><strong>Ascii</strong></p>
<p>将每个字节显示为其对应的Ascii字符。对于那些不存在于Ascii字符中的字节，查看器将其用.表示。该格式支持对字节的编辑。</p>
<p><strong>Address</strong></p>
<p>地址格式会确认字节所对应的地址是否在程序的内存范围。对于那些在内存范围内的地址，查看器会显示 <img src="blob:file:///2aacb2a0-2c71-4fdd-b277-182df4b4e768" srcset="/img/loading.gif" lazyload alt="202004031045_2JKHN4QSM86Q2NY.png">图标。相对的，如果地址不在内存范围内，查看器会显示.。该格式不支持对字节的编辑。</p>
<p><strong>Disassembled</strong></p>
<p>反汇编格式对未定义的字节显示□。对于指令或定义的字节，查看器会显示.。通过查看该格式，我们可以清楚地看出程序哪些部分被反汇编了。该格式不支持对字节的编辑。</p>
<p><strong>HexInteger</strong></p>
<p>该格式将4个字节显示为一个8位的十六进制数。该格式支持对字节的编辑。</p>
<p><strong>Integer</strong></p>
<p>该格式将4个字节显示为一个十进制数。该格式不支持对字节的编辑。</p>
<p><strong>Octal</strong></p>
<p>该格式将各个字节显示为一个三个字符的八进制数。该格式支持对字节的编辑。</p>
<p><strong>Binary</strong></p>
<p>该格式将各个字节显示为一个八个字符的二进制数。该格式支持对字节的编辑。</p>
<p><strong>3.1.2 编辑内存</strong></p>
<p>通过以下操作开启对字节的编辑。</p>
<p>1 切换查看器中的 <img src="blob:file:///024a3cdf-eab4-43f0-b91b-9f1c034c9e0c" srcset="/img/loading.gif" lazyload alt="202004031045_MNXRKHTXMZS392A.png">按键的状态至允许编辑。</p>
<p>2 选择一个支持编辑的格式。</p>
<p>3 当将光标放置于支持编辑的位置上时，光标会变为明显的颜色（此处为蓝色，默认配色为红色）。编辑过的字节也会显示为该颜色。</p>
<p><img src="blob:file:///78cd63b9-0f0a-43a0-aa95-b7ac0786c832" srcset="/img/loading.gif" lazyload alt="202004031045_FTZTSH59QRK8KAR.png"></p>
<p>图3-4 编辑字节</p>
<p>只有在当前地址不包含指令时，我们才能够对字节进行编辑。如果尝试对包含指令的字节进行编辑，我们会被提示editing not allowed。</p>
<p><strong>3.1.3 查看器设置</strong></p>
<p>Byte Viewer Options，即图3-3所示的设置窗口。我们可以在其中对显示进行更改。</p>
<p><strong>Alignment Address</strong></p>
<p>该属性（对齐地址）指定了所显示地址应如何对齐。查看器会根据所提供的地址对地址的对齐自动进行修改。</p>
<p><strong>Bytes Per Line</strong></p>
<p>该属性（每行的字节数）指定了查看器中每行显示的字节个数。默认的值是16。需要注意的是，诸如HexInteger和Integer这样的格式，将字节4个一组的显示，如果每行的字节数不是4的倍数，而我们又勾选显示了这两个格式，查看器将弹出一个错误信息。</p>
<p><strong>Set Group Size</strong></p>
<p>该属性只对Hex格式生效，它指定了将十六进制格式的字节几个一组显示。</p>
<p>#ghidra使用手册</p>
<p><strong>3.2 Comments</strong></p>
<p>在第二章中我们介绍过在反编译窗口，或是陈列窗口中添加注释。我们可以通过Window→Comments来打开一个显示所有注释的窗口。</p>
<p><img src="blob:file:///3cbe2b45-d099-475c-ab4a-163a93e3d192" srcset="/img/loading.gif" lazyload alt="202004031046_SQV7RJPEGDK93WY.png"></p>
<p>图3-5 注释窗口</p>
<p>我们可以在其中看到所有注释的位置、类型以及内容，通过点击某条注释，我们便可以在CodeBrowser中导航到相应的位置。</p>
<p>#ghidra使用手册</p>
<p><strong>3.3 Bookmarks</strong></p>
<p>在2.1.3当中，我们介绍了如何添加书签（Bookmarks），Ghidra同样提供了对于书签进行统一管理的窗口。选择Window→Bookmarks来将其打开。</p>
<p><img src="blob:file:///90ab3df1-bafc-4ed4-99cb-eef640cd4830" srcset="/img/loading.gif" lazyload alt="202004031047_XDCZN24UMMQQHZ2.png"></p>
<p>图3-6 书签窗口</p>
<p>书签窗口列出了程序当中所有的书签，并显示标签的类型、分类、描述、地址、标签、书签放置位置的代码单元。我们可以通过点击任意书签以在CodeBrowser当中进行导航。</p>
<p><strong>3.3.1 书签过滤器</strong></p>
<p>我们可以通过对过滤器进行设置来决定书签窗口中显示的内容。点击窗口中的 <img src="blob:file:///fe9fd416-44a4-4120-9a38-1bd611de9bfd" srcset="/img/loading.gif" lazyload alt="202004031047_5YNNPK8YRVV2FTZ.png">图标打开过滤器设置窗口。</p>
<p><img src="blob:file:///db9a69d7-15c2-4548-aa26-dc36911c12c8" srcset="/img/loading.gif" lazyload alt="202004031048_C4J7WV2YDGT7SXQ.png"></p>
<p>图3-7 过滤器设置窗口</p>
<p>我们可以简单地通过勾选或是取消勾选来决定显示什么类型的书签。</p>
<p><strong>3.3.2 对书签的编辑</strong></p>
<p>需要注意的是，在书签表格当中，我们只能够对书签的Category和Description列进行编辑。双击想要编辑的位置便可对其进行编辑。</p>
<p><strong>3.3.3 移除书签</strong></p>
<p>1 选择想要移除的书签行。</p>
<p>2 按下Delete按键，或是在书签窗口中点击 <img src="blob:file:///d7300c64-8e34-409b-afbb-cca766a1fffa" srcset="/img/loading.gif" lazyload alt="202004031049_PY9AV9PB2C792GF.png">图标。</p>
<p>#ghidra使用手册</p>
<p><strong>3.4 Data Type Preview</strong></p>
<p>数据类型预览（Data Type Preview），提供了对某个地址上数据类型的预览。我们可以通过Window→Data Type Preview来开启数据类型预览。当我们在陈列窗口移动光标时，数据类型预览也会随之更新。如果预览中出现了一个有效的地址，我们可以双击并在陈列窗口中导向至该地址。</p>
<p><img src="blob:file:///94898c87-f5b5-4040-852f-4436296d4771" srcset="/img/loading.gif" lazyload alt="202004031053_3GKKC7354686ADQ.png"></p>
<p>图3-8 数据类型预览</p>
<p><strong>3.4.1 添加与移除数据类型</strong></p>
<p>点击数据类型预览窗口右上角的+图标，可以选择数据类型的对话窗口。此外，我们可以从数据类型管理器中拖动类型至数据类型预览窗口当中。需要注意的是，数据类型预览窗口不支持动态数据类型。</p>
<p>如果想要移除某个数据类型，选中并点击 <img src="blob:file:///d7300c64-8e34-409b-afbb-cca766a1fffa" srcset="/img/loading.gif" lazyload alt="202004031049_PY9AV9PB2C792GF.png">图标。</p>
<p>#ghidra使用手册</p>
<p><strong>3.5 Defined Data</strong></p>
<p>我们可以通过数据窗口显示当前程序中定义的数据，我们可以选择Window→Defined Data来打开该窗口。</p>
<p><img src="blob:file:///affbf168-9d35-4117-ba33-e163824f2eca" srcset="/img/loading.gif" lazyload alt="202004031055_33WKDX8KANCR94W.png"></p>
<p>图3-9 数据窗口</p>
<p>数据窗口中有四列。Data列显示了该数据的字符串表现形式。Location列显示了其位置。Type列显示了该数据的数据类型。Size列显示了该数据的大小（字节）。我们可以通过点击某一列的顶部来以该列内容排序。我们同样可以通过点击某一行以在CodeBrowser当中导向至相应数据的位置。</p>
<p><strong>3.5.1 过滤器设置</strong></p>
<p>我们可以点击数据窗口上方的 <img src="blob:file:///fe9fd416-44a4-4120-9a38-1bd611de9bfd" srcset="/img/loading.gif" lazyload alt="202004031047_5YNNPK8YRVV2FTZ.png">图标来调出一个设置数据过滤器的对话窗口。</p>
<p><img src="blob:file:///20ba336d-5d84-4da0-9648-5d320f43bb8e" srcset="/img/loading.gif" lazyload alt="202004031056_D4CVWAKEE3CKVM8.png"></p>
<p>图3-10 过滤器设置</p>
<p>我们可以在Filter Enable选项中选择是否开启该过滤器。我们可以在Limit Data To选项中选择：</p>
<p>1 Entire Program：显示程序中所有数据。</p>
<p>2 Current View：只显示CodeBrowser中当前内容中的数据。</p>
<p>3 Current Selection：只显示当前所选择内容当中的数据。</p>
<p>使用勾选框来选定想要显示的数据类型。</p>
<p>#ghidra使用手册</p>
<p><strong>3.6 Defined Strings</strong></p>
<p>字符串窗口能够显示所有程序当中定义的字符串。我们可以从Window→Defined Strings打开字符串窗口。</p>
<p><img src="blob:file:///2a17151c-d87d-45c1-94cb-5f350041e817" srcset="/img/loading.gif" lazyload alt="202004031057_R25KWK6XN3FKJMW.png"></p>
<p>图3-11 字符串窗口</p>
<p>我们可以在其中点击字符串以在陈列窗口中导向至对应的位置。</p>
<p>字符串窗口有以下的列：</p>
<p>Location：字符串所在的位置。</p>
<p>String Value：字符串的值。</p>
<p>String Representation：字符串化的表现格式。</p>
<p>Data Type：该字符串的助记符或是数据类型。</p>
<p>Is Ascii：指示该字符串含不含有非ASCII字符的boolean型。</p>
<p>Has Encoding Error：指示该字符串含不含有不能通过字符集转换的字节的boolean型。这通常说明使用了错误的字符集或是该字符串并非真的是字符串。</p>
<p>Charset：该字符串所使用字符集的名字。</p>
<p>需要注意的是，Is Ascii、Has Encoding Error、和Charset列默认不会显示。我们需要右键点击列头并选择Add&#x2F;Remove Columns…来显示对应的列。</p>
<p>#ghidra使用手册</p>
<p><strong>3.7 Disassembled View</strong></p>
<p>反汇编窗口（Disassembled View）显示所选地址及其之上一小部分地址的反汇编。</p>
<p><img src="blob:file:///989f6ef7-5cdb-4700-bd29-fac005085247" srcset="/img/loading.gif" lazyload alt="202004031058_PADBRDP5PK56RDM.png"></p>
<p>图3-12 反汇编窗口</p>
<p>我们点击Window→Disassembled View打开反汇编窗口。如上图所示，其中高亮所显示的行是我们在陈列窗口中所选的地址，而剩余的行则显示紧挨着所选地址的地址。反汇编窗口只会显示有效的地址预览，也就是说，如果窗口中显示是空的，则当前所选地址不是内存中有效的地址。</p>
<p>#ghidra使用手册</p>
<p><strong>3.8 Functions</strong></p>
<p>函数窗口(Functions Window)列出了程序当中定义的函数。我们可以点击Window→Functions将其打开。</p>
<p><img src="blob:file:///73b24c5a-b7c9-490e-818d-b3d84a34d645" srcset="/img/loading.gif" lazyload alt="202004031059_PNWGC239ABDUVBQ.png"></p>
<p>图3-13 函数窗口</p>
<p>窗口当中有三个列：</p>
<p>Name：显示函数名。</p>
<p>Address：显示函数地址。</p>
<p>Function Signature：显示函数签名的预览。</p>
<p>点击某列的头来按照该列内容排序函数。我们也可以点击某个函数以在CodeBrowser中导向至对应位置。</p>
<p><strong>3.8.1 对比函数</strong></p>
<p>我们可以在函数窗口中对函数进行对比。</p>
<p>1 选择想要对比的两个或多个函数。</p>
<p>2 右键并选择Compare Selected Functions，或是直接点击位于窗口上方的 <img src="blob:file:///9d9e3fa3-1211-409d-9ee1-fc59c33ff9dc" srcset="/img/loading.gif" lazyload alt="202004031059_QA5YKXEYK4V39D5.png">图标。</p>
<p>一个函数对比窗口将会弹出。</p>
<p>#ghidra使用手册</p>
<p><strong>3.9 Function Call Graph</strong></p>
<p>函数调用图（Function Call Graph）是一个对于当前函数收到和使用的函数调用的简单图像化展示窗口。这个功能可以帮助我们理解当前的函数在程序中的作用。我们可以点击Window→Function Call Graph来打开该窗口。</p>
<p><img src="blob:file:///15330b32-f32a-4bfb-bbce-df55e7adfa5a" srcset="/img/loading.gif" lazyload alt="202004031100_DNSZ6BQ72JE62S2.png"></p>
<p>图3-14 函数调用图形</p>
<p><strong>3.9.1 显示与隐藏</strong></p>
<p>在函数调用图形中，我们可以按照需求隐藏或者显示函数调用。</p>
<p><img src="blob:file:///761f00f3-3a63-4528-998f-127ea3cbb2fc" srcset="/img/loading.gif" lazyload alt="202004031101_S6DKG5YMZKHED37.png"></p>
<p>图3-15 显示与隐藏</p>
<p>如上图所示，我们可以通过点击一个节点上的-图标来隐藏其对应连接的路径，也可以通过点击+图标将其显示。需要注意的是，函数调用图形只是整个程序图形当中的一部分，我们看到的图形不是程序中所有的函数以及函数调用。</p>
<p><strong>3.9.2 导向</strong></p>
<p>在默认设置下（窗口右上角的Incoming Navigation为开启状态），双击一个节点便可以以其为中心显示函数调用图。我们也可以利用窗口左上角的左右箭头，来做基于浏览历史的导向。</p>
<p>#ghidra使用手册</p>
<p><strong>3.10 Function Graph</strong></p>
<p>函数图（Function Graph）是一个对陈列窗口中当前函数进行简单图形化的显示窗口。</p>
<p><img src="blob:file:///ee54a746-0f9b-4c14-9c97-85e83c553b9c" srcset="/img/loading.gif" lazyload alt="202004031102_JDS2R3KH8PQUKUQ.png"></p>
<p>图3-16 函数图窗口</p>
<p>如上图所示，该窗口包含右下角的卫星视图以及除此之外的主要视图。</p>
<p><strong>3.10.1 主要视图</strong></p>
<p>主要视图中即除右下角卫星视图之外的部分。主要视图显示了代码块与控制流（箭头）。</p>
<p><strong>代码块</strong></p>
<p>每个图形中的矩形都代表了所选函数中的一部分代码（代码块）。我们可以通过左键点击选中代码块。如同Ghidra中其他工具中的选择一样，我们可以通过按住Ctrl键选择多个代码块。</p>
<p>我们可以通过鼠标滚轮缩放主要视图，也可以通过双击代码块的头部，将该代码块放大并居中显示。放大后，我们可以通过双击代码块当中的内容来进行相应的导向。</p>
<p><strong>组合代码块</strong></p>
<p>我们可以选择两个或者更多的代码块，并将它们组合成一个组合的代码块。这可以帮助我们将函数图变的更加简洁易读。下图中所示的代码块便是由三个代码块组合而成。</p>
<p><img src="blob:file:///c1d67edb-4c95-43e1-9360-18cff27fe73c" srcset="/img/loading.gif" lazyload alt="202004031102_HPX6T8WPMZEKTKE.png"></p>
<p>图3-17 函数图窗口</p>
<p>选择两个或多个代码块，右键并选择Group Selected Vertices，一个标题为Enter Group Vertex Text的对话窗口将会弹出，这个对话窗口中的内容将会显示在组合的代码块中。默认情况下，其内容会列出所组合的代码块的标题（如上图所示）。</p>
<p>如果想要解除代码块的组合，选择组合而成的代码块，并右键点击Ungroup Selected Vertices。</p>
<p><strong>控制流</strong></p>
<p>箭头被用于显示从一个代码块到另一个的流。流分为三种。</p>
<p>1 Fallthrough：一个条件检查的否定情况。</p>
<p>2 Conditional：一个条件检查的肯定情况。</p>
<p>3 Unconditional：无条件的流。</p>
<p>我们可以通过颜色区分这三种流。在函数窗口中右键并选择Properties可以调出对颜色的自定义窗口。我们可以在其中确认以及修改这三种流所对应箭头的颜色。</p>
<p><img src="blob:file:///efb20046-8b4f-4350-bf60-3fa4baa6625f" srcset="/img/loading.gif" lazyload alt="202004031102_R4FZCHE3H3JTW79.png"></p>
<p>图3-18 箭头颜色设置</p>
<p>与对代码块的选择一样，我们可以通过左键点击选中一个箭头，双击一个箭头将会导向至该控制流的终点，再次双击该箭头导向回控制流的起点。</p>
<p>我们可以将光标悬浮于控制流箭头上来获取信息，其中包括控制流的终点与起点的预览。</p>
<p><strong>3.10.2 卫星视图</strong></p>
<p>卫星视图提供了对于整个图的总览。我们也可以在卫星视图中对图整体的位置做出基本的调整。同时，卫星视图中还提示了当前主要视图中的位置位于整个函数图的哪里。我们可以通过勾选或取消勾选右键菜单中的Display Satellite View来决定是否显示卫星视图。</p>
<p>类似地，我们可以通过勾选或取消勾选右键菜单中的Dock Satellite View来决定是否将卫星视图镶嵌于主要视图的窗口当中。</p>
<p>#ghidra使用手册</p>
<p><strong>4.1 Equates Table</strong></p>
<p>这一章当中，我们会介绍剩下的一些使用机会相对少一些的功能窗口（因人因事而异）。</p>
<p>等量（Equates），即是在任意代码单元中对一个数值的字符串表示。比如说，在如下的指令当中：</p>
<p>MOV RAX, $0xf</p>
<p>数值$0xf可以被字符串EQUATES_SAMPLE代替，也即：</p>
<p>MOV RAX, EQUATES_SAMPLE</p>
<p>EQUATES_SAMPLE在这里便是$0xf的等值，也就是说，他们是相等的。</p>
<p><strong>4.1.1 设置等值</strong></p>
<p>我们可以在陈列窗口当中设置等值。</p>
<p><img src="blob:file:///a54b5112-82e6-479d-a900-7d099b882a63" srcset="/img/loading.gif" lazyload alt="202004031104_3SYDTUKWK8C6VT5.png"></p>
<p>图4-1 设置等值</p>
<p>1 右键点击目标标量值，并选择Set Equate，或使用快捷键E。这将调出一个用于设置等值的对话窗口。</p>
<p>2 我们可以从已知的关联字符串当中选择，或是手动输入一个字符串。该字符串会成为目标标量的等值。</p>
<p>3 我们可以看到如下选项：</p>
<p>Current Location：将等值运用于当前所选位置。</p>
<p>Current Selection：只有当我们在程序中选中了一部分内容时，该选项才会被显示为可用。反之，就会如上图一样，选项为灰色。选中后字符串将会应用于所有选中的内容中的对应值。</p>
<p>Entire Program：等值会运用于整个程序当中的所有对应标量。</p>
<p>Overwrite existing equates：只有选择了Current Selection或Entire Program的情况下，该选项才可以被勾选。如果该选项被勾选，当前所选内容或是整个程序中所有对应的标量以及对应等值，将会被替换为现在给定的字符串。如果不勾选，只有那些还没有应用等值的标量，才会被替换为现在给定的字符串。</p>
<p><strong>4.1.2 查看等值</strong></p>
<p>等值表，即Equates Table的作用，便是用来查看等值以及他们的引用。我们可以选择Window→Equates Table来打开等值表。</p>
<p><img src="blob:file:///47b6a4a4-e06a-4843-a803-778708560749" srcset="/img/loading.gif" lazyload alt="202004031104_427Z7DV8KK73BVB.png"></p>
<p>图4-2 等值表</p>
<p>左侧的面板列出了等值的名字、对应值、以及引用的次数。右侧的面板则列出了每次引用的地址。点击右侧面板中的地址可以让CodeBrowser导向至该地址。</p>
<p>我们可以在等值表中重命名等值，只需要双击名字并输入一个新的名字。</p>
<p>#ghidra使用手册</p>
<p><strong>4.2 Function Tag</strong></p>
<p>函数标签（Function Tag）窗口列出了当前打开程序的函数标签。该窗口也会显示当前选中函数的标签。标签可以由用户创建，也可以从预定义集中加载。我们可以选择Window→Function Tags来打开函数标签窗口。</p>
<p><img src="blob:file:///979e1cbc-2fe2-42b3-866e-c1978478dd87" srcset="/img/loading.gif" lazyload alt="202004031106_8C6PBWWXW5EEHZR.png"></p>
<p>图4-3 函数标签窗口</p>
<p>如上图所示，该窗口分为五个区域：</p>
<p>Available Tags List：显示所有能够分配给当前函数的标签。</p>
<p>Assigned Tags List：显示所有已经分配给当前函数的标签。</p>
<p>Tag Input Field：允许用户创建新的标签，可以同时创建多标签。</p>
<p>Filter Field：筛选想要显示的标签。</p>
<p>Action Buttons：从上至下三个按钮分别能：</p>
<p>将选中的标签分配给当前函数；</p>
<p>从当前函数中移除选中的标签； <img src="blob:file:///fa42ca82-e076-4230-b10a-87651fe850ed" srcset="/img/loading.gif" lazyload alt="202004031106_5ZCV63SYTSJ6YKM.png"></p>
<p>删除选中的标签并将其从所有函数中移除。</p>
<p><strong>4.2.1 标签操作</strong></p>
<p><strong>创建标签</strong></p>
<p>我们可以在上文中介绍的Tag Input Field当中创建标签。我们可以用逗号分隔一次性输入并创造多个标签。所有新建的标签将会被显示于Available Tags List当中，不会被分配给任何函数。</p>
<p><strong>删除标签</strong></p>
<p>选中想要删除的标签，并点击 <img src="blob:file:///eec75e83-da95-444b-b29c-d231f941e59a" srcset="/img/loading.gif" lazyload alt="202004031106_X7REDK8WAQUHUY7.png">图标，一个用于确认的对话窗口将会弹出。如果确认删除，该标签会被删除并从所有函数中移除。</p>
<p><strong>编辑</strong></p>
<p>双击一个标签便可以对其进行编辑。从外部源导入的标签不能被编辑或删除。</p>
<p><strong>分配与移除</strong></p>
<p>我们可以通过上文中提到的左右箭头按钮，对所选的标签进行分配或移除。</p>
<p>#ghidra使用手册</p>
<p><strong>4.3 Memory Map</strong></p>
<p>内存映射（Memory Map）窗口显示了当前程序的内存结构。我们可以点击Window→Memory Map或是在工具栏中点击 <img src="blob:file:///b6859724-20d3-40b3-87d0-963cb421a013" srcset="/img/loading.gif" lazyload alt="202004031107_SND6D9Y86WTEZF8.png">图标来打开内存映射窗口。</p>
<p><img src="blob:file:///d47c6079-46fb-4f67-8d24-2330661faf71" srcset="/img/loading.gif" lazyload alt="202004031107_CVU9D99MJYP2PTY.png"></p>
<p>图4-4 内存映射窗口</p>
<p>Ghidra通过内存映射窗口支持四种不同的内存区块类型，分别是：</p>
<p>1 Default：普通的区块类型，可以是初始化的或未初始化的。</p>
<p>2 Bit Mapped：区块提供了“位可寻址”的映射到其他区块上。</p>
<p>3 Byte Mapped：区块提供了“字节可寻址”的映射到其他区块上。</p>
<p>4 Overlay：区块被创建于一个新的重叠的地址空间。</p>
<p><strong>4.3.1 显示内容</strong></p>
<p>内存映射窗口中每一列的内容如下：</p>
<p>Name：内存块的内容。</p>
<p>Start：内存块起始地址（十六进制）。</p>
<p>End：内存块结束地址（十六进制）。</p>
<p>Length：内存块长度（十六进制）。</p>
<p>R：读权限。</p>
<p>W：写权限。</p>
<p>X：执行权限。</p>
<p>Volatile：指示易失的I&#x2F;O内存。</p>
<p>Type：指示内存区块的类型（Default、Bit Mapped、Byte Mapped或是Overlay）。</p>
<p>Source：按照文件导入器生成这些字节填充该区块的文件名字。对于类别为Bit Mapped或是Byte Mapped的区块，Source会显示映射的源地址。</p>
<p>Comment：用户对该内存区块添加的注释。</p>
<p><strong>4.3.2 内存区块编辑</strong></p>
<p><strong>重命名</strong></p>
<p>我们可以在name列双击对所选区块进行重命名。</p>
<p><strong>更改权限</strong></p>
<p>利用R、W、X列中的勾选框对相应的权限进行更改。</p>
<p><strong>初始化内存区块</strong></p>
<p>我们可以通过勾选Initialized列的勾选框来初始化当前未初始化的内存区块。这将调出一个对话窗口，我们输入想要用来填充该内存区块的值。</p>
<p><img src="blob:file:///48e45e09-6b65-4b3a-b26f-b3938af6b482" srcset="/img/loading.gif" lazyload alt="202004031108_HRPBDJ7YMZENRHH.png"></p>
<p>图4-5 指定填充值</p>
<p><strong>编辑注释</strong></p>
<p>我们可以双击内存映射窗口中的注释区域以编辑注释。注释最大长度为256个字符。</p>
<p><strong>4.3.3 内存区块操作</strong></p>
<p><strong>添加</strong></p>
<p>我们可以点击窗口右上角的+图标来添加内存区块，一个用于添加内存区块的对话窗口将会弹出。</p>
<p><img src="blob:file:///f6f18bc5-f9e5-4eca-a0de-ddc53629eb71" srcset="/img/loading.gif" lazyload alt="202004031108_5UTUGJCXGK37JCE.png"></p>
<p>图4-6 添加</p>
<p>Block Name：新的内存区块的名称。</p>
<p>Start Addr：新的内存区块的起始地址。如果程序语言定义了多个地址空间，那么我们也需要指定地址空间。地址空间的选项在只有一个地址空间被定义时不会显示。</p>
<p>Length：新的内存区块的长度。</p>
<p>Comment：注释。</p>
<p>Read、Write、Execute：设置相应的权限。</p>
<p>Volatile：标记为易失性的I&#x2F;O内存。</p>
<p>Block Types：选择内存区块的类型。</p>
<p><strong>移动</strong></p>
<p>与添加操作类似，我们可以点击移动图标 <img src="blob:file:///c230271a-8911-445b-bd74-21d680772770" srcset="/img/loading.gif" lazyload alt="202004031108_BC9ZBNPPVR87KKB.png">，调出移动内存区块的对话窗口。并在New Start Address与New End Address中填入新的起始地址。（如果输入新的起始地址，新的结束地址会被自动计算；如果输入新的结束地址，新的起始地址也会被自动计算）。</p>
<p><strong>分割</strong></p>
<p>选择Split图标 <img src="blob:file:///25fdcd48-1482-4105-b8d1-353011bb3df2" srcset="/img/loading.gif" lazyload alt="202004031109_PYPJMHSH5CG3PXH.png">调出分割内存区块的对话窗口。我们有四种输入分割点的方式。</p>
<p>1 输入首个内存区块（block to split）的结束地址。</p>
<p>2 输入首个内存区块（block to split）的长度。</p>
<p>3 输入第二个内存区块（new block）的起始地址。</p>
<p>4 输入第二个内存区块（new block）的长度。</p>
<p><img src="blob:file:///7c3fc960-cbeb-4989-99cb-a00c30d1af58" srcset="/img/loading.gif" lazyload alt="202004031109_GTT6P63T595WYD3.png"></p>
<p>图4-7 添加</p>
<p><strong>扩展</strong></p>
<p>我们可以选择 <img src="blob:file:///5b92da69-af65-4289-b71c-e6c04bc61a9f" srcset="/img/loading.gif" lazyload alt="202004031109_6Y6YS3BJ3Q2KNES.png">图标来向上或向下对内存区块进行扩展。向上扩展时，在弹出的窗口中指定新的起始地址（New Start Address）；向下扩展时，在弹出的窗口中指定新的结束地址(New End Address)。</p>
<p>#ghidra使用手册</p>
<p><strong>4.4 Register Manager</strong></p>
<p>寄存器管理器Register Manager能够显示程序中不同地址中寄存器被分配的值。我们可以选择Window→Register Manager来将其打开。</p>
<p><img src="blob:file:///46fccc96-2d27-437d-9208-5be625a18f9d" srcset="/img/loading.gif" lazyload alt="202004031110_ZXHDZMC4TGB327M.png"></p>
<p>图4-8 寄存管理器窗口</p>
<p>如上图所示，窗口的左侧包含了程序所有定义的寄存器。如果一些寄存器被语言按类别分组，同一组别的寄存器将在一个文件夹下。当我们在左侧选中了某个寄存器后，窗口的右侧会显示所选寄存器拥有分配的值的地址。</p>
<p><strong>4.4.1 编辑一个地址段的寄存器值</strong></p>
<p>我们可以在窗口右侧中双击一个地址段，这将调出一个编辑寄存器值的对话窗口。</p>
<p><img src="blob:file:///590353a1-2059-4777-92ac-755ea4215553" srcset="/img/loading.gif" lazyload alt="202004031111_YDU4ZKZZHNJNQ6V.png"></p>
<p>图4-9 编辑寄存器值</p>
<p>我们可以在该对话窗口中调整起始与结束地址，并将在该地址的寄存器值进行更改。需要注意的是，如果我们指定了一个更小的地址段，被截断的地址部分会被有效地清除。如上图所示，如果我们将结束地址改为080482ef，那么080482ec至080482ef将拥有指定值0x8049ff4，而080482f0将不会拥有值。</p>
<p><strong>4.4.2 编辑寄存器在多个地址段中的值</strong></p>
<p>我们可以在陈列窗口当中右键点击一个寄存器，并在菜单中选择Set Register Values，或者直接按下Ctrl+R快捷键。这将弹出如下的对话窗口。</p>
<p><img src="blob:file:///9cf55f61-34b0-4e5d-a419-7cdb0476037a" srcset="/img/loading.gif" lazyload alt="202004031111_SCNMVHRE6723W93.png"></p>
<p>图4-10 设置寄存器值</p>
<p>Address(es)栏中显示了将会受到本次改动影响的地址。我们在Value栏中输入指定的值，其默认格式是无符号的十六进制数，不过我们可以在临近的选择栏中选择格式。</p>
<p>类似地，我们可以通过在陈列窗口中右键点击一个寄存器，并选择Clear Register Values来清除寄存器在对应地址段的值，将受到影响的地址段同样会在Address(es)栏中显示。</p>
<p>#ghidra使用手册</p>
<p><strong>4.5 Relocation Table</strong></p>
<p>重定位表（Relocation Table）显示了程序当中定义的每一个重定位。重定位信息由自动导入器创建。我们可以选择Window→Relocaton Table将重定位表窗口打开。</p>
<p><img src="blob:file:///ef27a1e9-3bfe-48ca-963d-61be4b41fb4f" srcset="/img/loading.gif" lazyload alt="202004031112_ZRNPW2AJK7KSXQN.png"></p>
<p>图4-11 重定位表</p>
<p>如上图所示，该窗口显示了以下几列信息，分别是：</p>
<p>Address：重定位被定义的位置。</p>
<p>Type：重定位的类型。</p>
<p>Values：重定位时所用的值。</p>
<p>Bytes：重定位时所用的原字节。</p>
<p>#ghidra使用手册</p>
<p><strong>4.6 Symbol Table &amp; Symbol References</strong></p>
<p>符号表（Symbol Table）显示了程序当中所定义的各个符号。符号，又被成为标签（Label），是名称与地址之间的关联。我们可以选择Window→Symbol Table来打开符号表。默认工具设定下，打开符号表的同时，符号引用表（Symbol References）也会被打开。如下图所示，显示在左侧的为符号表，显示在右侧的则是符号引用表。</p>
<p><img src="blob:file:///fce662b5-df8f-459f-b24d-a06afcb7b041" srcset="/img/loading.gif" lazyload alt="202004031113_XPQQTRXV7H34JHC.png"></p>
<p>图4-12 符号表与符号引用表</p>
<p><strong>4.6.1 符号表</strong></p>
<p>符号表中的各列包括以下内容：</p>
<p>Label：符号的名字。</p>
<p>Location：符号所定义的地址。</p>
<p>Type：符号的类型（函数、外部、类，等等）。</p>
<p>Datatype：在符号地址所应用的数据类型。</p>
<p>Namespace：符号处的命名空间。</p>
<p>Source：标明符号的名字来自哪里。</p>
<p>Reference Count：对该符号的引用次数。</p>
<p><strong>文本过滤器</strong></p>
<p>我们可以使用符号表下方的文本过滤器。</p>
<p><img src="blob:file:///4b69dfa4-6a93-4f4e-ac51-9f6c5d865105" srcset="/img/loading.gif" lazyload alt="202004031113_H5C43T3U2ZGD5GT.png"></p>
<p>图4-13 文本过滤器</p>
<p>我们可以在输入框右侧的图标中选择文本过滤的匹配模式，包括“以…打头”，“完全一致”和“正则表达式”。更右侧的Name Only勾选框决定应用过滤器至名字列或是所有列。</p>
<p><strong>过滤器</strong></p>
<p>除去文本过滤器，符号表还提供了更全面的过滤器。我们可以点击右上角的Configure Symbol Filter <img src="blob:file:///bffa37d6-02d6-4d09-ac5c-486aa99e4054" srcset="/img/loading.gif" lazyload alt="202004031113_JCEQ7JD8XG856WG.png">图标来对过滤器进行配置。</p>
<p><img src="blob:file:///7fa04861-c4d4-4217-96d9-5ce02ddfd3c6" srcset="/img/loading.gif" lazyload alt="202004031114_Z7R9QY8JEKVSEPR.png"></p>
<p>图4-14 过滤器设置</p>
<p>这将调出一个对话窗口。如上图所示，该窗口包含三个部分：Symbol Source（符号源）、Symbol Types（符号类型）和默认情况下被隐藏的Advanced Filters。</p>
<ul>
<li>符号源（Symbol Source）：我们可以在如下勾选框中选择想要显示的符号源。</li>
</ul>
<p>User Defined：用户命名的符号。</p>
<p>Imported：导入信息命名的符号。</p>
<p>Analysis：自动分析器命名的符号。</p>
<p>Default(Functions)：拥有默认名称的函数符号。</p>
<p>Default(Labels)：拥有默认名称的非函数符号。</p>
<ul>
<li>符号类型（Symbol Type）：我们可以在如下勾选框中选择想要显示的符号类型。</li>
</ul>
<p>Instruction Labels：位于存在指令的地址的标志。</p>
<p>Data Labels：位于存在数据或外部标志的地址的标志。</p>
<p>Functions：位于函数被定义的位置的标志。</p>
<p>Namespaces：命名空间的名称标志。</p>
<p>Classes：C++类名称标志。</p>
<p>External Library：外部库名称标志。</p>
<p>Parameters：函数参数名标志。</p>
<p>Local Variables：局部变量名称标志。</p>
<p>Global Register Variable：全局寄存器变量名称标志。</p>
<ul>
<li>高级过滤设置（Advanced Filters）我们可以勾选Use Advanced Filters勾选框来显示高级过滤选项。</li>
</ul>
<p>Externals：只接受外部标志。</p>
<p>Non-Externals：只接受非外部标志。</p>
<p>Primary Labels：只接受地址上的首要标志。应用于标签与函数。</p>
<p>Non-Primary Labels：只接受地址上的非首要标志。应用于标签与函数。</p>
<p>Globals：接受全局命名空间中的标志。应用于标签、函数、命名空间与类。</p>
<p>Locals：接受不在全局命名空间中的标志。应用于标签、函数、命名空间与类。</p>
<p>Register Variables：接受基于寄存器的函数参数或局部变量。</p>
<p>Stack Variables：接受基于栈的函数参数或局部变量。</p>
<p>Entry Points：接受位于外部入口点的标签或函数。</p>
<p>Subroutines：接受被某指令调用的标签。</p>
<p>Not In Memory：接受位于不在内存中的地址上的标签。</p>
<p>Unreferenced：接受没有被引用过的标签或函数（也被称为dead code）。</p>
<p>Offcut Labels：接受不在指令或数据开始处的标签。应用于标签。</p>
<p><strong>4.6.2 符号引用表</strong></p>
<p>窗口右侧的符号引用表显示了关于引用的信息。当我们在符号表中选中了一个符号时，符号引用表中会显示该标志的引用信息。</p>
<p>我们可以通过以下三个切换按钮来控制显示的引用类型：References To、Instruction From和Data From，他们分别对应这三个图标 <img src="blob:file:///745c3cbc-86d7-4f73-8cc5-f63086f4b8de" srcset="/img/loading.gif" lazyload alt="202004031114_A6WT94PQ86CRQJ2.png">。</p>
<p>References To显示所有对当前选中的符号的引用。</p>
<p>Instruction From开启状态下，如果所选符号对应一个函数或是子路径的入口点，所有引用该子路径&#x2F;函数的指令将会被显示。如果所选符号不是一个子路径&#x2F;函数的入口点，所显示内容将为空白。</p>
<p>Data From：开启状态下，如果所选符号对应一个函数或是子路径的入口点，所有引用该子路径&#x2F;函数的数据将会被显示。如果所选符号不是一个子路径&#x2F;函数的入口点，所显示内容将为空白。</p>
<p><img src="blob:file:///d22fcd00-bf2b-4dd5-a578-fca2b4117b35" srcset="/img/loading.gif" lazyload alt="202004031115_UAZ5KPKG8RXG9K3.png"></p>
<p>图4-15 符号引用表</p>
<p>如上图所示，符号引用表所显示的列如下：</p>
<p>Address：对应所选符号的地址。点击地址将能够在CodeBrowser中进行导向（重定位）。</p>
<p>Laebl：显示所选符号引用地址的主要符号名称。</p>
<p>Subroutine：显示所选符号引用地址的子路径&#x2F;函数名称。</p>
<p>Access：指示引用类型。</p>
<p>Preview：引用源位置的指令或数据的预览。</p>
<p>#ghidra使用手册</p>
<p><strong>4.7 Checksum Generator</strong></p>
<p>Ghidra方便地为我们提供了Checksum生成器。我们可以从Tools→Generate Checksum…或者Window→Checksum Generator来调出Checksum生成器窗口。</p>
<p><img src="blob:file:///dd5cc85a-4fe6-4289-ba17-407f60450dc0" srcset="/img/loading.gif" lazyload alt="202004031116_ZXKSS7AP97CCAE4.png"></p>
<p>图4-16 Checksum生成器</p>
<p>可以看到窗口右上角有一些图标 <img src="blob:file:///3aaada51-8c58-4f56-83e5-374e1cbf6248" srcset="/img/loading.gif" lazyload alt="202004031116_33U4U4AB5QVYR8K.png">，我们将从左到右对其一一进行介绍。</p>
<p>1’s Complement：对当前checksum进行1’s complement 操作</p>
<p>2’s Complement：对当前checksum进行2’s complement 操作</p>
<p>XOR：对当前checksum进行异或操作</p>
<p>Carry：对当前checksum进行进位操作</p>
<p>On Selection：当该按钮被选中时，只生成当前选中内容的checksum。反之，则生成整个程序中所有字节的checksum。</p>
<p>As Hex：切换显示十六进制值或是十进制值。</p>
<p>Refreshes Checksum：刷新所生成的checksum。大多数情况下，checksum值会自动更新。</p>
<p>#ghidra使用手册</p>
<p><strong>4.8 Script Manager</strong></p>
<p>脚本管理器（Script Manager）允许我们高效地对Ghidra的功能进行扩展开发。不像传统的Ghidra插件那样需要一个完整的开发环境，我们可以在运行Ghidra的同时开发Ghidra脚本。我们可以对脚本做出更改并立即执行。</p>
<p><img src="blob:file:///e002abbc-9f39-49ac-83b1-c9336bced43c" srcset="/img/loading.gif" lazyload alt="202004031117_SVPCB6RPGDSVDS2.png"></p>
<p>图4-17 脚本管理器</p>
<p>如上图所示，我们可以看到脚本管理器的窗口包括以下部分。</p>
<p>Script Category Tree：靠左侧的脚本类型树将脚本按类型组织。</p>
<p>Script Table：窗口中间最大的部分显示了脚本的各类信息。包括：</p>
<p>   第一列指示是否应该为了该脚本创建一个操作。如果一个脚本拥有菜单路径，或是默认的按键绑定，选中该列中的勾选框会导致对菜单路径&#x2F;按键绑定的操作。</p>
<p>   第二列指示了该脚本的状态。如果空白这说明该脚本没有问题。</p>
<p>   Filename列显示了该脚本的文件名。</p>
<p>   Description列显示了脚本元数据中的描述。</p>
<p>   Key Binding列则显示了脚本所关联的按键绑定。</p>
<p>Filter：过滤器，我们可以用它来搜索想要寻找的脚本。</p>
<p>Description Panel：在窗口最下侧，显示了所选脚本的元数据，包括其作者、描述、按键绑定等。</p>
<p>我们会在后面的章节当中详细介绍如何开发Ghidra的脚本。</p>
<p>#ghidra使用手册</p>
<p><strong>4.9 External Programs</strong></p>
<p>外部程序（External Programs）窗口显示了外部程序名以及与它们相关联的Ghidra程序文件。我们选择Window→External Programs将其打开。</p>
<p><img src="blob:file:///c1efdf53-fbe5-4743-9bf5-98b452e20a4b" srcset="/img/loading.gif" lazyload alt="202004031118_68G2MF6DA8NJJJS.png"></p>
<p>图4-19 外部程序窗口</p>
<p>Name列中显示了外部程序的名称。</p>
<p>Ghidra Program列中显示了与外部程序名称所关联的Ghidra文件。如果显示空白，则说明没有外部引用被解析。如果外部程序名称未与Ghidra文件关联，Ghidra不能够找到外部引用。</p>
<p><strong>4.9.1 添加外部程序名称</strong></p>
<p>点击 <img src="blob:file:///701e22ef-6302-4f91-bc44-1e2b90e797b2" srcset="/img/loading.gif" lazyload alt="202004031118_ND6NRP9MTDJQY8M.png">图标以创建新的外部程序名称。</p>
<p><strong>4.9.2 设置外部名称的关联</strong></p>
<p>选中一个外部程序名称，并点击 <img src="blob:file:///78403896-fdcb-4a45-bdf6-2c2047e07187" srcset="/img/loading.gif" lazyload alt="202004031118_72X2Y5QTTW4HP55.png">图标以设置对其关联的外部程序。选中多个外部程序名称时，该按钮不可用。</p>
<p><img src="blob:file:///3d322ce1-39c5-421c-aa8f-f6e4ade9b4ae" srcset="/img/loading.gif" lazyload alt="202004031119_FRR3XCFKWRKSUN3.png"></p>
<p>图4-20 设置外部程序关联</p>
<p>#ghidra使用手册</p>
<p><strong>5.1 搭建Ghidra Server</strong></p>
<p>一个Ghidra项目中包含某个逆向工程的进度。Ghidra项目将程序进行组织并允许多个用户进行合作。Ghidra中引入了项目池（project repository）的概念，项目仓库中可能有记录了版本的、共享的、或是私有的文件。多个用户可以在共享的项目当中添加文件，获取服务端的文件并且创建新版本的文件。私有文件则存在于本地。</p>
<p>由于本地（非共享）的项目管理非常简单明了，在以下章节当中我们会主要介绍基于Ghidra Server的共享项目管理。</p>
<p>在开始创建项目之前，我们需要先搭建一个Ghidra服务器。Ghidra服务端的功能已经被涵盖于标准的Ghidra发行版本当中。我们会在以下的内容中从头开始搭建一个Ghidra服务器。用于示例的操作系统为Windows 10。</p>
<p>我们首先用第1章当中介绍过的方式，下载、解压并配置好Ghidra的运行环境。</p>
<p>切换到Ghidra的目录当中，进入server目录，可以看到有以下文件（夹）。</p>
<p><img src="blob:file:///383d3460-c550-4b61-85d4-2c3214796d17" srcset="/img/loading.gif" lazyload alt="202004031124_EEWHPMCJRQ4BYA4.png"></p>
<p>图5-1 server目录</p>
<p><strong>5.1.1 服务器配置</strong></p>
<p>在安装以及运行Ghidra服务器之前，我们需要修改server.conf文件来满足我们的特定需求。</p>
<p><img src="blob:file:///5e781f89-46f3-44d0-baa2-b0bb934fe4b2" srcset="/img/loading.gif" lazyload alt="202004031124_TJJXHJ68SUKZ67T.png"></p>
<p>图5-2 配置文件</p>
<p>在文件当中，找到这样的行：</p>
<p><a href="wrapper.app"><em>wrapper.app</em></a><em>.parameter.#</em></p>
<p><img src="blob:file:///6009ec30-64ed-4858-a6dd-ccdec5e39299" srcset="/img/loading.gif" lazyload alt="202004031125_8VS6MQG84PRUTJM.png"></p>
<p>图5-3 定位到这样的行</p>
<p>这些行代表了启动Ghidra服务器时的参数，#说明该行代表第个参数，编辑或添加时应当注意不要使#重复。行的等号右侧则代表了所对应的具体的参数。</p>
<p>启动的参数应如下列格式：</p>
<p>[-ip ###.###.###.###] [-p#] [-a#] [-anonymous] [-ssh] [-d<ntDomain>] [-e<days>] [-u] [-n] <repositories_path></p>
<p>其中，[-ip ###.###.###.###]: 绑定的ip地址（默认情况下将被绑定至hostname）。</p>
<p>[-p#]：使用的TCP端口（默认为13100）。</p>
<p>[-a#]：选择授权模式，其中#可以是0或2;</p>
<p>  0 - 用户私钥</p>
<p>  1 - PKI授权</p>
<p>[-anonymous]：启用匿名的仓库访问。</p>
<p>[-ssh]：启用SSH认证。</p>
<p>[-e<days>]：指定密码过期时间（单位为天），默认时间为1天，只可用于a0模式。</p>
<p>[-u]：要求用户输入用户ID，不应用于a2模式。</p>
<p>[-n]：在登录时启用IP地址反向名称查询。</p>
<p><repositories_path>：指明存储项目仓库的目录。</p>
<p>在图5-3中所显示的两行，表明使用了a0，也即是用户私钥的授权方式；而存储仓库则位于${ghidra.repositories.dir}这个变量当中，这个变量也被定义于该文件中，我们可以找到：</p>
<p><em>ghidra.repositories.dir&#x3D;.&#x2F;repositories</em></p>
<p>通常来说，我们应该避免使用这个默认的仓库地址，最为正确的做法是指定一个位于Ghidra安装目录之外的文件夹并使用绝对路径。因此，我们将其改为</p>
<p><em>ghidra.repositories.dir&#x3D;D:\test</em></p>
<p>当升级Ghidra时，我们需要将之前的参数设置从旧的server.conf复制到新的server.conf当中。我们不应该复制整个旧的server.conf文件，这可能会影响Ghidra服务的运行。</p>
<p><strong>5.1.2 用户授权</strong></p>
<p>Ghidra服务器支持多种授权认证模式。</p>
<p>1 无认证：任何被添加的用户都可以任意连接服务器。</p>
<p>2 本地Ghidra密码（-a0）：与被添加用户所关联的密码被维持于仓库目录的users目录当中。当用户连接服务器时，会被要求输入密码。当一个用户被添加时，默认的密码会是changeme。</p>
<p>3 PKI授权（-a2）：利用PKI用户证书进行授权认证。用户的证书需要是受信任的CA所颁发，并被添加到Ghidra服务器cacerts文件当中。</p>
<p>4 SSH密钥：当本地密码模式被使用时（-a0），SSH认证也会被支持，目前该模式只支持对无头的分析器的使用。</p>
<p>在我们的实例当中，我们仅使用比较易用且通用的本地密码模式（-a0）做示范。</p>
<p><strong>5.1.3 服务器内存管理</strong></p>
<p>我们同样可以在server.conf文件当中设置服务器最大的使用内存。</p>
<p><a href="wrapper.java"><em>wrapper.java</em></a><em>.maxmemory</em></p>
<p>我们可以用如下的公式来估算一个合适的最大内存值。</p>
<p><a href="wrapper.java"><em>wrapper.java</em></a><em>.maxmemory&#x3D;2(16+(32 FileCount&#x2F;10000) + (2 * ClientCount))</em></p>
<p>其中FileCount指仓库中的最大文件数，ClientCount指同时连接的Ghidra客户端数量。我们可以使用Java VisualVM工具来检视服务器运行时所使用的内存。该工具不在Ghidra发行包当中。</p>
<p>在我们的实例当中，我们假设仓库当中最大文件数为5000个左右，且同时连接的客户端数量约为4个，那么我们根据计算得出</p>
<p><a href="wrapper.java"><em>wrapper.java</em></a><em>.maxmemory&#x3D;2(16+(325000 &#x2F; 10000)+（2*4))&#x3D;80</em></p>
<p>默认的maxmemory值为768（MB），因此内存应该是完全够用的，我们便不对其进行改动。</p>
<p><strong>5.1.4 运行服务器</strong></p>
<p>完成了以上配置之后，我们便可以安装并运行服务器。</p>
<p><em>.svrInstall.bat</em></p>
<p>这能将服务器安装为服务并开始运行。如果想要移除安装的服务器服务：</p>
<p><em>.svrUninstall.bat</em></p>
<p>ghidraSvr.bat文件则为我们提供了对服务器一系列的指令。可用的参数包含：</p>
<p>console：在当前的终端窗口运行服务器。</p>
<p>start：开始运行安装好的Ghidra服务器服务。</p>
<p>stop：停止运行安装好的Ghidra服务器服务。</p>
<p>restart：停止并重启安装好的Ghidra服务器服务。</p>
<p>status：显示当前的Ghidra服务器服务状态。</p>
<p>比如，我们想要重启目前已经在运行的服务，输入</p>
<p><em>.ghidraSvr.bat restart</em></p>
<p>在Linux或macOS下对Ghidra服务器的搭建非常类似，只需要运行所对应的shell文件即可。</p>
<p>#ghidra使用手册</p>
<p><strong>5.2 创建项目</strong></p>
<p>之前我们完成了服务器的搭建，接下来我们会在服务器当中创建项目。首先，我们要在服务端添加用户。Ghidra服务器用于管理的脚本为svrAdmin.bat，其用法如下：</p>
<p>svrAdmin.bat [<server-root-path>]</p>
<p>        [-add <user_sid>]</p>
<p>        [-remove <user_sid>]</p>
<p>        [-reset <user_sid>]</p>
<p>        [-dn <user_sid> “<user_dn>”]</p>
<p>        [-admin <user_sid> “<repository_name>”]</p>
<p>        [-list]</p>
<p>        [-users]</p>
<p>        [-migrate-all]</p>
<p>        [-migrate “<repository_name>”]</p>
<p>我们将对这些参数作出说明：</p>
<p><server-root-path>：我们通常没有必要指明该参数。服务器根路径默认取决于server.conf文件的ghidra.repositories.dir变量。</p>
<p>-add：用于添加用户，在我们使用的-a0模式下，用户的初始密码会被设置为changeme。该密码需要在24小时内修改以避免过期。</p>
<p><em>svrAdmin.bat -add mySID</em></p>
<p>-remove：用于移除用户。该命令不会对被移除用户所作的操作历史产生影响。</p>
<p><em>svrAdmin.bat -remove mySID</em></p>
<p>-reset：用于重置用户的Ghidra密码。如果一个用户的密码过期，或被遗忘，我们可以用指令将密码重置为changeme。同样的，重置后密码需要在24小时内被用户更改。</p>
<p>-dn：用于分配用户的标识名。使用PKI认证时，每个用户的标识名需要与他们的用户SID相关联。使用方法：</p>
<p><em>svrAdmin.bat -dn mySID “CN&#x3D;MyName,OU&#x3D;AGENCY,OU&#x3D;DoD,O&#x3D;U.S.Government,C&#x3D;US”</em></p>
<p>-admin：用于添加仓库管理员。服务器管理员可以用该指令指定新的仓库管理员，用法：</p>
<p><em>svrAdmin.bat -admin mySID”myProject”</em></p>
<p>-list：用于列出全部仓库。可以与-users一起使用以显示每个仓库的用户列表。</p>
<p>-users：用于所有能够访问服务器的用户。</p>
<p>-migrate-all：用于将所有仓库迁移至一个索引文件系统当中。迁移会与Ghidra服务器重启时发生。需要注意的是，该操作是单向的，所以我们建议在迁移之前做好仓库的备份。</p>
<p>-migrate：将指定的仓库迁移至索引文件系统中。用法：</p>
<p><em>svrAdmin.bat -migrate “myProject”</em></p>
<p>在我们的服务器当中，我们需要先添加用户。虽说官方文档当中说明要添加SID，但实际上我们添加的内容只是简单的用户名。</p>
<p>命令行输入：</p>
<p><em>.svrAdmin.bat -add trident</em></p>
<p>确定我们Windows防火墙的设置能够放行。服务器开启后，我们可以在另一台机器中打开Ghidra，并创建一个分享项目。打开Ghidra，点击File→New Project，选择Shared Project，并输入服务器的IP地址或是DNS名，输入端口号（我们的服务器使用了默认的13100端口）。</p>
<p><img src="blob:file:///4833c618-ef07-4b49-8b16-c317eb077894" srcset="/img/loading.gif" lazyload alt="202004031126_KGZY5VMDUNDKRF6.png"></p>
<p>图5-4 创建分享项目</p>
<p>这里在使用时应该先创建与本机名称一样的userID </p>
<p>用 .svrAdmin.bat -add 创建</p>
<p>接下来我们输入密码（初始密码为changeme），这时将会弹出一个对话窗口提醒我们修改密码。设定完新密码之后，我们便可以创建新的仓库。</p>
<p><img src="blob:file:///99019444-603e-4998-8e59-d00d67e2e851" srcset="/img/loading.gif" lazyload alt="202004031126_M4VFQ7GYHVE5SMM.png"></p>
<p>图5-5 创建仓库</p>
<p>接下来我们对该仓库的权限进行设置</p>
<p><img src="blob:file:///1fd72b30-eee9-4827-ba24-bcd9b6430958" srcset="/img/loading.gif" lazyload alt="202004031127_SE8GP7W2C5GUY6D.png"></p>
<p>图5-6 权限设置</p>
<p>再设置完仓库的本地路径，我们便完成了这个分享项目的创建。</p>
<p>#ghidra使用手册</p>
<p><strong>5.3 项目仓库</strong></p>
<p>Ghidra中的项目仓库可以被记录版本，也即是说，我们可以追踪一个项目的所有改动历史。仓库支持签入、签出、版本历史。项目仓库在有或没有Ghidra服务器的情况下，都能够使用。如果项目被关联于一个Ghidra服务器，多个用户便可以同时访问该项目当中的文件。</p>
<p>我们将继续以5.2当中所创建的项目仓库为例进行一步步的说明。当我们在客户端将这个共享的项目打开时，Ghidra会尝试连接到该项目所关联的服务器。如果所关联的服务器不在运行，我们仍可以在本地工作于已经签出的文件，但不能访问未签出的文件。我们可以通过项目窗口右下角的线缆图标 <img src="blob:file:///8127b96f-2217-498e-b309-b1caffb4ef26" srcset="/img/loading.gif" lazyload alt="202004031128_XVJHC9RNKJCAX7G.png">快速地判断是否连接到服务器。如果该图标中线缆成断开状态，我们可以点击它来尝试进行重连。</p>
<p><strong>5.3.1 版本控制</strong></p>
<p>我们可以在Ghidra项目窗口中选中一个或多个程序，并点击工具栏中的 <img src="blob:file:///a24b24a4-dc92-4376-87b4-86fa052f5d3c" srcset="/img/loading.gif" lazyload alt="202004031128_KB7D374JQDM2747.png">图标，或是右键并选择Add to Version Control…。这将弹出一个对话窗口，我们可以在其中输入对该文件的注释。</p>
<p><img src="blob:file:///0d972ff8-ca55-4539-9b37-de9b73e1e32e" srcset="/img/loading.gif" lazyload alt="202004031128_EF4QJYCYDC9TDQ9.png"></p>
<p>图5-7 将项目中的crackme_example加入版本控制</p>
<p>勾选Keep File Checked Out，这样我们就不用在加入版本控制之后再将crackme_example签出。Apply to All按钮在我们选中了多个文件时可用，我们可以将输入的注释应用到所有将要添加到版本控制的文件之上。</p>
<p>如下图，我们可以看到已经签出的文件图标右下角会有一个绿色背景的勾. <img src="blob:file:///901f0c9d-113b-4bae-a138-0d74a8678970" srcset="/img/loading.gif" lazyload alt="202004031129_FAM73T4D446VF5G.png">而紫色背景的勾 <img src="blob:file:///78f21e4d-2ff4-4388-b9dd-2b81c0f61a26" srcset="/img/loading.gif" lazyload alt="202004031129_ZT869ATHTDPRUAP.png">则代表该文件为其他用户签入的新版本。</p>
<p><img src="blob:file:///820d52a9-67ca-4e1d-8d9b-d307cce75564" srcset="/img/loading.gif" lazyload alt="202004031129_AJMJKKYWS3ZXU5C.png"></p>
<p>图5-8 已签出的crackme_example</p>
<p><strong>签入</strong></p>
<p>当我们做完改动并保存之后，便可以签入文件（我们不能签入未被改动的文件）。签入会创建该文件的一个新版本。右键选择想要签入的文件，并在工具栏当中选择签入图标 <img src="blob:file:///c74bb980-7a42-4f48-a61d-d75065fb0d57" srcset="/img/loading.gif" lazyload alt="202004031129_9MTNS3F2MRNA855.png">，或者在右键菜单中选择Check In…。这将弹出一个对话窗口，我们可以在其中注释描述我们所做的改动。我们可以勾选Keep File Checked Out来接着签出该文件。我们可以勾选Create “.keep” file来在本地文件系统当中创造一个即将签入的文件的拷贝。</p>
<p>在一个共享的项目仓库当中，我们签入文件时，文件中的改动可能会与服务器当中最新的版本合并。在大多数情况下，合并都将是自动的，不需要任何干涉。然而，如果改动导致了冲突，我们需要在签入时解决冲突。当另一个用户签入他的文件时，我们可以通过导向标记查看从我们签出文件之后他所做的改动。潜在的冲突将以红色标出。我们接下来会更详细地介绍合并的过程。</p>
<p><strong>签出</strong></p>
<p>我们可以选择文件后点击 <img src="blob:file:///c8eac30a-d298-4e94-ad7f-a271d44a428a" srcset="/img/loading.gif" lazyload alt="202004031130_RS87GSJSHZZ74Q7.png">图标，或者在右键菜单当中选择Check Out…。这将弹出一个对话窗口。</p>
<p><img src="blob:file:///e283aad3-6f3c-473b-9d11-86118a476768" srcset="/img/loading.gif" lazyload alt="202004031130_VUX43CCYQSWY22R.png"></p>
<p>图5-9 签出文件</p>
<p>我们可以通过勾选Request exclusive check out来确保其他用户不能签出该文件。如果选中的文件已经被其他用户签出，我们则无法勾选该选项。在我们计划对内存映射做出操作时，勾选该选项是必要的。</p>
<p><strong>撤销签出</strong></p>
<p>我们有时可能希望撤销签出操作，这样我们便可以放弃所有的更改，文件也会还原到服务器当中的最新版本。选中文件，并点击 <img src="blob:file:///991181b0-541c-4d80-a4df-ac6bcb4f568d" srcset="/img/loading.gif" lazyload alt="202004031130_7JFC3GE2QJX93VH.png">图标，或是在右键菜单当中选择Undo Checkout选项。如果我们在此之前对文件进行了更改，这将弹出一个对话窗口以确认我们的操作。</p>
<p><img src="blob:file:///fdc17af2-9efb-47b4-b883-921da261eb46" srcset="/img/loading.gif" lazyload alt="202004031130_A8CPXD2E9TWG2YG.png"></p>
<p>图5-10 撤销签出</p>
<p>类似地，勾选Save copy of the file with a .keep extension勾选框，我们可以创建一个私人的文件复制，扩展名为.keep。如果我们尝试在文件于CodeBrowser中打开时撤销签出，将会看到一个错误信息。我们必须要先关闭文件，才能撤销签出。</p>
<p><strong>更新</strong></p>
<p>当我们工作于一个共享项目仓库当中的文件时，我们需要时不时地更新程序以获取其他人所做出的改动。选择文件并点击 <img src="blob:file:///0829fc2a-affa-4b60-8ce3-e12ab45a123b" srcset="/img/loading.gif" lazyload alt="202004031131_WVQVK7FXZ8P27FT.png">图标，或是在右键菜单当中选择Update…选项，我们便能将仓库中最新版本的程序同步于本地。如果我们的改变与最新版本中的改动产生了冲突，我们会被要求这些改动内容。</p>
<p><strong>撤销劫持</strong></p>
<p>当我们在本地的私人文件与仓库中存在的文件同名时，该私人文件便会被劫持。当另一个用户将文件添加到版本控制中，且我们本地存在同名私人文件时，会发生这种情况。如果想要撤销劫持，我们选中文件，并点击 <img src="blob:file:///2c9e6176-ccba-4417-8df9-572ed15c8e48" srcset="/img/loading.gif" lazyload alt="202004031131_8KD35GVE7VJ8CXJ.png">图标，或者在右键菜单当中选中Undo Hijack…。这将弹出一个对话窗口。类似地，我们可以选择性地创建一个扩展名为.keep的文件复制。</p>
<p><strong>查看版本历史</strong></p>
<p>我们可以右键点击一个文件，并选择Show History…选项。这将弹出一个表格，显示版本创建的日期、创建用户、和版本注释。</p>
<p><img src="blob:file:///b715a642-4759-4846-8447-28923f0d8cd7" srcset="/img/loading.gif" lazyload alt="202004031131_KU5MATTV65BQUDX.png"></p>
<p>图5-11 版本历史</p>
<p>我们可以在这其中方便地浏览历史中的任意版本，右键点击某个版本，并选择Open With→&lt;指定的工具&gt;，我们便可以通过指定的工具打开该版本的文件。这个版本将会以只读模式打开，我们可以对该文件作出更改，但是只能将其保存至新的名字。</p>
<p>此外，如果我们是仓库管理员，且该文件未被签出，我们可以删除最新或最老的版本。</p>
<p><strong>查看签出</strong></p>
<p>我们可以右键点击文件并选择View Checkouts…选项来查看文件被哪些用户签出。调出的表格中会显示签出日期与签出文件的版本号。</p>
<p><img src="blob:file:///66c3c21d-e61c-416e-a8dd-e1809681d973" srcset="/img/loading.gif" lazyload alt="202004031132_9UGCE4NMGXHCKAN.png"></p>
<p>图5-12 查看签出</p>
<p>如果某个用户签出了某文件，且不将其签入或撤销签出，管理员可以通过右键点击并选择Terminate the checkout来终止该签出。</p>
<p>如果想要查看某个文件夹下所有我们签出的文件，我们需要右键点击一个文件夹，并选择Find Checkouts…。</p>
<p><strong>5.3.2 权限控制</strong></p>
<p>在5.2当中，我们展示了在创建一个项目仓库时，需要对权限控制进行设置。在创建完成之后，如果有管理权限，我们也能够再次对权限进行修改。只需要在项目窗口选择Project→Edit Project Access List便能够调出对权限的编辑窗口。</p>
<p>#ghidra使用手册</p>
<p><strong>5.4 存档</strong></p>
<p>我们可以通过存档当前项目（Archive Current Project）将目前打开项目的所有内容储存到指定的文件名下。开始存档前，我们需要将所有运行的工具关闭。</p>
<p><strong>5.4.1 为什么要存档</strong></p>
<p>1 项目会被保存至一个对不同的Ghidra版本都兼容的文件格式。</p>
<p>2 存档一个项目并不会将该项目移除，对该项目的继续使用没有影响。</p>
<p>3 这是一个非常简单高效的备份方式。</p>
<p><strong>5.4.2 如何存档</strong></p>
<p>1 关闭所有工具。</p>
<p>2 在项目窗口，选择File→Archive Current Project…。</p>
<p>3 这将弹出一个对话窗口，在其中指定存档文件保存的位置与名称，并点击OK。</p>
<p><img src="blob:file:///de3cdb4e-3468-459b-b3cb-df404e95f1d4" srcset="/img/loading.gif" lazyload alt="202004031133_WX54CEU3G2BNYQM.png"></p>
<p>图5-13 存档</p>
<p><strong>5.4.3 恢复存档</strong></p>
<p>我们可以将存档的项目文件恢复为一个活跃的项目。</p>
<p>1 如果当期有打开的项目，选择File→Close Project将其关闭。</p>
<p>2 选择File→Restore Project…。</p>
<p>3 在弹出的窗口中指定想要恢复的存档文件（Archive File）、新项目的位置（Restore Directory）与名称（Project Name）。</p>
<p><img src="blob:file:///23eb0778-4b28-40e4-b282-4e01bfa9040e" srcset="/img/loading.gif" lazyload alt="202004031133_HTJJ4VJ29654XJH.png"></p>
<p>图5-14 恢复存档</p>
<p>4 如果恢复项目的位置存在一个同名项目，将会弹出窗口提醒我们，项目已存在（Project Exists）。</p>
<p>#ghidra使用手册</p>
<p><strong>6.1 默认工具</strong></p>
<p>一个Ghidra的工具即是一系列插件（Plugins）的集合。我们可以通过组合不同的插件创建工具。Ghidra提供了很多的插件，不过我们也可以创建自己的插件并将其添加到我们的工具当中。</p>
<p><strong>6.1 默认工具</strong></p>
<p>之前介绍的CodeBrowser即是Ghidra所提供的默认工具，其默认显示于我们的工具箱当中，且包含了所有的核心插件。图标为 <img src="blob:file:///31251f5d-3f37-4340-b8ff-1d4d6dd16eb3" srcset="/img/loading.gif" lazyload alt="202004031401_QCKND995E3HECKH.png">。我们可以在任何时候将其重新导入到工具栏当中。操作如下：</p>
<p>1 在项目窗口中选择Tools→Import Default…。</p>
<p>2 在弹出的对话窗口中选择一个默认工具（CodeBrowser，或是Version Tracking），并点击OK。</p>
<p>3 默认工具将被添加至工具栏当中。如果该默认工具已经存在，那么新添加的默认工具名称将会带上一个数字后缀，比如: CodeBrowser_1。</p>
<p>#ghidra使用手册</p>
<p><strong>6.2 工具管理</strong></p>
<p><strong>6.2.1 创建工具</strong></p>
<p>创建工具能够创建一个空的工具（不含任何插件）。我们可以根据工具的用途来给它添加插件。一个创建工具的整体过程应该如下：</p>
<p>1 确定我们对该工具的需求。</p>
<p>2 确定现存的插件是否能够满足我们的需求。如果现存的插件无法提供对应的功能，我们可能需要自己编写插件。</p>
<p>3 将这些插件添加到现存的工具或是一个新的工具中。</p>
<p>创建新工具的具体操作为：</p>
<p>1 在项目窗口，选择Tool→Create Tool…选项。</p>
<p>2 这将显示一个空的工具，并弹出配置工具的对话窗口。</p>
<p><img src="blob:file:///ffcdc5e8-4305-4a6f-a9d1-ef1d6259fd96" srcset="/img/loading.gif" lazyload alt="202004031442_UWCCWYM9ST26YFT.png"></p>
<p>图6-1 配置工具窗口</p>
<p><strong>6.2.2 配置工具</strong></p>
<p>如图6-1所示，我们可以在配置工具的窗口下对工具进行配置，即是在一个工具上增加&#x2F;移除插件包，或是单独的插件。</p>
<p>我们可以通过勾选插件包对应的勾选框，增添（或移除）该包中的所有插件。需要注意的是，Experimental包不能够整包添加，我们只能够单独添加其中的插件。点击Configure链接，我们便可以对插件进行单独的添加或移除。</p>
<p><img src="blob:file:///91631757-9ad1-47e2-9db4-d05db8b34f26" srcset="/img/loading.gif" lazyload alt="202004031442_G9YRSKQJ4SFFDFZ.png"></p>
<p>图6-2 单独添加插件</p>
<p><strong>6.2.2 将工具保存至工具栏</strong></p>
<p>我们可以在工具当中，选择File→Save Tool，来保存该工具。</p>
<p>如果想要将工具保存为另外的名字，或是想要更换工具图标：</p>
<p>1 在工具中选择File→Save Tool As…。</p>
<p> <img src="blob:file:///fe1c1c41-1058-4364-8fa3-8fbb56750ef4" srcset="/img/loading.gif" lazyload alt="202004031443_7ZZAPPKHR5C44XR.png"></p>
<p>图6-3 保存工具</p>
<p>2 在弹出的对话窗口中输入新的工具名字。</p>
<p>3 选择新工具的图标，并点击Save。</p>
<p><strong>6.2.3 导出工具</strong></p>
<p>我们可以将工具以XML文件导出，这样便可以与其他用户分享我们的工具。</p>
<p>在项目窗口中导出工具：</p>
<p>1 选择File→Export Tool，并选中想导出的工具。</p>
<p>2 指定导出的文件位置与名称。</p>
<p>或者是，</p>
<p>1 右键点击想要导出的工具图标，选择Export…。</p>
<p>2 指定导出的文件位置与名称。</p>
<p>需要注意的是，如果工具包含了Ghidra所不含的插件，比方说，我们自己写的新插件。这种情况下我们需要将包含插件类文件的jar文件跟XML文件一起发布。</p>
<p><strong>6.2.4 导入工具</strong></p>
<p>我们可以将被导出的XML文件导入至Ghidra的工具栏当中。</p>
<p>1 在项目窗口，选择Tools→Import Tools to Tool Chest…。</p>
<p>2 选择一个.tool或是.obj扩展名的文件，并点击Import。</p>
<p>3 工具将被添加至工具栏当中。如果该工具已经存在，那么新添加的工具名称将会带上一个数字后缀，比如: CodeBrowser_1。</p>
<p><strong>6.2.5 编辑插件路径</strong></p>
<p>我们在之前提到过，如果想要将含有自己所编写的新插件的工具发布，需要将包含插件类文件的jar文件一起发布。而想要导入该工具的用户则需要将该jar文件放置于Ghidra的插件路径下。</p>
<p>如果我们想要增添一个插件路径：</p>
<p>1 在项目窗口当中选择Edit→Plugin Path…。</p>
<p>2 一个编辑插件路径的对话窗口将会显示；</p>
<p> <img src="blob:file:///c0da2c7d-880a-43a0-9f5d-84db698be028" srcset="/img/loading.gif" lazyload alt="202004031443_YVK257KZAUSF2R2.png"></p>
<p>图6-4 编辑插件路径</p>
<p>在该窗口当中，选择Add Jar…或是Add dir…按键来选择一个jar文件或是一个目录。在文件选择对话中选择jar文件或是目录。</p>
<p>1 点击Apply（关闭窗口）或OK（不关闭窗口）。</p>
<p><strong>更改搜索顺序</strong></p>
<p>我们可以更改用户插件路径列表中的搜索顺序，选择一个插件路径，并点击向上或向下的箭头图标。搜索顺序由上至下。</p>
<p><strong>设置用户插件Jar目录</strong></p>
<p>我们可以在User Plugin Jar Directory处，输入一个绝对路径，或是点击…按键，在文件系统中选择一个目录。</p>
<p><strong>6.2.6 工具连接</strong></p>
<p>Ghidra中不同的工具能够分享数据并动态地互动，我们可以说这些工具是被连接的。工具通过工具事件（tool events）被连接。当我们：</p>
<p>1 打开或关闭程序。</p>
<p>2 将光标移动至程序中的另一位置。</p>
<p>3 在程序当中做出选择。</p>
<p>工具便会生成事件。</p>
<p>工具的连接是有方向性的。也就是说，我们可以将工具A与B单方向地连接，工具B能够接收使用A生成的事件，而A不能够接收使用B所生成的事件。我们也可以将A与B双向的进行连接。</p>
<p><strong>自动的工具连接</strong></p>
<p>当我们：</p>
<p>1 将一个运行工具的图标拖动至另一个运行工具当中。</p>
<p>或是</p>
<p>2 在工具栏中将一个工具图标拖动到一个运行工具的图标上。</p>
<p>工具会被自动且双向地连接。这也是连接工具最快捷的方式。</p>
<p><strong>手动的工具连接</strong></p>
<p>我们同样也可以手动地连接工具。在项目窗口当中选择Tools→Connect Tools…。</p>
<p>这将弹出用于手动创建工具连接的对话窗口。</p>
<p>1 在Event Producer列表当中选择生成事件的工具。</p>
<p>2 在Event Consumer列表当中选择接收使用事件的工具。</p>
<p>3 在Events Names列表当中选择需要被连接的事件。</p>
<p>需要注意的是，只有在我们想选择具体的连接事件时，手动的工具连接才会显得有用。如果只是想将所有工具的所有事件进行双向的连接，我们可以简单地点击Connect All按键。</p>
<p>#ghidra使用手册</p>
<p><strong>6.3 插件开发</strong></p>
<p>有时，Ghidra自带的插件集合不能够满足我们的需求，这时我们可能需要自己开发插件。</p>
<p><strong>6.3.1 基础</strong></p>
<p>在开始之前，我们建议在CodeBrowser当中选择Help→Ghidra API Help来阅读Ghidra API的官方文档。</p>
<p>当一个Ghidra插件脚本运行时，当前程序的状态会被处理为五个对象：</p>
<p>1 currentProgram：活跃的程序。</p>
<p>2 currentAddress：工具中当前光标位置的地址。</p>
<p>3 currentLocation：工具中当前光标位置的程序位置，如果无程序位置存在，则为NULL。</p>
<p>4 currentSelection：工具中当前的选择，如果无选择存在，则为NULL。</p>
<p>5 currentHighlight：工具中当前的高亮显示，如果无高亮显示存在，则为NULL。</p>
<p>Ghidra基于Java编写，而其插件可以用Java或是Jython进行编写。</p>
<p><strong>6.3.2 脚本编写</strong></p>
<p>我们将先对编写脚本进行介绍。</p>
<p>基于以上的基本了解，我们现在打开脚本管理器，Window→Script Manager。我们在此用ghidra_<a href="basics.py">basics.py</a>文件来做示例。右键并选择Edit with Basic Editor，我们便可以使用Ghidra提供的基本编辑器将其打开。</p>
<p> <img src="blob:file:///d219b049-af8b-486c-9427-668203be254a" srcset="/img/loading.gif" lazyload alt="202004031448_Z83AQF4KXR5JWNW.png"></p>
<p>图6-5 ghidra_<a href="basics.py">basics.py</a></p>
<p>我们可以看到，该文件中介绍了一系列Ghidra API的使用方法。</p>
<p>接下来我们可以尝试创建一个新的脚本。点击Create New Script <img src="blob:file:///f55d742d-ed42-4129-9fbd-9e82bb3d14a6" srcset="/img/loading.gif" lazyload alt="202004031448_VFXZUPYXNFQ2FZH.png">图标，并选择使用Java或是Python，选择文件路径与名称。</p>
<p> <img src="blob:file:///9f51545a-9e22-4723-a914-f7b818f76b74" srcset="/img/loading.gif" lazyload alt="202004031449_DG4QEX5YHWDBQAD.png"></p>
<p>图6-6 新创建的Python脚本</p>
<p>一个编辑器将会弹出。我们可以在相应位置输入该脚本的元数据。标签内容如下：</p>
<p>@author: 说明脚本作者。</p>
<p>@category: 指示脚本目录路径。目录被用.符号分级。比如：</p>
<p>   @category categoryA.categoryB</p>
<p>@keybinding: 该标签指示激活该脚本的键位绑定。格式为ctrl alt shift A-Z,0-9,F1-F12。比如：</p>
<p>   @keybinding ctrl shift A</p>
<p>   @keybinding ctrl alt F12</p>
<p>@menupath: 指示该脚本在顶部菜单中的路径。路径层级用.区分。比如：</p>
<p>   @menupath <a href="File.Run.My">File.Run.My</a> Script</p>
<p>@toolbar: 工具栏中将创建一个用于启动该脚本的按键，该标签指定了该按键的图标。脚本管理器会尝试在脚本目录与Ghidra安装目录下搜索该图像，如果该图像不存在，会使用默认的图标。比如：</p>
<p>   @toolbar myScriptImage.gif</p>
<p>接下来我们会编写一个简单的Python脚本，</p>
<p><img src="blob:file:///7f97146d-e78d-48ac-8bea-1a1f9a82b628" srcset="/img/loading.gif" lazyload alt="202004031449_2Q2F5TGT4ZSX2WN.png"></p>
<p>图6-7 简单的Python脚本</p>
<p>此处，我们使用getName()获取当前程序的名称，并使用popup()将字符串在弹出窗口中显示。更多的API请参考Ghidra API的官方文档，通过Help→Ghidra API Help打开。保存该脚本并运行，可以看到：</p>
<p> <img src="blob:file:///db8d3e6d-857f-4403-b50c-1f95e77cd6d4" srcset="/img/loading.gif" lazyload alt="202004031449_YFUACT3SMDA2UR6.png"></p>
<p>图6-8 弹出窗口</p>
<p>如果使用print，则输出会显示于CodeBrowser中的控制台界面内。</p>
<p><strong>使用Eclipse</strong></p>
<p>如果想要高效地开发真正实用、更加复杂的Ghidra脚本或是插件，我们需要用到GhidraDev Eclipse插件。该插件提供Ghidra与Eclipse间的交互。</p>
<p>我们在脚本管理器当中右键点击一个脚本，并选择Edit with Eclipse，如果是第一次打开，我们会被要求输入Eclipse的安装目录。</p>
<p> <img src="blob:file:///4714e620-91c6-4f6a-84db-f981d55b0cc5" srcset="/img/loading.gif" lazyload alt="202004031450_R2STE9B9PQ3UZ3F.png"></p>
<p>图6-9 设置Eclipse路径</p>
<p>如上图，勾选Automatically Install GhidraDev以自动安装GhidraDev插件。GhidraDev插件以及其文档位于&lt;Ghidra安装目录&gt;&#x2F;Extensions&#x2F;Eclipse&#x2F;GhidraDev&#x2F;。</p>
<p><img src="blob:file:///bb5dd84f-51a6-44bd-ad47-5074cae623cb" srcset="/img/loading.gif" lazyload alt="202004031450_DRX75SDHU4S5H2T.png"></p>
<p>图6-10 创建项目</p>
<p>我们在弹出的窗口当中进行进一步的设置，点击Finish完成设置。</p>
<p>我们便可以在Eclipse当中对脚本进行编辑。需要注意的是，我们只应当在Ghidra的脚本管理器当中运行脚本，而不应该从Eclipse中运行。</p>
<p>我们同样可以在Eclipse当中对脚本进行调试。</p>
<p>1 将目前打开的Ghidra关闭。</p>
<p>2 点击Eclipse中的Debug As…图标 <img src="blob:file:///9d4e475f-e022-423e-b297-c807db25da21" srcset="/img/loading.gif" lazyload alt="202004031451_5ZS47MGNDS9CYCG.png">，并选择Ghidra。</p>
<p>3 仍然从Ghidra的脚本管理器中运行脚本。</p>
<p>我们同样可以在Eclipse中使用Python来编写Ghidra插件，开始之前我们需要安装Eclipse上的PyDev插件。</p>
<p><strong>6.3.3 插件开发</strong></p>
<p>在非常多的情况下，编写脚本并从脚本管理器当中运行便能够满足我们的需求。但有时我们可能需要一个更加直观且完整的插件以供我们制作一个新的工具。GhidraDev支持对于插件的开发，我们在安装并设置好了的GhidraDev（见6.3.2）当中，选择GhidraDev→New→Ghidra Module Project，并创建一个项目。</p>
<p><img src="blob:file:///943dafdd-d8c5-4211-9566-5d692ca18d44" srcset="/img/loading.gif" lazyload alt="202004031451_4WFEHHNKEP5BW2V.png"></p>
<p>图6-11 创建项目</p>
<p>可以看到，该新创建的扩展项目含有以下内容。</p>
<p> <img src="blob:file:///d8c8718d-f865-4123-beb0-0ed117f0437a" srcset="/img/loading.gif" lazyload alt="202004031452_N4MPJX9GVAP9XQS.png"></p>
<p>图6-12 文件内容</p>
<p>src&#x2F;main&#x2F;java</p>
<p>src&#x2F;main&#x2F;resources</p>
<p>这两个文件夹包含了该扩展项目的Java源代码。</p>
<p>src&#x2F;main&#x2F;help</p>
<p>该文件夹存放对于该扩展的在线帮助内容，包括CSS与HTML文件。</p>
<p>ghidra_scripts&#x2F;</p>
<p>存放该扩展的脚本。</p>
<p>data&#x2F;</p>
<p>存放该扩展的数据文件。</p>
<p>lib&#x2F;</p>
<p>存放该扩展的外部Java依赖。如果不存在外部的依赖，我们可以将该目录删除。</p>
<p><strong>示例</strong></p>
<p>接下来我们将开发一个简单的Ghidra插件作为示例。更加详尽的内容请参考Ghidra的API文档。我们选中</p>
<p>src&#x2F;main&#x2F;java&#x2F;myproject&#x2F;MyProjectPlugin.java</p>
<p>我们在此对自定义插件的内容进行修改。</p>
<p> <img src="blob:file:///661398ae-3c61-4a54-ac9c-7ab8d8f7e324" srcset="/img/loading.gif" lazyload alt="202004031452_PX43D6EYGDD8QXZ.png"></p>
<p>图6-13 插件描述</p>
<p>之后我们对窗口中的组件进行简单的修改。</p>
<p><img src="blob:file:///117132cc-d6b0-4738-be89-2cdfe7f2f34a" srcset="/img/loading.gif" lazyload alt="202004031452_H95NEFUPYMYBZPE.png"></p>
<p>图6-14 窗口组件</p>
<p>接下来我们可以像对脚本进行调试一样，对该插件模组进行调试。确保没有正在运行的Ghidra后, 点击 <img src="blob:file:///9d4e475f-e022-423e-b297-c807db25da21" srcset="/img/loading.gif" lazyload alt="202004031451_5ZS47MGNDS9CYCG.png">图标。</p>
<p>进入Ghidra的工具中后，点击File→Configure，在Experimental类别中，勾选上我们新编写的插件，之后在Window中，将该插件打开。</p>
<p><img src="blob:file:///14f3a8af-999f-4baa-9876-e305f1891ffd" srcset="/img/loading.gif" lazyload alt="202004031453_8YJJ4B45FD3DQ3D.png"></p>
<p>图6-15 勾选该插件</p>
<p><img src="blob:file:///5fede103-2144-4d90-aa33-dd1b9b0d9327" srcset="/img/loading.gif" lazyload alt="202004031453_E8XCWU9VCZPKZTD.png"></p>
<p>图6-16 打开插件</p>
<p>可以看到我们的插件窗口。当然这只是一个简单的示例，想要开发能够满足自己特定需求的插件，我们可以参考Ghidra的API文档，而更为直观的例子，我们可以从开源项目的（访问Github官网，并搜索Ghidra找到Ghidra的开源项目)</p>
<p>&#x2F;tree&#x2F;master&#x2F;Ghidra&#x2F;Extensions&#x2F;sample&#x2F;src&#x2F;main&#x2F;java&#x2F;ghidra&#x2F;examples</p>
<p>文件夹当中找到。</p>
<p><em>eclipse 实在是太老了，可能之后有人会开发其他方式的</em></p>
<p>#ghidra使用手册</p>
<p><strong>6.4 扩展实例</strong></p>
<p>开源社区已经为Ghidra编写了不少实用的脚本或是插件，接下来我们将对其中几个进行介绍。</p>
<p><strong>6.4.1 FindCrypt-Ghidra</strong></p>
<p>IDA中比较著名的插件，FindCrypt，为Ilfak Guilfanov（IDA Pro 的主要开发者之一）本人编写，用于快速的查找目标当中的加密函数引用，在逆向工程的领域尤其有用。</p>
<p>而该插件被开发者d3v1l401移植到了Ghidra当中，将其编写成了一个Ghidra脚本，我们可以访问Github官网，并搜索FindCrpyt-Ghidra以找到该项目。</p>
<p><strong>安装</strong></p>
<p>Windows：</p>
<p><em>1 将</em><a href="FindCrypt.java"><em>FindCrypt.java</em></a><em>移动到</em></p>
<p><em>&lt;Ghidra安装目录&gt;GhidraFeaturesBytePatternsghidra_scripts</em></p>
<p><em>2 将findcrypt_ghidra（该脚本的数据库目录）移动到</em></p>
<p><em>C:Users我们的用户</em></p>
<p><em>3 确保Ghidra拥有对于findcrypt_ghidra目录的读写权限。</em></p>
<p>Linux：</p>
<p><em>1 将</em><a href="FindCrypt.java"><em>FindCrypt.java</em></a><em>移动到</em></p>
<p><em>&lt;Ghidra安装目录&gt;&#x2F;Ghidra&#x2F;Features&#x2F;BytePatterns&#x2F;ghidra_scripts</em></p>
<p><em>2 将findcrypt_ghidra（该脚本的数据库目录）移动到~&#x2F;</em></p>
<p><em>3 确保Ghidra拥有对于findcrypt_ghidra目录的读写权限。</em></p>
<p><strong>使用</strong></p>
<p>我们打开脚本管理器，搜索<a href="FindCrypt.java">FindCrypt.java</a>，并运行该脚本。</p>
<p><img src="blob:file:///1ca0e258-0040-43bb-b351-51626c3e16b7" srcset="/img/loading.gif" lazyload alt="202004031455_TEKF7D79A396NX3.png"></p>
<p>图6-17 运行结果</p>
<p>该插件将运行结果输出在了一个弹出窗口当中。</p>
<p><strong>6.4.2 binwalk</strong></p>
<p>同样来自于开源社区的<a href="binwalk.py">binwalk.py</a>脚本，允许我们在Ghidra中对当前程序运行binwalk工具，并将运行结果标记于陈列窗口中。该脚本的代码只有39行。我们可以访问Github官网，并搜索创作者为ghidraninja，名称为ghidra_scripts的开源项目。并找到其中的&#x2F;blob&#x2F;master&#x2F;binwalk.py文件。</p>
<p><img src="blob:file:///175a3266-ff2c-48ca-aaa1-d74868975082" srcset="/img/loading.gif" lazyload alt="202004031455_QZ5CYAYTS9D9FFR.png"></p>
<p>图6-18 binwalk</p>
<p>我们需要提前确保binwalk位于$PATH当中。</p>
<p>#ghidra使用手册</p>
<p><strong>7.1 搜索</strong></p>
<p>在之前的章节当中，我们对于各个插件进行了单独的介绍。在这一章当中，我们会介绍如何在一个程序当中进行搜索与导向。</p>
<p>Ghidra提供了一系列的搜索功能。搜索程序内存功能能让我们在程序内存中快速的寻找字节样式。搜索程序文本功能可以在陈列窗口的不同部分，如注释、标签、助记符中搜索字符串。搜索字符串功能则可以搜索程序内存当中潜在的ASCII字符串。</p>
<p><strong>7.1.1 搜索内存</strong></p>
<p>搜索内存（Search Memory）功能在程序内存定位字节。该搜索基于输入的值，该值可以为十六进制、十进制或是字符串。对于字符串的搜索同样支持使用正则表达式。</p>
<p>1 在工具中，选择Search→Memory，这将打开如下的窗口。</p>
<p><img src="blob:file:///1d55e3b9-9a8c-4f80-870b-e3aaae809498" srcset="/img/loading.gif" lazyload alt="202004031457_5V3MGKVTZNDD9HV.png"></p>
<p>图7-1 搜索内存</p>
<p>1 选择输入值的格式，并输入值。</p>
<p>2 选择Next寻找下一个出现的搜索值，选择Previous寻找上一个，或是选择Search All寻找全部。</p>
<p><strong>搜索格式</strong></p>
<p><strong>Hex 十六进制:</strong></p>
<p>输入的值为一串十六进制数。我们可以用.或是?来匹配任意的单个十六进制位。</p>
<p><strong>String 字符串：</strong></p>
<p> <img src="blob:file:///f9cc4f69-93fd-48f4-9ea4-1799313cf8e9" srcset="/img/loading.gif" lazyload alt="202004031458_JB6NFKCCGDATXJJ.png"></p>
<p>图7-2 字符串格式</p>
<p>我们可以在Format Options处选择指定的编码，启用或者禁用大小写敏感。同时我们可以通过勾选Escape Sequences选项来允许转义字符出现于搜索值当中，比如n。</p>
<p><strong>Decimal 十进制：</strong></p>
<p><img src="blob:file:///b0f5445e-fee6-4597-978d-aefdab70759e" srcset="/img/loading.gif" lazyload alt="202004031458_9BVN79TE68MSKU4.png"></p>
<p>图7-3 十进制</p>
<p>我们在靠中间的面板中选择该十进制数的格式：</p>
<p>Byte：定点的8位数字，即一个字节（-128 ~ 255）。</p>
<p>Word：定点的16位数字（-32768 ~ 65535）。</p>
<p>DWord：定点的32位数字。</p>
<p>QWord：定点的64位数字。</p>
<p>Float：浮点32位数字。</p>
<p>Double：浮点64位数字。</p>
<p>我们只能够输入满足该格式的十进制数字。</p>
<p><strong>Binary 二进制</strong></p>
<p>输入的值为一串二进制数。我们可以用x、?或是.来代表任意的单个二进制位。</p>
<p><strong>Regular Expression 正则表达式</strong></p>
<p>输入值会被解释为Java正则表达式，并将所有的内存视为一个字符串来进行匹配。使用正则表达式时，我们只能进行向前匹配。</p>
<p><strong>内存区块类型</strong></p>
<p>我们可以选择想要进行搜索的内存区块。Ghidra会将来自于程序的文件头中的额外信息储存于特别的内存区块当中，这些区块不位于当前程序的地址空间当中。</p>
<p>Loaded Blocks：选择该选项以只搜索已经加载的内存区块（将会在实际的该程序运行实例当中出现的内存区块）。</p>
<p>All Blocks：将会搜索所有的内存区块。</p>
<p><strong>选择范围</strong></p>
<p>Search All：选择该选项以在所有内存中搜索。</p>
<p>Search Selection：当该选项被选择时，搜索范围将被限制于工具中当前的选择内容，只有当我们在工具中作出了选择时，该选项才可用。</p>
<p><strong>代码单元范围</strong></p>
<p>点击Advanced&gt;&gt;展开高级选项，便能看到该区域（Code Unit Scope）。</p>
<p>Instructions：搜索指令。</p>
<p>Defined Data：搜索定义的数据。</p>
<p>Undefined Data：搜索未定义的数据。</p>
<p><strong>7.1.2 搜索程序文本</strong></p>
<p>搜索程序文本（Search for Program Text）功能允许我们对函数、注释、标签、指令以及定义的数据当中的文本字符串进行搜索。我们可以一个接一个地进行搜索，也可以生成一个搜索结果的列表。选择Search→Program Text以打开该窗口。</p>
<p><img src="blob:file:///4732bcb5-8928-4404-b174-1eecc2ddead3" srcset="/img/loading.gif" lazyload alt="202004031459_7AHEYVZUP8JTYDU.png"></p>
<p>图7-4 搜索文本</p>
<p>我们可以在输入栏中输入我们想要搜索的字符串，类似地，我们可以使用?代表任意单个字符，并用<em>代表任意字符。需要注意的是，该输入区域不支持正则表达式的使用。如果我们想要搜索</em>或是?，则需要使用符号对其进行转义，比如说：*</p>
<p>此外，可以看到，窗口中有以下这些选项。</p>
<p><strong>搜索类型</strong></p>
<p>我们可以看到搜索类型（Search Type）区域有两个可选选项：Program Database Search与Listing Display Search。</p>
<p>Program Database Search选项在该程序数据库当中进行搜索。而Listing Display Search选项则在我们于陈列窗口所看到的东西当中进行搜索。他们会生成不同的结果，因为陈列窗口包含了派生的以及自动生成的信息，而这些信息不存在于数据库当中。数据库也可以包含不显示于陈列窗口当中的信息。以下的表格总结了它们的优缺点。</p>
<p> |Program Database Search| Listing Display Search</p>
<p>优点| 更快；可以得到不在陈列窗口显示的信息。| 搜索的结果反映我们在陈列窗口中可见的信息；包括派生和自动生成的信息都可以被搜索，而这些信息不处于数据库中。</p>
<p>缺点 | 搜索结果可能与陈列窗口中显示的内容不匹配；搜索也被限制于指定的区域。| 可能比数据库搜索要慢非常多。比如说，当我们在一个含有一个注释的大程序中进行搜索，数据库搜索可以立即找到该注释，而陈列窗口搜索在找到该注释前，需要遍历每一个地址；不能找到未显示于陈列窗口的信息。</p>
<p>默认的情况下，数据库搜索会被选中。</p>
<p><strong>渐进式搜索</strong></p>
<p>我们可以渐进地进行搜索：</p>
<p>点击Next或是Previous来向前或是向后进行搜索，搜索的起始点为我们在陈列窗口中的当前位置。</p>
<p>如果找到一个匹配，陈列窗口中当前的位置会被移动到匹配出现的位置。如果未找到匹配，将会出现Not found提醒。</p>
<p><img src="blob:file:///f6412645-f429-446b-847a-50682e323765" srcset="/img/loading.gif" lazyload alt="202004031459_FMDWM48WB8XVXRB.png"></p>
<p>图7-5 未找到匹配</p>
<p>在一个大的程序中进行搜索可能会花一些时间，我们随时可以点击位于搜索进度栏右侧的Cancel图标，来停止进行中的搜索。</p>
<p><img src="blob:file:///025f17f8-1789-449d-a10e-cfd4c1b9c302" srcset="/img/loading.gif" lazyload alt="202004031459_ATQ7H7NS7MFCAFG.png"></p>
<p>图7-6 取消搜索</p>
<p><strong>搜索全部</strong></p>
<p>除了进行渐进式地搜索，我们也可以寻找程序（或是选中内容）当中的所有匹配。点击Search All按键，这将弹出一个显示所有匹配的表格。</p>
<p><img src="blob:file:///bbf711ab-67f5-4804-ac42-7ec94049bf9d" srcset="/img/loading.gif" lazyload alt="202004031500_Z2FCAKHJFTKPAC5.png"></p>
<p>图7-7 搜索全部</p>
<p>当在一个比较大的程序上进行该操作时，结果的表格将先于搜索完成弹出，而表格会随着搜索的进度而更新。类似地，我们也可以取消搜索，取消后，已经得到的匹配结果将仍显示于表格当中。</p>
<p>需要注意的是，我们可能得到同一个地址的多个入口。比如，在一个注释当中，一个字符串可能出现多次。当我们在结果表格中点击一行时，我们在陈列窗口当中的光标会被移动至相应位置。</p>
<p><strong>其他设置</strong></p>
<p>搜索全部功能存在预设的匹配数量上限，默认值为500。在找到500个匹配值后，搜索将会自动停止。我们可以匹配数量上限值：</p>
<p>1 在工具中选择Edit→Tool Options…，并找到其中Search栏。</p>
<p><img src="blob:file:///6cb63dda-9a4b-4e9d-87a8-491eededb267" srcset="/img/loading.gif" lazyload alt="202004031500_ZBX8BK832EPU6XK.png"></p>
<p>图7-8 搜索设置选项</p>
<p>2 如图，在其中Search Limit栏，输入匹配数量上限。</p>
<p>3 点击OK或Apply。</p>
<p>类似地，在该面板中，我们也可以对搜索结果的高亮显示做出自定义。该处的设置同样应用于7.1.1当中的搜索内存功能。</p>
<p><strong>默认的搜索顺序</strong></p>
<p>该功能中，默认的搜索顺序如下：</p>
<p>1 函数</p>
<p>2 区块注释</p>
<p>3 前置注释</p>
<p>4 标签</p>
<p>5 指令助记符</p>
<p>6 指令操作数</p>
<p>7 定义的数据助记符</p>
<p>8 定义的数据值</p>
<p>9 行末注释</p>
<p>10 可重复注释</p>
<p>11 后置注释</p>
<p>而在一个函数当中，顺序如下：</p>
<p>1 函数注释</p>
<p>2 函数签名</p>
<p>3 栈变量类型</p>
<p>4 栈变量名称</p>
<p>5 栈变量便宜</p>
<p>6 栈变量注释</p>
<p>需要注意的是，即便我们更改了陈列窗口中的显示顺序，搜索顺序也不会改变，这可能导致我们在进行渐进式的搜索时，光标会进行前后的移动，而不是预期的，只向搜索的方向进行移动。</p>
<p><strong>7.1.3 搜索字符串</strong></p>
<p>搜索字符串（Search for Strings）功能在当前程序或是指定的选中内容中搜索可能的ASCII或Unicode字符串。结果将被展示于一个表格当中。</p>
<p>在工具当中选择Search→For String…以打开搜索字符串的对话窗口。</p>
<p><img src="blob:file:///ec60bd57-c74c-4a97-9180-6f484988a748" srcset="/img/loading.gif" lazyload alt="202004031500_WQZNUPP5UEM7XKS.png"></p>
<p>图7-9 搜索字符串</p>
<p>如图，我们可以按需对以下选项做出修改（选择）。</p>
<p>Minimum Length：决定将显示字符串的最小长度。</p>
<p>Alignment：搜索将只返回从输入的对齐值开始的结果。</p>
<p>Require Null Termination：勾选时，搜索返回的字符串一定要以Null(&#96;&#96;)结尾；未勾选时，则无特定要求。</p>
<p>Pascal Strings：勾选时，只搜索有效的pascal, pascal 255，或是pascal unicode字符串。</p>
<p>Word Model：指定用于检测可能的单词的字符串分析模型文件。默认的文件为StringModel.sng。搜索结果表格中将会显示一列Is Word，以指示该字符串是否为单词。我们可以将该栏留空以将其忽略。而用户定义的分析模型文件应当被放置于Ghidra&#x2F;Features&#x2F;Base&#x2F;data&#x2F;stringngrams目录下。</p>
<p>Memory Block Types：指定搜索加载的内存区块或是全部内存区块。</p>
<p>Selection Scope：指定在整个地址空间中进行搜索，或是在当前用户选中的内容中进行搜索。</p>
<p><strong>搜索结果</strong></p>
<p>按需设置好这些选项后，我们按下Search，搜索的结果将会以一个表格的形式弹出。</p>
<p><img src="blob:file:///b9af46db-7237-45a6-baba-2f6d47fe4702" srcset="/img/loading.gif" lazyload alt="202004031500_3ZK74TPV8B6TTW5.png"></p>
<p>图7-10 字符串搜索结果</p>
<p>结果中的列如下：</p>
<p>Defined：指示该字符串的状态。我们可以将光标移动到图标上查看图标所代表的状态。</p>
<p>Location：字符串所处地址。</p>
<p>Label：字符串所处位置的标签。</p>
<p>String View：显示该字符串。</p>
<p>String Type：显示该字符串类型。Ghidra支持ASCII字符串，Unicode字符串，pascal字符串，pascal 255字符串与pascal unicode字符串。</p>
<p>Length：字符串中的字符个数。</p>
<p>Is Word：当我们在选项中选择了一个单词分析模型时，该列会显示。指示该字符串是否为单词或是一串单词。</p>
<p><strong>创建字符串</strong></p>
<p>我们可以通过表格中的Make String来创建字符串。选中表格中的一行或多行，并按需修改以下选项。</p>
<p><img src="blob:file:///a56627cd-08aa-4801-aded-2495f3d1a335" srcset="/img/loading.gif" lazyload alt="202004031501_M7JTN97R3PNDTEB.png"></p>
<p>图7-11 创建字符串</p>
<p>Offset：允许用户指定该字符串或是字符列表的起始点。对于pascal字符串，该选项会被忽略，因为更改偏移会让pascal字符串无效。</p>
<p>Auto Label：当勾选时，创建字符串时一个标签将被自动生成。</p>
<p>Include Alignment Nulls：当勾选时，创建的字符串会包含用于对齐的Null值。</p>
<p>Truncate if Needed：勾选时，如果存在冲突，创建截断的字符串。</p>
<p>按需设置好选项后，我们可以按下</p>
<p>Make String：在所选地址创建字符串。</p>
<p>Make Char Array：在所选地址创建一个字符的数组。</p>
<p><strong>7.1.4 搜索地址表</strong></p>
<p>搜索地址表（Search for Address Tables）功能搜索当前程序中可能的地址表。搜索结果将会被显示以一个列表的形式显示。</p>
<p>在工具中选择Search→For Address Tables…选项以搜索地址表。</p>
<p><img src="blob:file:///cbe5bf81-c145-4005-9ab3-591a1fe96f15" srcset="/img/loading.gif" lazyload alt="202004031501_V9WDJRWS92PQRH4.png"></p>
<p>图7-12 搜索地址表</p>
<p>搜索选项如下：</p>
<p>Search Selection：显示搜索范围于陈列窗口中当前的选中内容（只有在陈列窗口中做出选择后，该勾选框才可选）。</p>
<p>Minimum Length：决定显示的地址表的最小长度。</p>
<p>Alignment：地址表必须按给定的字节对齐。</p>
<p>Skip Length：在匹配的地址间跳过的字节数。</p>
<p>按需设置好各个选项后，我们便可以按下Search以开始寻找。类似地，我们可以按下进度栏右侧的Cancel图标来终止搜索。</p>
<p><strong>搜索结果</strong></p>
<p>搜索的结果当中含有如下的列：</p>
<p>Location：地址表的位置。</p>
<p>Label：地址表所处位置的主要标签。</p>
<p>Data(Hex&#x2F;Ascii)：表中第一个元素指向的字节的ASCII与十六进制显示。</p>
<p>Length：地址表的长度。</p>
<p><strong>创建地址表</strong></p>
<p>我们同样可以在该窗口当中创建地址表。</p>
<p>1 在表格当中选择一行或多行。</p>
<p>2 勾选Auto Label选项可以在创建地址表时自动创建标签。</p>
<p>3 如必要的话，我们可以在offset输入栏处输入偏移：</p>
<p><img src="blob:file:///f829efe2-d78f-480e-a83d-e4e750c21c17" srcset="/img/loading.gif" lazyload alt="202004031501_SCN239WKEJXBVPV.png"></p>
<p>图7-13 输入偏移值</p>
<p>   对于单个地址表，输入的偏移不能大于地址表长度减一。</p>
<p>   对于多个地址表，偏移值不能大于其中最小的地址表长度减一。</p>
<p>   输入栏右侧显示了经过调整（即算上了偏移值）的起始地址。当我们选中多个地址表时，此处无显示。</p>
<p>1 点击Make Table按键。</p>
<p>2 一个地址表将会创建于我们所选的位置，包含指向创建的地址的定义地址。</p>
<p><strong>反汇编地址表</strong></p>
<p>1 选中一行或多行。</p>
<p>2 点击Disassemble按键。</p>
<p><strong>7.1.5 搜索直接引用</strong></p>
<p>搜索直接引用（Search for Direct References）功能可以在整个程序当中搜索可能的对当前位置的直接引用。该搜索会尝试寻找组成当前位置地址的字节。搜索的结果也将显示于一个表格当中。</p>
<p><img src="blob:file:///9e38c90f-b63b-463f-ab79-6642ea40b04d" srcset="/img/loading.gif" lazyload alt="202004031501_NFSC4SH6YNACSH5.png"></p>
<p>图7-14 搜索直接引用</p>
<p>我们可以通过以下操作搜索直接引用：</p>
<p>1 在陈列窗口当中点击一个地址。</p>
<p>2 选择Search→for Direct References…。</p>
<p>3 这将弹出显示搜索结果的表格窗口。</p>
<p>如果我们选择了一段地址并搜索直接引用，那么该功能将会搜索对于所有选中地址的可能的引用。我们可以通过Ctrl+A选中程序中所有内容，再进行搜索，以搜索程序内存空间中所有可能的引用。</p>
<p>显示结果的表格中有以下的列：</p>
<p>From Location：直接引用的地址。</p>
<p>Label：引用所在位置的主要标签。</p>
<p>From Preview：显示引用位置的代码单元定义。</p>
<p>To Location：被引用位置的地址。</p>
<p>To Preview：显示被引用位置的代码单元的定义。</p>
<p><strong>基于对齐值的过滤</strong></p>
<p><img src="blob:file:///68ca5d4f-0800-402d-b0d2-4013b1f0be4d" srcset="/img/loading.gif" lazyload alt="202004031502_RJVD3MG4NTZDB5Q.png"></p>
<p>图7-15 对齐值过滤</p>
<p>当我们得到搜索结果后，我们可以对引用位置进行基于对齐值的过滤。如上图所示，我们可以选择1&#x2F;2&#x2F;4或8作为想要的对齐值。只有满足所选对齐值的结果才会显示于表格之中。</p>
<p><strong>7.1.6 指令样式搜索</strong></p>
<p>我们可以使用指令样式搜索（Instruction Pattern Search）功能搜索当前程序中的指定指令。</p>
<p>使用该功能的操作如下：</p>
<p>1 在陈列窗口中选择一段地址（不能选择多段地址）。</p>
<p>2 选择 Search→For Instruction Patterns…。</p>
<p>3 这将打开用于搜索指令样式搜索的对话窗口。</p>
<p><img src="blob:file:///093d0de1-20cf-4a2e-a350-8d251b9063af" srcset="/img/loading.gif" lazyload alt="202004031502_AXHYFEEWQMZDCY8.png"></p>
<p>图7-16 指令样式搜索</p>
<p>我们可以看到，该窗口分为两个大部分：指令表与预览表。前者包含所有用户选中的指令，而后者显示了用于搜索的字符串。</p>
<p><strong>指令表</strong></p>
<p>该部分位于窗口左侧。</p>
<p><img src="blob:file:///e86c6024-cc4f-4551-841b-dfc45f39a7a5" srcset="/img/loading.gif" lazyload alt="202004031502_6X3HJ6V33NDDGYT.png"></p>
<p>图7-17 指令表</p>
<p>所有选中范围内的内容，即便是非指令，都会显示于该表格当中。指令表上方有一行工具栏。我们可以点击一个方格来将其遮盖。</p>
<p>该样式可以涵盖的指令个数上限为500个。</p>
<p> <img src="blob:file:///9454d3f3-b86f-42d6-9f7d-fb32b5f180de" srcset="/img/loading.gif" lazyload alt="202004031502_UDET4KGXXPBH4NK.png"></p>
<p>图7-18 指令表工具栏</p>
<p>从左到右这些图标的作用分别为：</p>
<p>1 清除所有遮盖。</p>
<p>2 遮盖所有数据（非指令）。</p>
<p>3 遮盖所有操作数。</p>
<p>4 遮盖所有标量操作数。</p>
<p>5 遮盖所有地址操作数。</p>
<p>6 根据陈列窗口中的选择内容刷新表格。</p>
<p>7 允许用户手动输入要加载的字节。</p>
<p>8 在陈列窗口中导航至这些指令的位置。</p>
<p><strong>预览表</strong></p>
<p><img src="blob:file:///0df42c41-01fd-49fd-833e-f3fa9b5795f3" srcset="/img/loading.gif" lazyload alt="202004031503_NQJXC6JQBABNQY3.png"></p>
<p>图7-19 预览表</p>
<p>预览表会显示用于搜索的字符串是什么样子，当我们在指令表当中应用或移除遮盖时，预览表其中的内容会动态地进行对应变化。</p>
<p>当预览表以二进制显示时，遮盖的位会以.显示。</p>
<p>以十六进制显示时，如果字节的某些部分含有遮盖的位，那么十六进制值将不会显示。而是会显示其二进制值，其中遮盖的位同样以.表示。比如图中的。</p>
<p>在预览表的工具栏当中，</p>
<p> <img src="blob:file:///e87d360d-d7b3-429c-a8fd-aa11fe859130" srcset="/img/loading.gif" lazyload alt="202004031503_VY43F4QQK4UGVZA.png"></p>
<p>图7-20 预览表工具栏</p>
<p>从左到右的图标作用分别为：</p>
<p>1 切换至二进制显示模式。</p>
<p>2 切换至十六进制显示模式。</p>
<p>3 将当前的预览表内容复制到剪切板当中。</p>
<p>我们可以将预览表中内容复制并保存，以便以后使用。</p>
<p><strong>搜索范围</strong></p>
<p>与其他搜索功能类似地，我们可以选择:</p>
<p>Entire Program: 在整个程序中进行搜索。</p>
<p>Search Selection: 在当前陈列窗口的选中内容中进行搜索。</p>
<p>Forward: 向前搜索。</p>
<p>Backward: 向后搜索。</p>
<p><strong>搜索结果</strong></p>
<p>配置好以上选项后，我们可以点击Search All按键以显示所有的匹配。如果点击Search，不会有结果表格弹出，但陈列窗口中光标将会移动至下一个匹配的位置。</p>
<p><img src="blob:file:///06275063-b049-46db-ad20-e01e7e914f8d" srcset="/img/loading.gif" lazyload alt="202004031503_H3CVXUUA9VMY685.png"></p>
<p>图7-21 Search All显示所有搜索结果</p>
<p>需要注意的是，该搜索会寻找完全一样的字节样式。比如，当我们在一个程序中复制了其RET指令的样式，该样式在其他程序中很可能无法用于有效地搜索RET指令。</p>
<p>尽管如此，我们也能够根据自己的需求在多个程序当中使用该搜索功能。我们可以在程序A的陈列窗口中做出选择，并切换到开启程序B的工具中，选择该功能。</p>
<p><strong>7.1.7 搜索标量</strong></p>
<p>搜索标量（Search for Scalars）功能可以定位当前程序中的标量操作数或标量值。该搜索基于输入的十六进制或是十进制值。</p>
<p>1 在工具中选择Search→For Scalars。这将弹出如下的窗口。</p>
<p><img src="blob:file:///a6b9771f-0ce0-496e-a6b8-13e2441891e7" srcset="/img/loading.gif" lazyload alt="202004031503_2HKDRA9E6TNUSEJ.png"></p>
<p>图7-22 搜索标量</p>
<p>1 可以看到其中的选项有：</p>
<p>  Scalars in Range：在程序中搜索值居于给定范围内的标量。</p>
<p>  Specific Scalar：在程序中搜索给定值的标量。</p>
<p>  Search All：搜索程序中所有内存。</p>
<p>  Search Selection：在工具内当前选中的内容当中进行搜索。</p>
<p>1 我们可以输入十进制或是十六进制数（0x…）。</p>
<p>2 点击Search以开始搜索。</p>
<p><strong>搜索结果</strong></p>
<p>搜索的结果将被呈现于一个表当中。如之前介绍过的，我们也可以从Window→Scalar Table处直接打开标量表。对其中的内容我们不再重复进行介绍。</p>
<p><img src="blob:file:///91b90a57-f196-48a6-b3e1-d16674a5cefc" srcset="/img/loading.gif" lazyload alt="202004031504_XX7GMHYJ92MXU8M.png"></p>
<p>图7-23 搜索标量结果</p>
<p>#ghidra使用手册</p>
<p><strong>7.2 导向</strong></p>
<p>我们在使用Ghidra时，经常会有导向至程序中特定位置的需求，而Ghidra也提供了多种不同的导向方法。其中一种在陈列窗口中进行导向的方式我们已经于2.1.2当中进行过介绍。</p>
<p><strong>7.2.1 Go To</strong></p>
<p>Go To功能可以帮助我们导航至某个地址、标签、表达式。</p>
<p>1 在工具中选择Navigation→Go To…，或是使用快捷键G。</p>
<p>2 这将弹出一个窗口。</p>
<p> <img src="blob:file:///6c074e68-38bb-4c4f-a02a-b2475cced529" srcset="/img/loading.gif" lazyload alt="202004031505_PG3GU5XSH5PX4ER.png"></p>
<p>图7-24 Go To窗口</p>
<p>3 我们可以在其中输入地址、标签、或是表达式，并选择OK。</p>
<p>4 如果该地址、标签、或是表达式有效，CodeBrowser将被重定位至那个位置。</p>
<p>5 如无效，该对话窗口将显示一个错误信息。</p>
<p> <img src="blob:file:///2143d30d-16b0-47c9-ae05-1fdc9ef8f438" srcset="/img/loading.gif" lazyload alt="202004031505_M6Z7X8FZQUENEN3.png"></p>
<p>图7-25 错误信息</p>
<p><strong>导向至地址</strong></p>
<p>我们可以在输入栏中输入地址。输入的值被视为十六进制值。也就是说，0x1000与1000会被视为一样的值。</p>
<p>当程序有多个地址空间且目标地址是模糊的时候，将会显示一个对话。</p>
<p>有如下例子：</p>
<p>一个含有以下内存区块的程序处于不同的地址空间中。</p>
<p>名称|起始地址|结束地址</p>
<p>|-|-|-|</p>
<p>BLOCK1|BLOCK1:00000000|BLOCK1:0000ffff</p>
<p>BLOCK2|BLOCK2:00000000|BLOCK2:0000ffff</p>
<p>BLOCK3|BLOCK3:00000080|BLOCK3:0000ffff</p>
<p>示例1：不模糊的地址</p>
<p>1 将当前位置移动至BLOCK1:00001000。</p>
<p>2 导向至地址5。</p>
<p>3 目标地址不模糊，因为BLOCK1区块含有地址5，所以陈列窗口会移动到地址5。</p>
<p>示例2：模糊的地址</p>
<p>1 将当前位置移动到BLOCK3:00000080。</p>
<p>2 导向至地址5。</p>
<p>3 目标地址模糊，因为</p>
<p>  BLOCK3区块不包含地址5。</p>
<p>  与此同时，BLOCK1和BLOCK2两个区块都包含地址5。</p>
<p><strong>导向至标签</strong></p>
<p>我们可以通过输入一个存在的标签名进行导向。此时，如下两个选项将会影响到导向的结果。</p>
<p>Case Sensitive：</p>
<p>默认的大小写设置为敏感，也就是说，LAB1000与lab1000不一样。我们可以关闭该选项来同时搜索他们。</p>
<p>Dynamic Labels：</p>
<p>该选项只影响那些可能导致多个结果的搜索。勾选该选项会使Ghidra考虑所有的动态标志（未储存的标志，但是因对某个位置引用被生成）。当该选项被关闭时，只搜索定义的标签，且会显著提高搜索速度。</p>
<p>除此之外，我们可以使用<em>代表任意数量（包括0个）的任意字符。示例如下：</em></p>
<p><em>如果我们在寻找以LABEL打头的标签，输入LABEL</em>。</p>
<p>类似地，我们可以用?来表示任意单个字符。</p>
<p><strong>导向至表达式</strong></p>
<p>我们可以输入包括地址、标志的运算表达式。其中的所有数字都将被认为是十六进制数。支持的操作符有+-<em>&#x2F;&lt;&lt;&gt;&gt;。此外，括号也可以用来控制运算的优先级。一些例子：</em></p>
<p><em>ENTRY+10：标志ENTRY的地址加上0x10。</em></p>
<p><em>0x100000+30：地址0x100030。</em></p>
<p><em>0x100000+(2</em>10)：地址0x100020。</p>
<p>+20：当前地址加上0x20。</p>
<p><strong>错误信息</strong></p>
<p>可能弹出的错误信息如下：</p>
<p>1 This is not a query, label or address：我们输入了无效的地址或不存在的标签。</p>
<p>2 No results for…：搜索结果不存在。</p>
<p><strong>7.2.2 导向至下一个&#x2F;上一个代码单元</strong></p>
<p>导向至下一个或上一个代码单元的功能允许我们能够跳转到下一个&#x2F;上一个指令、数据、未定义数据、函数、或是非函数。该导向基于当前陈列窗口当中的光标位置。</p>
<p>当搜索指令、数据或是未定义数据时，Ghidra会跳过紧接着的同类数据。比如，我们当前的光标位于存在指令的地址上，而我们想要导向至下一个指令，那么所有紧接着当前指令的指令将会被跳过，直到我们找到一个非指令。找到该非指令后，Ghidra才会将我们导向至下一个出现的指令。</p>
<p>我们可以在工具当中选择Navigation，便能够看到以下选项。</p>
<p> <img src="blob:file:///16b6e810-b322-4ce0-9e5c-f8468f373007" srcset="/img/loading.gif" lazyload alt="202004031505_PYXR9PAHJRM3DNJ.png"></p>
<p>图7-26 导向至下个&#x2F;上个代码单元</p>
<p><strong>导向方向</strong></p>
<p>我们可以点击Toggle Code Unit Search Direction来切换搜索方向。向下的箭头图标代表当前在向下搜索，向上的箭头图标则代表当前在向上进行搜索。</p>
<p><strong>导向至指令</strong></p>
<p>点击Next Instruction，我们便能够将陈列窗口中的光标定位于下一个指令上。当目前的搜索方向上不存在下一个指令时，该选项不可用。</p>
<p><strong>导向至数据</strong></p>
<p>点击Next Data，我们便能够将陈列窗口中的光标定位于下一个数据上。当目前的搜索方向上不存在下一个数据时，该选项不可用。</p>
<p><strong>导向至未定义数据</strong></p>
<p>点击Next Undefined，我们便能够将陈列窗口中的光标定位于下一个未定义数据。当目前的搜索方向上不存在下一个未定义数据时，该选项不可用。</p>
<p><strong>导向至标签</strong></p>
<p>点击Next Label，我们便能够将陈列窗口中的光标定位于下一个标签。当目前的搜索方向上不存在下一个标签时，该选项不可用。</p>
<p><strong>导向至函数</strong></p>
<p>点击Next Function，我们便能够将陈列窗口中的光标定位于下一个函数。如果我们在函数内部，且方向朝向更低的地址，我们会被导向至当前函数的入口点。</p>
<p>由于该功能的使用频率可能很高，我们可以通过快捷键来实现导向至下一个或是上一个函数。</p>
<p>按下Ctrl+向下方向键导向至下一个函数，即下一个更大地址的函数入口点。</p>
<p>按下Ctrl+向上方向键导向至上一个函数，即下一个更小地址的函数入口点。</p>
<p><strong>导向至非函数指令</strong></p>
<p>点击Next Instruction Not In a Function，我们便能够将陈列窗口中的光标定位于下一个不在某个函数内的指令区块。当我们手动地创建函数，且越过它们以鉴别候选函数时，该功能可能有用。</p>
<p><strong>导向至不同的字节值</strong></p>
<p>点击Next Different Byte Value，该功能会尝试将我们导向至下一个与当前代码单元中的第一个字节的值不同的代码单元。当我们尝试跨越一长串FF或0时，便可以使用该功能。</p>
<p><strong>导向至书签</strong></p>
<p>点击Next Bookmark，我们便能够将陈列窗口中的光标定位于下一个书签处。当目前的搜索方向上不存在下一个书签时，该选项不可用。</p>
<p><strong>7.2.3 导向历史</strong></p>
<p>Ghidra也同样支持利用导向历史进行导向。当前的地址会被推入一个存放导向历史的栈当中。我们可以利用该功能重新访问之前的位置。</p>
<p>在工具栏当中，可以看到以下图标。</p>
<p> <img src="blob:file:///52b83e9a-477d-4dd9-9ae8-b313947207ce" srcset="/img/loading.gif" lazyload alt="202004031506_USZGZ4947W288AX.png"></p>
<p>图7-27 导向历史</p>
<p>我们可以点击向左的箭头导向至上一个位置，或是点击向右的箭头导向至下一个位置。包括但不限于以下的操作将被记录至导向历史当中。</p>
<p>1 使用Go To导向至地址或标签。</p>
<p>2 双击包含地址或标签的操作数。</p>
<p>3 双击XREF。</p>
<p>4 在内存映射窗口中点击一个内存区块的起始或结束地址。</p>
<p>5 在等值表当中点击一个地址。</p>
<p>6 使用某个搜索功能。</p>
<p>我们也可以清除导向历史：在工具中选择Navigation→Clear History。</p>
<p>#ghidra使用手册</p>
<p><strong>8.1 创建会话</strong></p>
<p>可以发现，Ghidra自带的工具除了CodeBrowser，还包括一个名为Version Tracking的工具。</p>
<p>版本跟踪（Version Tracking）指鉴别不同的二进制文件当中所匹配的代码或数据。一个常见用处便是用来跟踪同一文件的不同版本。此外，版本跟踪技术也能够用来检查某段特定代码在某个文件当中的出现。</p>
<p>使用版本跟踪工具最常用的情景可能如下：我们分析了某个二进制文件，并注释、标记了一些重要区域的代码。而该软件的开发者发布了新版本的软件，可能包含Bug修复、功能修改等等。这时我们希望我们的分析能够作用于新版本的软件，且不希望丢失之前的进度。而版本跟踪便能够让我们将之前的注释和标签导入到新的内容当中。</p>
<p>另一种常见的使用情况可能是：我们希望检查某些代码在一个文件中是否出现。比如说，给定一小撮函数，来自于代表着已知恶意软件的代码，我们可以在用版本跟踪来寻找文件中的这些代码。</p>
<p>我们接下来将对使用Ghidra中的版本跟踪工具做一步步的介绍。</p>
<p>首先，我们需要创建一个新的版本跟踪会话。我们可以：</p>
<p>1 将两个程序拖动至工具箱上的版本跟踪工具图标上。 <img src="blob:file:///1dafc404-0ff5-4410-81eb-29928c6b69f7" srcset="/img/loading.gif" lazyload alt="202004031509_Y9DTVZ2RSZTUKBN.png"></p>
<p>抑或是</p>
<p>2 在打开的版本跟踪工具中，选择 <img src="blob:file:///7d6e2c1a-8175-468e-83e2-7b52bf199b49" srcset="/img/loading.gif" lazyload alt="202004031509_DK4BD5KXMSAZW9W.png">Create Session图标。</p>
<p>一个创建会话的窗口将会弹出。在该面板中，我们需要指定储存该会话的位置、名称、源程序与目标程序。源程序（Source Program）是已经被分析，并包含注释、标记的程序，而目标程序（Destination Program）则是将要接受标记、注释的新程序。</p>
<p> <img src="blob:file:///12ae3b45-739b-4157-8e49-4db35328184b" srcset="/img/loading.gif" lazyload alt="202004031509_6ZZPXNDBEM943JV.png"></p>
<p>图8-1 创建会话面板</p>
<p>选择Next之后，先决条件面板将会弹出。其中包含了一系列的校验程序。这些校验程序会分析源程序与目标程序，寻找可能影响版本跟踪成功执行的潜在问题。比方说，源与目标中，定义的函数个数相差太多的话，可能指示着它们不能被相关联。</p>
<p> <img src="blob:file:///f90ab40f-8cce-420a-aea9-511ebc3f5d89" srcset="/img/loading.gif" lazyload alt="202004031509_5MVRDZ7KHSTTH3Q.png"></p>
<p>图8-2 先决条件</p>
<p>我们按下Run Precondition Checks按钮，便能够看到校验结果。</p>
<p>再次点击Next之后，我们可以看到总览面板，总览面板在创建新的版本跟踪会话之前显示了新会话的总览信息，包括会话名、源程序、目标程序。</p>
<p><img src="blob:file:///0b09560d-a9a3-43cd-8986-ba4c8735fedf" srcset="/img/loading.gif" lazyload alt="202004031510_TZYXN65SAX543S6.png"></p>
<p>图8-3 总览面板</p>
<p>#ghidra使用手册</p>
<p><strong>8.2 匹配表</strong></p>
<p>创建完会话之后，一个主要的版本跟踪工具将会被打开。同时，两个子工具也将会打开。我们可以在主要的版本工具窗口点击 <img src="blob:file:///a32d6273-0729-41fd-af37-52102183b2aa" srcset="/img/loading.gif" lazyload alt="202004031513_UYTNTQJ5EW5JSRJ.png">图标来运行某些算法以生成可能的匹配。</p>
<p>所生成的匹配表如下。 <img src="blob:file:///a98abec8-026d-4feb-8426-bd9e8c020014" srcset="/img/loading.gif" lazyload alt="202004031513_RJZRT9KPD2ENSCY.png"></p>
<p>图8-4 匹配表</p>
<p>匹配代表着一个程序中的数据或函数与另一个程序中的数据或函数相同。将一个程序中的函数或数据与另一个程序中的组对被称为关联。同一组关联可能被一个和更多的相关性推演算法生成多个匹配意见。当一个匹配被认为是正确时，它会被标记为接受的（accepted）。当一个匹配被接受，该组关联是实际被接受的内容，因此所有作用于该组关联的匹配都会被接受。此外，所有相斥的匹配将会被标记为屏蔽的（blocked）。所谓相斥的匹配是指拥有相同的源地址与不同的目标地址，或是拥有相同的目标地址与不同的源地址。比如说，当一个程序中的A与另一个程序中的X组成的匹配意见被接受时，A与另一个程序中Y的匹配意见将会被屏蔽，因为A不能同时与X和Y相关联。</p>
<p><strong>8.2.1 匹配状态</strong></p>
<p>我们可以在匹配表当中直观的看到每个匹配的基本状态：</p>
<p>状态| 图标 | 描述</p>
<p>|-|-|-|</p>
<p>AVAILABLE| |该匹配被接受且应用。</p>
<p>REJECTED| <img src="blob:file:///d5556505-5ab4-47b0-987f-02ec2b6f6ede" srcset="/img/loading.gif" lazyload alt="202004031513_GP8RN8NCSVREWNY.png"> | 该匹配被用户拒绝。</p>
<p>BLOCKED| <img src="blob:file:///b51822d9-ea44-431c-9dec-40794823fe2c" srcset="/img/loading.gif" lazyload alt="202004031513_PARPCMKYZ3F5K3S.png"> | 该匹配不能被接受，因为一个相斥的匹配被接受了；我们可以将匹配表按源地址或目标地址排序来查看相斥的关联。</p>
<p>ACCEPTED| <img src="blob:file:///d6d3d540-3b80-4b5e-b021-3778b66a7cc9" srcset="/img/loading.gif" lazyload alt="202004031513_PBMAG5AFW9DZCZR.png">|该匹配已被接受。</p>
<p>ACCEPTED - Not Done | <img src="blob:file:///606a11bd-2916-464a-a071-03b7138456b8" srcset="/img/loading.gif" lazyload alt="202004031514_AFY5X3ZCQXSHZEJ.png"> | 该匹配已被接受。但至少有一个标记物未被检验。</p>
<p>ACCEPTED - Fully considered| <img src="blob:file:///ec450adb-a3fd-4ec5-a595-d4bb8bca2017" srcset="/img/loading.gif" lazyload alt="202004031514_RJ9XDWC2SYDJQ5V.png"> | 该匹配已被接受且所有标记物已被应用或者忽略。</p>
<p>ACCEPTED - Fully Applied| <img src="blob:file:///2ebca1bd-6cab-4732-9fcf-66ba07707a1e" srcset="/img/loading.gif" lazyload alt="202004031514_MCXS2RMBEFTSJ4R.png">| 该匹配已被接受且所有标记物已被应用。</p>
<p><strong>8.2.2 匹配表内容</strong></p>
<p>以下则是对表格中所有列内容的介绍：</p>
<p>Session ID：得到该匹配的相关性推演算法的ID。</p>
<p>Tag：应用于该匹配的用户定义标签。</p>
<p>Status：如上表格，显示图标以说明对应的匹配状态。</p>
<p>Type：说明匹配的为函数或是数据。</p>
<p>Source Label：匹配源地址处的标签。</p>
<p>Dest Laebl：匹配目标地址处的标签。</p>
<p>Multiple Source Labels?：指示该匹配源地址有无多个标签，如有，将指示标签个数，我们可以将光标悬浮于图标上以查看多个标签名称。</p>
<p>Multiple Dest Labels?：指示该匹配目标地址有无多个标签，如有，将指示标签个数，我们可以将光标悬浮于图标上以查看多个标签名称。</p>
<p>Score：该匹配的相似度得分。分值将会位于0.0与1.0之间。该分数指示相匹配的两处的相似程度。我们不应比较不同相似度推演算法得来的匹配得分。</p>
<p>Confidence Score：该匹配的确定性分数。更高的确定性分数指示对于该匹配正确更高的确定性。同样地，我们不应比较不同相似度推演算法得来的确定性分数。</p>
<p>Source Length：源函数或数据的长度。</p>
<p>Dest Length：目标函数或数据的长度。</p>
<p>Votes：从之前接受的匹配引用的数量。</p>
<p>Source Address：源程序中数据或函数的地址。</p>
<p>Dest Address：目标程序中数据或函数的地址。</p>
<p>Algorithm：用于生成该匹配的算法。</p>
<p>Length Delta：源对象与目标对象的长度差。</p>
<p>Source Label Type：源程序中标签的源（导入而来&#x2F;分析得到的&#x2F;用户定义的等等）。</p>
<p>Destination Label Type：目标程序中标签的源（导入而来&#x2F;分析得到的&#x2F;用户定义的等等）。</p>
<p>Markup Status：显示标记物的状态。</p>
<p>#Conflicting：冲突的关联个数。如果我们接受该行中的匹配，这将是将会被屏蔽的关联的个数。</p>
<p><strong>8.2.3 匹配表操作</strong></p>
<p>我们可以在匹配表处做出以下的操作，在任意一行打开右键菜单，可以看到：</p>
<p>Accept Match：接受该匹配。所有相斥的匹配将会被屏蔽。</p>
<p>Apply Blocked Match：清除相斥的匹配并应用被因冲突而被屏蔽的该匹配。</p>
<p>Apply Markup：尝试应用所用标记物于该匹配。如果该匹配未被接受，其将先被接受。</p>
<p>Reject Match：将该匹配标记为拒绝的。</p>
<p>Choose Match Tag：从已经编辑好的标签当中选择，并应用于该匹配。</p>
<p>Remove Match Tag：移除选中匹配的标签。</p>
<p>Edit Tag：编辑标签。</p>
<p>Clear Match：将该匹配重设为未接收的，并撤销所有应用的标记。</p>
<p>Remove Match：从匹配表移除一个手动创建的匹配。</p>
<p>Make Selections：在打开源程序的工具与打开目标程序的工具当中做出对应该匹配内容的选择。</p>
<p><strong>8.2.4 匹配表过滤器</strong></p>
<p>除此之外，我们可以通过匹配表格中的过滤器来筛选我们想要的内容。</p>
<p>我们可以在表格的底部看到一些常用的过滤内容。</p>
<p><img src="blob:file:///e18b3640-8529-4ebb-b089-5fc1cc4f1d22" srcset="/img/loading.gif" lazyload alt="202004031514_ER9Y8UF4D79UBBP.png"></p>
<p>图8-5 匹配表过滤设置</p>
<p>其中包括：</p>
<p>1 文本：基于我们输入的文本进行筛选。</p>
<p>2 分数：基于相似度分数进行过滤。</p>
<p>3 确定性：基于确定性分数进行过滤。</p>
<p>4 长度：过滤掉比输入长度短的对象。</p>
<p>如图8-5，我们将显示的匹配限制于相似度分数基于0.5到1之间，确定性分数限制于0到1之间，但不对文本和长度做出限制。</p>
<p>此外，我们还可以点击 <img src="blob:file:///18d89be8-d55d-4f3e-80ea-528534b73d77" srcset="/img/loading.gif" lazyload alt="202004031514_XMHN2QESGFSDJVR.png">图标来进行完整的过滤器设置。</p>
<p><img src="blob:file:///30692ab1-bc47-4206-b82d-d6862722a080" srcset="/img/loading.gif" lazyload alt="202004031515_F49E867FAM73BV8.png"></p>
<p>图8-6 完整的过滤器设置</p>
<p>如上图，可以设置的内容包括：</p>
<p>Match Type：显示函数或数据的匹配。</p>
<p>Associatoin Status：通过关联的状态筛选显示内容。</p>
<p>Symbol Type：通过源或目标对象处标签的符号类型筛选显示内容。</p>
<p>Algorithms：通过使用的相关性推演算法筛选显示内容。</p>
<p>Address Range：通过指定的地址范围限制源或目标地址。</p>
<p>Tags：通过标签限制显示内容。</p>
<p>#ghidra使用手册</p>
<p><strong>8.3 函数表</strong></p>
<p>我们可以在版本跟踪工具当中选择Windows→Version Tracking Functions来打开版本跟踪的函数表格。该表格显示了源程序与目标程序当中所有的函数。我们可以筛选该表格以只显示那些不在匹配中的函数，这样方便我们手动创建匹配。</p>
<p><img src="blob:file:///3e390dac-a8ec-46b3-975e-416e4b5cfe13" srcset="/img/loading.gif" lazyload alt="202004031528_ZPSFF85FEBX7J5M.png"></p>
<p>图8-7 函数表格</p>
<p>如果我们分别选中一个目标函数与一个源函数，而恰好存在他们的匹配时，将会显示消息</p>
<p>A match already exists between &lt;源函数名&gt; and &lt;目标函数名&gt;.</p>
<p>比如，在下图中，我们分别选中目标与源中的main函数。</p>
<p><img src="blob:file:///ff2368c2-732c-4498-9556-b56de7f246c1" srcset="/img/loading.gif" lazyload alt="202004031528_FMRCJ5EC6MYQJ9X.png"></p>
<p>图8-8 存在匹配</p>
<p><strong>8.3.1 函数表内容</strong></p>
<p>函数表中存在以下列：</p>
<p>Label：该列显示函数的标签。</p>
<p>Location：该列显示函数的地址。</p>
<p>Function Signature：该列显示函数签名。</p>
<p><strong>8.3.2 函数表操作</strong></p>
<p>版本跟踪函数表允许我们做出一些操作。首先，我们可以在右键菜单中看到如下的选项：</p>
<p>Create Manual Match：该操作允许用户对所选的函数间创建匹配。如果我们没有在两个表中各选中一个函数，该选项将被禁用。</p>
<p>Create And Accept Manual Match：该操作允许用户对所选的函数间创建匹配，并自动接受该匹配。如果我们没有在两个表中各选中一个函数，该选项将被禁用。</p>
<p>Create And Apply Munual Match：该操作允许用户对所选的函数间创建匹配，并自动接受且应用该匹配。如果我们没有在两个表中各选中一个函数，该选项将被禁用。</p>
<p>此外，我们在两个表格中各选中一个函数的情况下，点击 <img src="blob:file:///5073e1bf-633b-4a03-907a-15fe88c2ee67" srcset="/img/loading.gif" lazyload alt="202004031528_EXTBQTXGE6FQE6K.png">图标。匹配表中这两个函数间存在的匹配将被选中。只有当选中函数间存在匹配时，该图标才可用。</p>
<p>与大多数其他表格类似地，我们也可以通过过滤器对表格中的显示内容作出筛选。首先，我们可以在如下图所示处，选择对应选项以进行筛选。</p>
<p> <img src="blob:file:///2641fb4f-bac9-45e1-bb91-1d6c9e4c0531" srcset="/img/loading.gif" lazyload alt="202004031528_ZFERGN6WYPYHBK5.png"></p>
<p>图8-9 筛选选项</p>
<p>Show All Functions：默认选项。显示源程序与目标程序当中所有的函数。</p>
<p>Show Only Unmatched Functions：只显示不处于任何匹配中的函数。我们可以选择该选项以显示所有未被程序关联器匹配的函数。</p>
<p>Show Only Unaccepted Match Functions：只显示不处于任何已接受匹配中的函数。这意味着所显示的函数不处于任何匹配中，抑或是处于未被接受的匹配中。</p>
<p>除去这些选项，我们也可以使用表格下方的文本过滤器。</p>
<p>我们还可以点击 <img src="blob:file:///67dd8d26-a9c3-4251-839d-37cd7879b39d" srcset="/img/loading.gif" lazyload alt="202004031529_AGKA4T9KFDZTFDH.png">图标，切换是否显示函数的对比面板。如果显示，其将显示于函数表格下方。</p>
<p><strong>8.3 隐含匹配表</strong></p>
<p>一个隐含的匹配即是一个由其他匹配暗示的函数或数据匹配。而隐含匹配表则显示了匹配表中所选中匹配暗示的匹配。比如，我们在匹配表当中选中源程序与目标程序的main函数之间的匹配。</p>
<p> <img src="blob:file:///486db3f4-1b6c-4aef-91b3-3493be5ab49e" srcset="/img/loading.gif" lazyload alt="202004031529_8A32K77QHRKWEFE.png"></p>
<p>图8-10 隐含匹配表</p>
<p>可以看到两个程序中main函数的匹配的隐含匹配显示于隐含匹配表当中。</p>
<p><strong>8.3.1 隐含匹配表内容</strong></p>
<p>隐含匹配表当中有以下列：</p>
<p>Source Reference Address：显示源程序中该隐含匹配的引用地址。</p>
<p>Destination Reference Address：显示目标程序中该隐含匹配的引用地址。</p>
<p>其他列与匹配表中的列含义一样，在此不再赘述。</p>
<p><strong>8.3.2 隐含匹配表操作</strong></p>
<p>我们可以看到隐含匹配表的右上角有这些图标 <img src="blob:file:///9f894896-6c7c-48ec-b3a0-53417aca94ad" srcset="/img/loading.gif" lazyload alt="202004031529_EA9A3H3NEF3PFJD.png">。</p>
<p>Accept Implied Match：如之前该隐含匹配不在匹配表中，则在匹配表中创建一个匹配。</p>
<p>Navigate References：当该操作被切换至开启状态时，子工具将会被导向至用于生成选中的隐含匹配的引用地址。</p>
<p>Navigate Match：当该操作被切换至开启状态时，子工具将会被导向至所选中的隐含匹配所在的地址。</p>
<p>类似地，我们也可以使用文本过滤器对表格中的内容作出筛选。</p>
<p>#ghidra使用手册</p>
<p><strong>8.4 标记物表</strong></p>
<p>标记一个程序意味着向该程序中添加信息以便我们更好的理解这个程序。我们会在源程序作出标记，并希望将其转移到目标程序的相同函数或数据上。而版本跟踪中的标记物窗口便能够帮助我们做到这一点。标记物表会显示当前所选中匹配的标志物。</p>
<p><img src="blob:file:///4eb12c82-d250-4e8b-96b3-887fa98b947d" srcset="/img/loading.gif" lazyload alt="202004031530_GBXRXJFE88AF8CV.png"></p>
<p>图8-11 标记物表</p>
<p>在标记物表的下方，我们可以看到源程序与目标程序的陈列窗口。此外，我们也可以将其切换为反编译窗口查看。</p>
<p>当我们确定一个函数或是数据匹配正确后，我们可以选择应用或是忽略单个标记物。应用标记物将会使目标程序使用源程序的标记物。</p>
<p><strong>8.4.1 标记物表内容</strong></p>
<p>标记物表中含有以下列：</p>
<p>Status：当前标记物的状态，指示该标记物未被应用&#x2F;已被应用&#x2F;已被拒绝，等等。</p>
<p>Source Address：源程序中该标记物的地址。</p>
<p>Dest Address：该标记物将会被应用或已被应用于目标程序当中的地址。如果当前的关联器不能决定一个目标地址，且用户没有手动指定一个目标地址，该处为空。</p>
<p>Displacement：显示目标地址与源地址的相对位移。</p>
<p>Markup Type：指示标记物的类型。</p>
<p>Source Value：源地址当中标记物的值。</p>
<p>Current Dest Value：当前目标程序中标记物的值。</p>
<p>Original Dest Value：目标程序中标记物的初始值。如果该标记物仍未被应用，那么该值也将是当前的目标程序中标记物的值。</p>
<p>其中，标记类型（Markup Type）包括以下几种：</p>
<p>Function Name：该函数的名称。任何源程序中的非默认名称都可以替换目标程序中的函数名。所谓默认名称，指以FUN_开头的函数名。我们可以选择只替换目标程序中的默认函数名，也可以选择不论是否默认函数名，都对目标程序中的函数名做出替换。</p>
<p>Function Signature：函数签名，其中包括返回类型，参数个数，每个参数的数据类型、名称和注释，函数是否含有可变参数。函数签名标记中，有几个其他的标记应用选项。</p>
<p>    Return Type and Parameter DataTypes：</p>
<p>    当数据类型（data types）被应用，默认的数据类型，即一个未定义的字节，将不会替代任何其他数据类型。一个指定大小的未定义数据类型将不会替代一个定义的数据类型。一个定义的数据类型可以替代任意其他的数据类型，但当选项被设置为Replace Undefined Data Types Only且目标是一个定义的数据类型时，其不会取代。</p>
<p>    Parameter Names：</p>
<p>    一个默认的参数名以param_开头。源程序中默认的参数名将不会替代目标程序中定义的参数名。</p>
<p>    如果我们对参数名Priority Replace选择，不论替换名称是否基于它们的源类型。该选项让我们决定用户定义名称或是导入名称的更高优先级。我们也可以当它们的源类型相同时，指定源名称是否应该替代目标名称。</p>
<p>Label：位于指令或是定义数据上的标签可以取代或添加与目标程序上的关联地址。我们可以选择只在目标标签为默认时取代，或取代所有目标标签。</p>
<p>EOL Comment、Plate Comment、Pre Comment、Post Comment、Repeatable Comment：源程序中的对应注释可以被添加到目标程序的现存注释中，也可以简单地取代目标注释。</p>
<p><strong>8.4.2 标记物操作</strong></p>
<p>我们可以在标记物表中对标记物进行以下的操作。</p>
<p>操作|描述</p>
<p>|-|-|</p>
<p>Apply(Use Options; Force If Necessary)|这个操作会根据当前的标记物匹配选项应用标记物。对于每一个选中的标记物，该操作会强制应用选项。</p>
<p>Apply(Add As Primary)| 该操作会将所选中的标记物源值添加到目标值上。如果可能的话，源标记物将变成首要的标记物。</p>
<p>Apply(Add)| 该操作会将所选中的标记物源值添加到目标值上，目标标记物将仍会是首要的标记物。</p>
<p>Apply(Replace Default Only)| 仅在目标标记物值为默认时，该操作会用所选中的源标记物值替换目标标记物。</p>
<p>Apply(Replace First Only)| 仅当目标标记物处有只有唯一的定义的数据时，才用选中的源标记物替换目标标记物。</p>
<p>Apply(Replace)| 该操作用所选中的源标记物值替换目标标记物。</p>
<p>Don’t Care | 将标记物状态设为不关心。</p>
<p>Don’t Know| 将标记物状态设置为未知。</p>
<p>Reject| 该操作将标记物状态设置为拒绝的，该状态的标记物将在应用于匹配时被忽略。</p>
<p>Edit Destination Address| 我们可以手动地指定目标标记物地址。</p>
<p>Reset|将标记物重置为未应用的状态。</p>
<p>在标记物表格当中，我们同样可以通过设置过滤器对表格的显示内容作出筛选。我们可以使用表格下方的文本过滤器，也可以点击文本框右边的图标打开通过标记物类型或是状态设置过滤器的对话窗口。</p>
<p><img src="blob:file:///18145e9e-96bf-4316-9fb9-8d771354d62c" srcset="/img/loading.gif" lazyload alt="202004031531_UYWCU3KX578MKRC.png"></p>
<p>图8-12 过滤器设置</p>
<p><strong>8.4.3 对比视图</strong></p>
<p>打开标记物表格后，我们可以看到其下方提供了目标与源程序的对比视图。该视图的显示内容可以为陈列窗口内容，也可以为反编译内容。</p>
<p><img src="blob:file:///7666e597-fc69-4634-8684-1bcc3a36b027" srcset="/img/loading.gif" lazyload alt="202004031531_BHP42BQQXMEW5DW.png"></p>
<p>图8-13 陈列窗口对比</p>
<p>上图即为陈列窗口对比所显示的内容。我们可以在标记物窗口工具栏的 <img src="blob:file:///c6e2c8a3-ff21-4d0e-82b2-016bd71ce595" srcset="/img/loading.gif" lazyload alt="202004031531_DC9CXBWQZZAPZ37.png">图标中，选择：</p>
<p>Show Listing Format Header：</p>
<p>当该选项被勾选时，将会于陈列窗口的上方显示格式头，以便我们对格式进行修改。修改的方式我们会在下一章介绍Browser Field Formatter时对如何更改陈列窗口的显示格式详细地进行介绍。</p>
<p>Show Listings Side By Side：</p>
<p>当该选项被勾选时，目标程序的显示内容会被显示于源程序右侧。未被勾选时，其将显示于源程序下方。</p>
<p>SYnchronize Scrolling：</p>
<p>当该选项被勾选时，当我们在源窗口或是目标窗口中滚动时，另一个窗口中会同步地进行滚动。未被勾选时，两边的滚动将会是独立的。</p>
<p>我们可以简单地在对比视图中拖动以应用标记物。这是一个快速且直观的应用标记物方法。相比之下，手动地编辑目标地址则比较费时。</p>
<p>拖动只可以将标记物应用于合理的位置。比如，我们不能够拖动一个已被应用的标记物。想要通过拖动应用标记物，点击源程序窗口中的一个标记物，并且将其拖动到目标窗口中想要应用的位置。拖动中，光标会指示所在位置能否被应用，完成拖动后，目标陈列窗口会更新，标记物表格中的标记物状态也会随之改变。</p>
<p>一些标记物只能被应用于特定的位置。举个例子，一个函数的名称或函数的签名只能被应用于函数上。因此目标函数的入口点将为预期的目标地址。在这种情况下，不论我们将标记物拖动到目标函数中的什么位置，目标地址都将变为目标函数的入口点。</p>
<p>#ghidra使用手册</p>
<p><strong>8.5 一个简单的实例</strong></p>
<p>在该示例中，我们先对crackme_example文件进行了分析，并对其做出了一些注释。之后我们想要将已经做出的分析与标记物内容应用于一个叫crackme_example的稍有不同的文件上，以节省时间。</p>
<p>按照8.1的内容中的流程创建好它们的版本跟踪会话后，我们可以看到，一个空的版本跟踪窗口，以及两个用默认CodeBrowser工具打开的程序窗口。我们可以点击红框中的图标，快速地运行关联器，并应用好的匹配。</p>
<p><img src="blob:file:///eb965567-638d-445a-b7eb-a19c2191dec6" srcset="/img/loading.gif" lazyload alt="202004031532_FRGAUHZZYJCTDQG.png"></p>
<p>图8-14 点击红框中的图标</p>
<p>之后，我们基于之前对crackme_example的了解，直接在匹配表格下方的文本过滤器中输入main，以查找main函数。我们先选中main函数，并从Windows→Version Tracking Markup Items中打开标记物表格。</p>
<p><img src="blob:file:///2271f780-cd65-416f-8ad5-0f3a7300f1ab" srcset="/img/loading.gif" lazyload alt="202004031532_MHFSG7VTC54794Z.png"></p>
<p>图8-15 许多标记物已经被自动应用</p>
<p>如上图，我们可以看出，所有的标记物已经被自动地应用。通常来说，目标程序与源程序之间改动越多，将会自动应用的标记物就会越少，因为关联器无法确定地将两者间的部分内容相关联。但是在该示例中，两者差距不大，因此我们甚至不需要手动地对版本跟踪会话进行更多的操作，便能够将main函数中所有的标记物应用于目标程序上。</p>
<p>#ghidra使用手册</p>
<p><strong>9.1 陈列窗口格式修改</strong></p>
<p>在2.1中，我们介绍了陈列窗口的功能。之前说过，Ghidra是高度可定制化的，我们可以运用Ghidra提供的Browser Field Formatter来对陈列窗口进行自定义，以便满足我们的需求与喜好。整个修改的过程都非常的简单与可视化。点击位于陈列窗口上方的Browser Field Formatter图标，便可以打开该界面。</p>
<p> <img src="blob:file:///5ae5499f-eea4-4e16-aa89-404daf151d51" srcset="/img/loading.gif" lazyload alt="202004031536_XQ5MHMTVB5FK8WM.png"></p>
<p>图9-1 Browser Field Formatter图标</p>
<p><strong>9.1.1 标签</strong></p>
<p>打开该界面后，我们首先看到最上端有若干标签。</p>
<p> <img src="blob:file:///f510a5ee-e034-4c3d-97d5-9f93a644a5ea" srcset="/img/loading.gif" lazyload alt="202004031537_PXDAMPZ66KQGS4F.png"></p>
<p>图9-2 Browser Field Formatter界面</p>
<p>这些标签分别代表了不同类别的信息，每一种类型的信息我们都可以单独地对其显示格式进行修改。</p>
<p>类别分别有：</p>
<p>类别名称|描述</p>
<p>Address Break| 分隔不连续的地址</p>
<p>Plate|显示区块的注释，其他种类的注释被包含于Instruction&#x2F;Data类别中</p>
<p>Function| 显示函数签名与函数相关属性</p>
<p>Variable|显示与一个函数相关的返回信息、参数以及局部变量</p>
<p>Instruction&#x2F;Data|显示指令或数据</p>
<p>Open Data| 显示数据结构或数组的内部</p>
<p>每一个地址都有一个或更多的以上类别的信息。当我们移动光标的时候，Browser Field Formatter会自动切换到当前光标位置所对应的标签。此外，当前光标位置所对应的区域也会被高亮显示。如下图所示，当我们将光标移动到一个地址上时，标签会被自动切换至Instruction&#x2F;Data，同时，其中所对应的Address区域会被高亮显示。</p>
<p><img src="blob:file:///05d2682a-591d-4900-b07e-3c3bdfcb8358" srcset="/img/loading.gif" lazyload alt="202004031537_8A6KVE5F957B6T4.png"></p>
<p>图9-3 光标移动至一个地址</p>
<p><strong>9.1.2 调整格式</strong></p>
<p><strong>增加区域</strong></p>
<p>我们可以通过右键点击Browser Field Formatter界面，选择Add Field→&lt;想添加的区域&gt;来添加新的区域。新的区域会被添加至右键点击的位置。</p>
<p><strong>移除区域</strong></p>
<p>右键点击想移除的区域，选择Remove Field。我们也可以右键并选择Remove All Fields来移除所有的区域。</p>
<p><strong>移动区域</strong></p>
<p>Browser Field Formatter中直观的图形界面让移动区域变得十分简单。我们只需要用鼠标拖拽区域便可以实现对其的移动。</p>
<p><strong>禁用区域</strong></p>
<p>右键点击区域，选择Disable Field可将其禁用。禁用区域将仍然占着位置，不过不会在陈列窗口中显示信息。</p>
<p><strong>启用区域</strong></p>
<p>右键点击被禁用的区域，选择Enable Field，便可以使该区域重新在陈列窗口中显示信息。</p>
<p><strong>添加行&#x2F;移除行</strong></p>
<p>如果觉得当前的行数不够放置足够的区域，我们可以右键并选择Insert Row来添加新的空行。这个空行会被添加至右键点击的位置。我们也可以右键并选择Remove Row来移除空行。</p>
<p><strong>重设格式</strong></p>
<p>我们可以通过右键点击Browser Field Formatter，并选中Reset Format来将当前类别标签中的格式恢复为默认设置。如果想要将所有类别的设置都恢复为默认，右键并选择Reset All Formats。</p>
<p>#ghidra使用手册</p>
<p><strong>9.2 撤回操作&#x2F;取消撤回</strong></p>
<p>Ghidra提供了小巧却十分强大的Undo&#x2F;Redo功能，即我们可以撤回做出的操作，也能够在这之后将重应用被撤回的操作。默认存储的操作历史大小为20。当我们执行了一系列的撤回操作后，便能做出同样次数的取消撤回操作。然而，如果我们在撤回操作后进行了其他的编辑，储存重新操作的列表会被清空。</p>
<p>想要撤回上一个做出的操作，选择Edit→Undo，或是在工具栏中点击 <img src="blob:file:///3bff1b5c-1dbd-402d-b07e-d1783c9f668b" srcset="/img/loading.gif" lazyload alt="202004031538_RN4M7QS6PTEJ6JF.png">图标。</p>
<p>想要取消上一个撤回，选择Edit→Redo，或是在工具栏中点击 <img src="blob:file:///35861b4a-7b78-41d8-ad4d-f80b28acedfe" srcset="/img/loading.gif" lazyload alt="202004031538_JEQ3H3ESTRGTNT3.png">图标。</p>
<p>#ghidra使用手册</p>
<p><strong>10.1 一个简单的Crackme</strong></p>
<p>在本章中，我们将会通过一些示例，线性地对Ghidra在实际使用中的操作流程做出示范。</p>
<p>由于我们并不期望正在阅读本章的读者，已经看过之前所有的内容，因此我们将尽量对每一步都做出详细的介绍，让该章节中的内容能单独形成一个简单的操作流程示范。</p>
<p><strong>10.1 一个简单的Crackme</strong></p>
<p>我们打开Ghidra，将想要分析的Crackme文件直接拖动到Ghidra的项目窗口当中。</p>
<p><img src="blob:file:///0fa7b222-cb70-4c77-b925-a6fe26c55696" srcset="/img/loading.gif" lazyload alt="202004031539_XAMUDBMF76H5UD4.png"></p>
<p>图10-1 导入程序</p>
<p>可以看到，程序的格式、语言都已经被自动分析，我们可以直接输入在Ghidra中该程序的名称，并点击OK。</p>
<p><img src="blob:file:///4ce581fe-0a31-4815-8809-6c490c885d7a" srcset="/img/loading.gif" lazyload alt="202004031539_MMJQKBWDKW3DQVU.png"></p>
<p>图10-2 信息总览</p>
<p>导入完成后，我们可以看到该文件信息总览。我们点击OK关闭该窗口，并在Ghidra的项目窗口中，选中已经导入的该程序，并双击以将其用默认的CodeBrowser工具打开。</p>
<p>打开后，Ghidra将提示我们，”simple_crackme has not been analyzed. Would you like to analyze it now?”。我们选择Yes。一个可以设置分析器的对话窗口将会随之弹出。</p>
<p><img src="blob:file:///dea09ba3-3188-4c7e-8cd4-94a9ba00f859" srcset="/img/loading.gif" lazyload alt="202004031540_2EDQHRPBGH4MCVA.png"></p>
<p>图10-3 分析选项</p>
<p>无需对这些选项作出修改，我们直接使用默认的分析器设置，点击Analyze。窗口右下角的进度条将显示分析的进度。该范例中的Crackme文件非常小，因此分析将会极快地结束。</p>
<p>对于这种简单小巧的Crackme，我们往往希望找到main函数作为开始分析的切入点。该示例中，我们在界面左侧的Symbol Tree窗口中，点击Functions→main。</p>
<p> <img src="blob:file:///0fc5ccf4-0640-4a2d-a6a6-642bf4a84654" srcset="/img/loading.gif" lazyload alt="202004031540_D3D4CWN3H5HVTSH.png"></p>
<p>图10-4 选中main函数</p>
<p>之后我们可以看到，在陈列（Listing）窗口与反编译（Decompile）窗口当中，显示出了main函数所对应的内容。</p>
<p> <img src="blob:file:///f24c1282-df5a-41a7-8ed6-132c1d09a691" srcset="/img/loading.gif" lazyload alt="202004031541_VMYSKA55AWGUXKE.png"></p>
<p>图10-5 main的反编译内容</p>
<p>我们可以从函数签名入手，对数据类型做出的定义，由于对一个数据类型的定义将会传播至程序中各个位置，所以这是一个高效的切入点。</p>
<p>如上图，我们可以看到，Ghidra反编译器得到的函数签名为:</p>
<p>undefined8 main(int iParm1, undefined8* puParm2)</p>
<p>不难看出，我们需要将其还原为符合C标准的main函数函数签名，也即</p>
<p>int main(int argc, char *argv)</p>
<p>我们在反编译窗口中，右键并选择Edit Function Signature，并将其进行修改。</p>
<p>需要注意的是，由于Ghidra反编译器的特性，argv之中的并不会被当成数组的标志，而是将被看待为参数名称的一部分。所以我们需要将char* argv[]以char** argv的形式进行表示</p>
<p><img src="blob:file:///a4c1651c-0701-479e-9f5d-e6619a2e415d" srcset="/img/loading.gif" lazyload alt="202004031541_9WKXEA38Q8PMZN7.png"></p>
<p>图10-6 修改函数签名</p>
<p>修改并应用新的函数签名后，我们可以看到，反编译的结果变得十分明了了。</p>
<p><img src="blob:file:///f8c120bd-2fe3-445b-8320-57846a47c327" srcset="/img/loading.gif" lazyload alt="202004031541_G7YS5WP2UQUQFUZ.png"></p>
<p>图10-7 更改函数签名后的编译结果</p>
<p>接下来，我们可以通过重命名变量，或是添加注释的方式，进一步地增加反编译的可读性。比如，此处明显地，sVar1为一个指示长度的变量。我们选中它，并点击快捷键L，重命名sVar1为length。我们也可以点击;，在一处添加注释。</p>
<p>通过几步简单的操作，相信我们都已经十分清楚，这个main函数在做什么了。总的来说，参数需要为恰好一个，长度为10且第五个字符串为’@‘。</p>
<p>对于更为复杂的程序来说，我们需要对编译结果以及其可读性进行优化的过程也会不可避免地更为漫长。不过以每个函数的函数签名作为切入点，将仍是非常高效的方式。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/article/0.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>p1yang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>August 29, 2023</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/article/0.html" title="">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/article/9d94ce31.html" title="预处理，编译，汇编，链接">
                        <span class="hidden-mobile">预处理，编译，汇编，链接</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-love"></i> <a href="https://p1yang.github.io" target="_blank" rel="nofollow noopener"><span>p1yang</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
